SCRIPT  /Users/kaizhi/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer.vim
Sourced 1 time
Total time:   0.000804
 Self time:   0.000804

count  total (s)   self (s)
    1              0.000005 function! wilder#renderer#redraw(apply_incsearch_fix) abort
                              call s:redraw(a:apply_incsearch_fix, 0)
                            endfunction
                            
    1              0.000002 function! wilder#renderer#redrawstatus(apply_incsearch_fix) abort
                              call s:redraw(a:apply_incsearch_fix, 1)
                            endfunction
                            
    1              0.000005 function! s:redraw(apply_incsearch_fix, is_redrawstatus) abort
                              if a:apply_incsearch_fix &&
                                    \ &incsearch &&
                                    \ (getcmdtype() ==# '/' || getcmdtype() ==# '?')
                                call feedkeys("\<C-R>\<BS>", 'n')
                                return
                              endif
                            
                              if a:is_redrawstatus
                                redrawstatus
                              else
                                redraw
                              endif
                            endfunction
                            
    1              0.000001 function! wilder#renderer#get_cmdheight() abort
                              if !has('nvim')
                                " For Vim, if cmdline exceeds cmdheight, the screen lines are pushed up
                                " similar to :mess, so we draw the popupmenu just above the cmdline.
                                " Lines exceeding cmdheight do not count into target line number.
                                return &cmdheight
                              endif
                            
                              let l:cmdline = getcmdline()
                            
                              " include the cmdline character
                              let l:display_width = strdisplaywidth(l:cmdline) + 1
                              let l:cmdheight = l:display_width / &columns + 1
                            
                              if l:cmdheight < &cmdheight
                                let l:cmdheight = &cmdheight
                              elseif l:cmdheight > 1
                                " Show the pum above the msgsep.
                                let l:has_msgsep = stridx(&display, 'msgsep') >= 0
                            
                                if l:has_msgsep
                                  let l:cmdheight += 1
                                endif
                              endif
                            
                              return l:cmdheight
                            endfunction
                            
    1              0.000002 function! wilder#renderer#pre_draw(components, ctx, result) abort
                              let l:should_draw = 0
                            
                              for l:Component in a:components
                                let l:should_draw += s:pre_draw(l:Component, a:ctx, a:result)
                              endfor
                            
                              return l:should_draw
                            endfunction
                            
    1              0.000001 function! s:pre_draw(component, ctx, result) abort
                              if type(a:component) isnot v:t_dict
                                return a:ctx.done
                              endif
                            
                              if has_key(a:component, 'pre_draw')
                                return a:component.pre_draw(a:ctx, a:result)
                              endif
                            
                              return a:ctx.done || get(a:component, 'dynamic', 0)
                            endfunction
                            
    1              0.000001 function! wilder#renderer#call_component_pre_hook(ctx, component) abort
                              if type(a:component) is v:t_dict &&
                                    \ has_key(a:component, 'pre_hook')
                                call a:component['pre_hook'](a:ctx)
                              endif
                            endfunction
                            
    1              0.000001 function! wilder#renderer#call_component_post_hook(ctx, component) abort
                              if type(a:component) is v:t_dict &&
                                    \ has_key(a:component, 'post_hook')
                                call a:component['post_hook'](a:ctx)
                              endif
                            endfunction

SCRIPT  /Users/kaizhi/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/pipeline.vim
Sourced 1 time
Total time:   0.000283
 Self time:   0.000283

count  total (s)   self (s)
    1              0.000004 let s:handler_registry = {}
    1              0.000001 let s:partial_results = {}
    1              0.000001 let s:id_index = 0
    1              0.000001 let s:last_cleared_id = -1
                            
    1              0.000001 function! wilder#pipeline#clear_handlers() abort
                              let s:last_cleared_id = s:id_index
                              let s:handler_registry = {}
                              let s:partial_results = {}
                            endfunction
                            
    1              0.000001 function! wilder#pipeline#resolve(ctx, x) abort
                              call s:handle(a:ctx, a:x, 'resolve')
                            endfunction
                            
    1              0.000001 function! wilder#pipeline#reject(ctx, x) abort
                              call s:handle(a:ctx, a:x, 'reject')
                            endfunction
                            
    1              0.000001 function! s:partial_error_message(key, x)
                              let l:message = 'wilder#' . a:key . '()'
                              let l:message .= ' ''partial'' only supported for lists: ' . string(a:x)
                            
                              return l:message
                            endfunction
                            
    1              0.000001 function! s:handle(ctx, x, key) abort
                              let l:handler_id = get(a:ctx, 'handler_id', 0)
                            
                              if !has_key(s:handler_registry, l:handler_id)
                                " only show error if handler has not been cleared
                                if l:handler_id > s:last_cleared_id
                                  let l:message = 'wilder#' . a:key . '()'
                                  let l:message .= ' handler not found - id: ' . l:handler_id
                                  let l:message .= ': ' . string(a:x)
                            
                                  call s:echoerr(l:message)
                                endif
                            
                                return
                              endif
                            
                              let l:X = a:x
                              let l:handler = s:handler_registry[l:handler_id]
                            
                              if get(a:ctx, 'partial', 0)
                                if type(l:X) isnot v:t_list
                                  call l:handler.on_error(a:ctx,
                                        \ 'pipeline: ' . s:partial_error_message(a:key, l:X))
                                  return
                                endif
                            
                                if !has_key(s:partial_results, l:handler_id)
                                  let s:partial_results[l:handler_id] = l:X
                                else
                                  let s:partial_results[l:handler_id] += l:X
                                endif
                            
                                return
                              endif
                            
                              unlet s:handler_registry[l:handler_id]
                            
                              if has_key(s:partial_results, l:handler_id)
                                if type(l:X) isnot v:t_list
                                  call l:handler.on_error(a:ctx,
                                        \ 'pipeline: ' . s:partial_error_message(a:key, l:X))
                                  return
                                endif
                            
                                let l:X = s:partial_results[l:handler_id] + l:X
                                unlet s:partial_results[l:handler_id]
                              endif
                            
                              if a:key ==# 'reject'
                                call l:handler.on_error(a:ctx, l:X)
                                return
                              endif
                            
                              try
                                call l:handler.on_finish(a:ctx, l:X)
                              catch
                                call l:handler.on_error(a:ctx, 'pipeline: ' . v:exception)
                              endtry
                            endfunction
                            
    1              0.000002 function! wilder#pipeline#run(pipeline, on_finish, on_error, ctx, x) abort
                              let l:pipeline = type(a:pipeline) isnot v:t_list
                                    \ ? [a:pipeline]
                                    \ : a:pipeline
                            
                              return s:run(l:pipeline, a:on_finish, a:on_error, a:ctx, a:x, 0)
                            endfunction
                            
    1              0.000001 function! s:call(f, ctx, handler_id) abort
                              let a:ctx.handler_id = a:handler_id
                            
                              try
                                call a:f(a:ctx)
                              catch
                                call wilder#reject(a:ctx, 'pipeline: ' . v:exception)
                              endtry
                            endfunction
                            
    1              0.000002 function! s:prepare_call(f, pipeline, on_finish, on_error, ctx, i)
                              let l:handler = {
                                    \ 'on_finish': {ctx, x -> s:run(a:pipeline, a:on_finish, a:on_error, ctx, x, a:i)},
                                    \ 'on_error': {ctx, x -> a:on_error(ctx, x)},
                                    \ }
                            
                              let s:id_index += 1
                              let l:handler_id = s:id_index
                              let s:handler_registry[s:id_index] = l:handler
                            
                              call timer_start(0, {_ -> s:call(a:f, a:ctx, l:handler_id)})
                            endfunction
                            
    1              0.000001 function! s:run(pipeline, on_finish, on_error, ctx, x, i) abort
                              if a:x is v:false || a:x is v:true
                                call a:on_finish(a:ctx, a:x)
                                return
                              endif
                            
                              if type(a:x) is v:t_func
                                let l:ctx = copy(a:ctx)
                                call s:prepare_call(a:x, a:pipeline, a:on_finish, a:on_error, l:ctx, a:i)
                                return
                              endif
                            
                              let l:x = a:x
                              let l:i = a:i
                            
                              while l:i < len(a:pipeline)
                                let l:F = a:pipeline[l:i]
                            
                                if type(l:F) isnot v:t_func
                                  call a:on_error(a:ctx, 'pipeline: expected function but got: ' . string(l:F))
                                  return
                                endif
                            
                                try
                                  let l:Result = l:F(a:ctx, l:x)
                                catch
                                  call a:on_error(a:ctx, 'pipeline: ' . v:exception)
                                  return
                                endtry
                            
                                if l:Result is v:false || l:Result is v:true
                                  call a:on_finish(a:ctx, l:Result)
                                  return
                                endif
                            
                                if type(l:Result) is v:t_func
                                  let l:ctx = copy(a:ctx)
                                  call s:prepare_call(l:Result, a:pipeline, a:on_finish, a:on_error, l:ctx, l:i+1)
                                  return
                                endif
                            
                                let l:x = l:Result
                                let l:i += 1
                              endwhile
                            
                              call a:on_finish(a:ctx, l:x)
                            endfunction
                            
    1              0.000001 function! wilder#pipeline#wait(f, on_finish) abort
                              let l:state = {
                                    \ 'f': a:f,
                                    \ 'on_finish': a:on_finish,
                                    \ }
                            
                              return {ctx -> s:wait_start(l:state, ctx)}
                            endfunction
                            
    1              0.000001 function! s:wait_start(state, ctx)
                              let a:state.wait_handler_id = a:ctx.handler_id
                            
                              let a:state.handler = {
                                    \ 'on_finish': {ctx, x -> s:wait_on_finish(a:state, ctx, x)},
                                    \ 'on_error': {ctx, x -> s:wait_on_error(a:state, ctx, x)},
                                    \ }
                            
                              call s:wait_call(a:state, a:ctx)
                            endfunction
                            
    1              0.000001 function! s:wait_call(state, ctx)
                              try
                                if type(a:state.f) is v:t_func
                                  let l:ctx = copy(a:ctx)
                            
                                  let s:id_index += 1
                                  let l:id_index = s:id_index
                                  let s:handler_registry[s:id_index] = a:state.handler
                            
                                  call timer_start(0, {_ -> s:call(a:state.f, l:ctx, l:id_index)})
                                else
                                  let a:ctx.handler_id = a:state.wait_handler_id
                                  call a:state.on_finish(a:ctx, a:state.f)
                                endif
                              catch
                                let a:ctx.handler_id = a:state.wait_handler_id
                                call s:wait_on_error(a:state, a:ctx, v:exception)
                              endtry
                            endfunction
                            
    1              0.000001 function! s:wait_on_finish(state, ctx, x)
                              if type(a:x) is v:t_func
                                let a:state.f = a:x
                                call s:wait_call(a:state, a:ctx)
                                return
                              endif
                            
                              let l:ctx = copy(a:ctx)
                              let l:ctx.handler_id = a:state.wait_handler_id
                            
                              try
                                call a:state.on_finish(l:ctx, a:x)
                              catch
                                call wilder#reject(l:ctx, v:exception)
                              endtry
                            endfunction
                            
    1              0.000001 function! s:wait_on_error(state, ctx, x)
                              let l:ctx = copy(a:ctx)
                              let l:ctx.handler_id = a:state.wait_handler_id
                            
                              call wilder#reject(l:ctx, a:x)
                            endfunction
                            
    1              0.000001 function! s:echoerr(message)
                              " avoid echoerr since this in a try-catch block
                              " see try-echoerr
                              echohl ErrorMsg
                              echomsg a:message
                              echohl Normal
                            endfunction

SCRIPT  /Users/kaizhi/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/cmdline/main.vim
Sourced 1 time
Total time:   0.001166
 Self time:   0.001166

count  total (s)   self (s)
    1              0.000020 let s:command_modifiers = {
                                  \ 'aboveleft': 1,
                                  \ 'argdo': 1,
                                  \ 'belowright': 1,
                                  \ 'botright': 1,
                                  \ 'browse': 1,
                                  \ 'bufdo': 1,
                                  \ 'cdo': 1,
                                  \ 'cfdo': 1,
                                  \ 'confirm': 1,
                                  \ 'debug': 1,
                                  \ 'folddoclosed': 1,
                                  \ 'folddoopen': 1,
                                  \ 'hide': 1,
                                  \ 'keepalt': 1,
                                  \ 'keepjumps': 1,
                                  \ 'keepmarks': 1,
                                  \ 'keeppatterns': 1,
                                  \ 'ldo': 1,
                                  \ 'leftabove': 1,
                                  \ 'lfdo': 1,
                                  \ 'lockmarks': 1,
                                  \ 'noautocmd': 1,
                                  \ 'noswapfile': 1,
                                  \ 'rightbelow': 1,
                                  \ 'sandbox': 1,
                                  \ 'silent': 1,
                                  \ 'tab': 1,
                                  \ 'tabdo': 1,
                                  \ 'topleft': 1,
                                  \ 'verbose': 1,
                                  \ 'vertical': 1,
                                  \ 'windo': 1,
                                  \ }
                            
    1              0.000001 function! wilder#cmdline#main#do(ctx) abort
                              " default
                              let a:ctx.expand = 'command'
                              let a:ctx.force = 0
                            
                              if empty(a:ctx.cmdline[a:ctx.pos :])
                                return
                              endif
                            
                              if !wilder#cmdline#main#skip_whitespace(a:ctx)
                                return
                              endif
                            
                              " check if comment
                              if a:ctx.cmdline[a:ctx.pos] ==# '"'
                                let a:ctx.pos = len(a:ctx.cmdline)
                                let a:ctx.expand = 'nothing'
                                return
                              endif
                            
                              " skip range
                              call wilder#cmdline#skip_range#do(a:ctx)
                            
                              if !wilder#cmdline#main#skip_whitespace(a:ctx)
                                return
                              endif
                            
                              if a:ctx.cmdline[a:ctx.pos] ==# '"'
                                let a:ctx.pos = len(a:ctx.cmdline)
                                let a:ctx.expand = 'nothing'
                                return
                              endif
                            
                              " check if starts with | or :
                              " treat as a new command
                              if a:ctx.cmdline[a:ctx.pos] ==# '|' || a:ctx.cmdline[a:ctx.pos] ==# ':'
                                let a:ctx.pos += 1
                                let a:ctx.cmd = ''
                            
                                call wilder#cmdline#main#do(a:ctx)
                            
                                return
                              endif
                            
                              let l:is_user_cmd = 0
                            
                              if a:ctx.cmdline[a:ctx.pos] ==# 'k' && a:ctx.cmdline[a:ctx.pos + 1] !=# 'e'
                                let a:ctx.cmd = 'k'
                                let a:ctx.pos += 1
                            
                                return
                              else
                                let l:cmd_start = a:ctx.pos
                            
                                let l:char = a:ctx.cmdline[a:ctx.pos]
                            
                                if l:char >=# 'A' && l:char <=# 'Z'
                                  " user-defined command can contain digits
                                  while l:char >=# 'a' && l:char <=# 'z' ||
                                        \ l:char >=# 'A' && l:char <=# 'Z' ||
                                        \ l:char >=# '0' && l:char <=# '9'
                                    let a:ctx.pos += 1
                                    let l:char = a:ctx.cmdline[a:ctx.pos]
                                  endwhile
                            
                                  let a:ctx.cmd = a:ctx.cmdline[l:cmd_start : a:ctx.pos - 1]
                                  let l:is_user_cmd = 1
                                else
                                  " non-alphabet command
                                  if stridx('@*!=><&~#', l:char) != -1
                                    let a:ctx.pos += 1
                                    let l:char = a:ctx.cmdline[a:ctx.pos]
                                  else
                                    " py3, python3, py3file and py3do are the only commands with numbers
                                    " all other commands are alphabet only
                                    if a:ctx.cmdline[a:ctx.pos] ==# 'p' &&
                                          \ a:ctx.cmdline[a:ctx.pos + 1] ==# 'y' &&
                                          \ a:ctx.cmdline[a:ctx.pos + 2] ==# '3'
                                      let a:ctx.pos += 3
                                      let l:char = a:ctx.cmdline[a:ctx.pos]
                                    endif
                            
                                    " this should check for [a-zA-Z] only, but the Vim implementation
                                    " skips over wildcards. This matters for commands which accept
                                    " non-alphanumeric arugments e.g. 'e*' would be parsed as an 'edit'
                                    " command with a '*' argument otherwise. These commands typically
                                    " don't need a space between the command and argument e.g. 'e++opt'
                                    " is a valid command.
                                    while l:char >=# 'a' && l:char <=# 'z' ||
                                          \ l:char >=# 'A' && l:char <=# 'Z' ||
                                          \ l:char ==# '*'
                                      let a:ctx.pos += 1
                                      let l:char = a:ctx.cmdline[a:ctx.pos]
                                    endwhile
                                  endif
                            
                                  if a:ctx.pos == l:cmd_start
                                    let a:ctx.expand = 'unsuccessful'
                                    return
                                  endif
                            
                                  " find the command
                                  if a:ctx.pos > l:cmd_start
                                    let l:cmd = a:ctx.cmdline[l:cmd_start : a:ctx.pos - 1]
                                    let l:len = a:ctx.pos - l:cmd_start
                            
                                    let l:char = l:cmd[0]
                                    if l:char < 'a' || l:char > 'z'
                                      let l:char = 'z'
                                    endif
                            
                                    let l:next_char = nr2char(char2nr(l:char) + 1)
                            
                                    let l:i = s:command_char_pos[l:char]
                                    let l:end = get(s:command_char_pos, 'l:next_char', len(s:commands))
                            
                                    while l:i < l:end
                                      let l:command = s:commands[l:i]
                                      if l:cmd ==# l:command[: l:len - 1]
                                        let a:ctx.cmd = l:command
                                        break
                                      endif
                            
                                      let l:i += 1
                                    endwhile
                                  endif
                                endif
                              endif
                            
                              " cursor is touching command and ends in alpha-numeric character
                              " complete the command name
                              if a:ctx.pos == len(a:ctx.cmdline)
                                let l:char = a:ctx.cmdline[a:ctx.pos - 1]
                            
                                if l:char >=# 'a' && l:char <=# 'z' ||
                                      \ l:char >=# 'A' && l:char <=# 'Z' ||
                                      \ l:char >=# '0' && l:char <=# '9'
                                  let a:ctx.pos = l:cmd_start
                                  let a:ctx.cmd = ''
                                  " expand commands
                                  return
                                endif
                              endif
                            
                              " no matching command found, treat as no arguments
                              if empty(a:ctx.cmd)
                                " 2 or 3-letter substitute command, takes no arguments
                                if a:ctx.cmdline[l:cmd_start] ==# 's' &&
                                      \ stridx('cgriI', a:ctx.cmdline[l:cmd_start + 1]) != -1
                                  let a:ctx.cmd = 's'
                                endif
                            
                                let a:ctx.pos = len(a:ctx.cmdline)
                                let a:ctx.expand = 'nothing'
                                return
                              endif
                            
                              let a:ctx.expand = 'nothing'
                            
                              " handle !
                              if a:ctx.cmdline[a:ctx.pos] ==# '!'
                                let a:ctx.pos += 1
                                let a:ctx.force = 1
                              endif
                            
                              if has_key(s:command_modifiers, a:ctx.cmd)
                                let a:ctx.cmd = ''
                                let a:ctx.expand = ''
                            
                                call wilder#cmdline#main#do(a:ctx)
                            
                                return
                              endif
                            
                              call wilder#cmdline#main#skip_whitespace(a:ctx)
                            
                              let l:flags = get(s:command_flags, a:ctx.cmd, 0)
                            
                              let l:use_filter = 0
                            
                              if a:ctx.cmd ==# 'write' || a:ctx.cmd ==# 'update'
                                if a:ctx.cmdline[a:ctx.pos] ==# '>'
                                  if a:ctx.cmdline[a:ctx.pos + 1] ==# '>'
                                    let a:ctx.pos += 2
                                  endif
                            
                                  call wilder#cmdline#main#skip_whitespace(a:ctx)
                                endif
                            
                                if a:ctx.cmd ==# 'write' && a:ctx.cmdline[a:ctx.pos] ==# '!'
                                  let a:ctx.pos += 1
                                  let l:use_filter = 1
                                endif
                              elseif a:ctx.cmd ==# 'read'
                                if a:ctx.cmdline[a:ctx.pos] ==# '!'
                                  let a:ctx.pos += 1
                                  let l:use_filter = 1
                                else
                                  let l:use_filter = a:ctx.force
                                endif
                              elseif a:ctx.cmd ==# '<' || a:ctx.cmd ==# '>'
                                while a:ctx.cmdline[a:ctx.pos] ==# a:ctx.cmd
                                  let a:ctx.pos += 1
                                endwhile
                            
                                call wilder#cmdline#main#skip_whitespace(a:ctx)
                              endif
                            
                              " Handle +cmd or ++opt
                              if a:ctx.cmdline[a:ctx.pos] ==# '+' &&
                                    \ ((and(l:flags, s:EDITCMD) && !l:use_filter) ||
                                    \ and(l:flags, s:ARGOPT))
                                let l:allow_opt = 1
                                let l:allow_cmd = and(l:flags, s:EDITCMD) && !l:use_filter
                            
                                while a:ctx.cmdline[a:ctx.pos] ==# '+' &&
                                      \ a:ctx.pos < len(a:ctx.cmdline)
                                  let a:ctx.pos += 1
                            
                                  if a:ctx.cmdline[a:ctx.pos] ==# '+'
                                    if l:allow_opt
                                      let a:ctx.pos += 1
                                      let l:expand = 'file_opt'
                                    else
                                      let l:expand = 'nothing'
                                    endif
                                  elseif l:allow_cmd
                                    let l:expand = 'command'
                                    " ++opt must be before +cmd
                                    let l:allow_opt = 0
                                    " only 1 +cmd allowed
                                    let l:allow_cmd = 0
                                  else
                                    let l:expand = 'nothing'
                                  endif
                            
                                  let l:arg_start = a:ctx.pos
                            
                                  " skip to next arg
                                  while a:ctx.pos < len(a:ctx.cmdline)
                                        \ && !wilder#cmdline#main#is_whitespace(a:ctx.cmdline[a:ctx.pos])
                                    if a:ctx.cmdline[a:ctx.pos] ==# '\' &&
                                          \ a:ctx.pos + 1 < len(a:ctx.cmdline)
                                      let a:ctx.pos += 1
                                    endif
                            
                                    " TODO: multibyte
                                    let a:ctx.pos += 1
                                  endwhile
                            
                                  " still in command or option
                                  if empty(a:ctx.cmdline[a:ctx.pos])
                                    let a:ctx.pos = l:arg_start
                                    let a:ctx.expand = l:expand
                                    return
                                  endif
                            
                                  call wilder#cmdline#main#skip_whitespace(a:ctx)
                                endwhile
                            
                                if a:ctx.cmd ==# 'write' && a:ctx.cmdline[a:ctx.pos] ==# '!'
                                  let a:ctx.pos += 1
                                  let l:use_filter = 1
                                elseif a:ctx.cmd ==# 'read'
                                  if a:ctx.cmdline[a:ctx.pos] ==# '!'
                                    let a:ctx.pos += 1
                                    let l:use_filter = 1
                                  else
                                    let l:use_filter = a:ctx.force
                                  endif
                                endif
                              endif
                            
                              " look for | for new command and " for comment
                              if and(l:flags, s:TRLBAR) && !l:use_filter
                                if a:ctx.cmd ==# 'redir' &&
                                      \ a:ctx.cmdline[a:ctx.pos] ==# '@' &&
                                      \ a:ctx.cmdline[a:ctx.pos + 1] ==# '"'
                                  let a:ctx.pos += 2
                                endif
                            
                                let l:lookahead = a:ctx.pos
                                while l:lookahead < len(a:ctx.cmdline)
                                  if a:ctx.cmdline[l:lookahead] ==# "\<C-V>" || a:ctx.cmdline[l:lookahead] ==# '\'
                                    let l:lookahead += 1
                            
                                    if l:lookahead + 1 < len(a:ctx.cmdline)
                                      let l:lookahead += 1
                                    else
                                      break
                                    endif
                                  endif
                            
                                  " Check if " indicates a comment or start of string
                                  if a:ctx.cmdline[l:lookahead] ==# '"'
                                    let l:lookahead += 1
                            
                                    let l:end_quote_reached = 0
                                    " Consume until next char is " or end of cmdline is reached
                                    while l:lookahead < len(a:ctx.cmdline)
                                      if a:ctx.cmdline[l:lookahead] ==# '\'
                                        let l:lookahead += 1
                                      elseif a:ctx.cmdline[l:lookahead] ==# '"'
                                        let l:end_quote_reached = 1
                                        let l:lookahead += 1
                                        break
                                      endif
                            
                                      let l:lookahead += 1
                                    endwhile
                            
                                    " remaining part of cmdline is comment, treat as no arguments
                                    if !l:end_quote_reached
                                      let a:ctx.pos = len(a:ctx.cmdline)
                                      return
                                    endif
                            
                                  " start of new command
                                  elseif a:ctx.cmdline[l:lookahead] ==# '|'
                                    let a:ctx.pos = l:lookahead + 1
                                    let a:ctx.cmd = ''
                                    let a:ctx.expand = ''
                            
                                    call wilder#cmdline#main#do(a:ctx)
                            
                                    return
                                  endif
                            
                                  " TODO: multibyte
                                  let l:lookahead += 1
                                endwhile
                              endif
                            
                              " command does not take extra arguments
                              if !and(l:flags, s:EXTRA) && !l:is_user_cmd
                                " consume whitespace
                                call wilder#cmdline#main#skip_whitespace(a:ctx)
                            
                                " and check for | or "
                                if a:ctx.cmdline[a:ctx.pos] ==# '|'
                                  let a:ctx.pos += 1
                                  let a:ctx.cmd = ''
                                  let a:ctx.expand = ''
                            
                                  call wilder#cmdline#main#do(a:ctx)
                                  return
                                else
                                  " remaining part is either comment or invalid arguments
                                  " either way, treat as no arguments
                                  let a:ctx.pos = len(a:ctx.cmdline)
                                  let a:ctx.expand = 'nothing'
                                  return
                                endif
                              endif
                            
                            
                              if l:use_filter || a:ctx.cmd ==# '!' || a:ctx.cmd ==# 'terminal'
                                let l:before_args = a:ctx.pos
                            
                                if !wilder#cmdline#main#skip_nonwhitespace(a:ctx)
                                  let a:ctx.pos = l:before_args
                                  let a:ctx.expand = 'shellcmd'
                                  return
                                endif
                            
                                " Reset pos back to before_args
                                let a:ctx.pos = l:before_args
                              endif
                            
                              if and(l:flags, s:XFILE)
                                " TODO: handle backticks :h backtick-expansion
                            
                                let l:arg_start = a:ctx.pos
                            
                                " Check if completing $ENV
                                if a:ctx.cmdline[a:ctx.pos] ==# '$'
                                  let l:arg_start = a:ctx.pos
                                  let a:ctx.pos += 1
                            
                                  while a:ctx.pos < len(a:ctx.cmdline)
                                    let l:char = a:ctx.cmdline[a:ctx.pos]
                                    if !s:is_idc(l:char)
                                      break
                                    endif
                            
                                    let a:ctx.pos += 1
                                  endwhile
                            
                                  if a:ctx.pos == len(a:ctx.cmdline)
                                    let a:ctx.expand = 'environment'
                                    let a:ctx.pos = l:arg_start + 1
                                    return
                                  endif
                                endif
                            
                                " Check if completing ~user
                                if a:ctx.cmdline[a:ctx.pos] ==# '~'
                                  let l:allow_backslash = has('win32') || has('win64')
                            
                                  while a:ctx.pos < len(a:ctx.cmdline)
                                    let l:char = a:ctx.cmdline[a:ctx.pos]
                                    if l:char ==# '/' ||
                                          \ l:allow_backslash && l:char ==# '\' ||
                                          \ !s:is_filec(l:char)
                                      break
                                    endif
                            
                                    let a:ctx.pos += 1
                                  endwhile
                            
                                  " + 1 since we want to expand ~ to $HOME
                                  if a:ctx.pos == len(a:ctx.cmdline) &&
                                        \ a:ctx.pos > l:arg_start + 1
                                    let a:ctx.expand = 'user'
                                    let a:ctx.pos = l:arg_start + 1
                                    return
                                  endif
                                endif
                            
                                let a:ctx.pos = l:arg_start
                                let a:ctx.expand = 'file'
                            
                                " vim assumes for XFILE, we can ignore arguments other than the last one but
                                " this is not necessarily true, we should not do this for NOSPC
                                if !and(l:flags, s:NOSPC)
                                  call s:move_pos_to_last_arg(a:ctx)
                                endif
                              endif
                            
                              if a:ctx.cmd ==# 'find' ||
                                    \ a:ctx.cmd ==# 'sfind' ||
                                    \ a:ctx.cmd ==# 'tabfind'
                                if a:ctx.expand ==# 'file'
                                  let a:ctx.expand = 'file_in_path'
                                endif
                                return
                              elseif a:ctx.cmd ==# 'cd' ||
                                    \ a:ctx.cmd ==# 'chdir' ||
                                    \ a:ctx.cmd ==# 'lcd' ||
                                    \ a:ctx.cmd ==# 'lchdir' ||
                                    \ a:ctx.cmd ==# 'tcd' ||
                                    \ a:ctx.cmd ==# 'tchdir'
                                if a:ctx.expand ==# 'file'
                                  let a:ctx.expand = 'dir'
                                endif
                                return
                              elseif a:ctx.cmd ==# 'help'
                                let a:ctx.expand = 'help'
                                return
                              " command modifiers
                              elseif has_key(s:command_modifiers, a:ctx.cmd)
                                let a:ctx.cmd = ''
                                let a:ctx.expand = ''
                            
                                call wilder#cmdline#main#do(a:ctx)
                            
                                return
                              elseif a:ctx.cmd ==# 'filter'
                                call wilder#cmdline#filter#do(a:ctx)
                                return
                              elseif a:ctx.cmd ==# 'match'
                                call wilder#cmdline#match#do(a:ctx)
                                return
                              elseif a:ctx.cmd ==# 'command'
                                call wilder#cmdline#command#do(a:ctx)
                                return
                              elseif a:ctx.cmd ==# 'delcommand'
                                let a:ctx.expand = 'user_commands'
                                return
                              elseif a:ctx.cmd ==# 'global' || a:ctx.cmd ==# 'vglobal'
                                call wilder#cmdline#global#do(a:ctx)
                                return
                              elseif a:ctx.cmd ==# '&' || a:ctx.cmd ==# 'substitute'
                                call wilder#cmdline#substitute#do(a:ctx)
                                return
                              elseif a:ctx.cmd ==# 'isearch' ||
                                    \ a:ctx.cmd ==# 'dsearch' ||
                                    \ a:ctx.cmd ==# 'ilist' ||
                                    \ a:ctx.cmd ==# 'dlist' ||
                                    \ a:ctx.cmd ==# 'ijump' ||
                                    \ a:ctx.cmd ==# 'psearch' ||
                                    \ a:ctx.cmd ==# 'djump' ||
                                    \ a:ctx.cmd ==# 'isplit' ||
                                    \ a:ctx.cmd ==# 'dsplit'
                                call wilder#cmdline#isearch#do(a:ctx)
                                return
                              elseif a:ctx.cmd ==# 'autocmd'
                                call wilder#cmdline#autocmd#do(a:ctx, 0)
                                return
                              elseif a:ctx.cmd ==# 'doautocmd' ||
                                    \ a:ctx.cmd ==# 'doautoall'
                                call wilder#cmdline#autocmd#do(a:ctx, 1)
                              elseif a:ctx.cmd ==# 'set' ||
                                    \ a:ctx.cmd ==# 'setglobal' ||
                                    \ a:ctx.cmd ==# 'setlocal'
                                call wilder#cmdline#set#do(a:ctx)
                                return
                              elseif a:ctx.cmd ==# 'tag' ||
                                    \ a:ctx.cmd ==# 'stag' ||
                                    \ a:ctx.cmd ==# 'ptag' ||
                                    \ a:ctx.cmd ==# 'ltag' ||
                                    \ a:ctx.cmd ==# 'tselect' ||
                                    \ a:ctx.cmd ==# 'stselect' ||
                                    \ a:ctx.cmd ==# 'tjump' ||
                                    \ a:ctx.cmd ==# 'stjump' ||
                                    \ a:ctx.cmd ==# 'ptselect' ||
                                    \ a:ctx.cmd ==# 'ptjump'
                                let a:ctx.expand = 'tags'
                                return
                              elseif a:ctx.cmd ==# 'augroup'
                                let a:ctx.expand = 'augroup'
                              elseif a:ctx.cmd ==# 'syntax'
                                call wilder#cmdline#syntax#do(a:ctx)
                                return
                              elseif a:ctx.cmd ==# 'let' ||
                                    \ a:ctx.cmd ==# 'if' ||
                                    \ a:ctx.cmd ==# 'elseif' ||
                                    \ a:ctx.cmd ==# 'while' ||
                                    \ a:ctx.cmd ==# 'for' ||
                                    \ a:ctx.cmd ==# 'echo' ||
                                    \ a:ctx.cmd ==# 'echon' ||
                                    \ a:ctx.cmd ==# 'execute' ||
                                    \ a:ctx.cmd ==# 'echomsg' ||
                                    \ a:ctx.cmd ==# 'echoerr' ||
                                    \ a:ctx.cmd ==# 'call' ||
                                    \ a:ctx.cmd ==# 'return' ||
                                    \ a:ctx.cmd ==# 'cexpr' ||
                                    \ a:ctx.cmd ==# 'caddexpr' ||
                                    \ a:ctx.cmd ==# 'cgetexpr' ||
                                    \ a:ctx.cmd ==# 'lexpr' ||
                                    \ a:ctx.cmd ==# 'laddexpr' ||
                                    \ a:ctx.cmd ==# 'lgetexpr'
                                "TODO call has extra arugments
                                call wilder#cmdline#let#do(a:ctx)
                                return
                              elseif a:ctx.cmd ==# 'unlet'
                                call wilder#cmdline#unlet#do(a:ctx)
                                return
                              elseif a:ctx.cmd ==# 'function'
                                let a:ctx.expand = 'function'
                                return
                              elseif a:ctx.cmd ==# 'delfunction'
                                let a:ctx.expand = 'user_func'
                                return
                              elseif a:ctx.cmd ==# 'echohl'
                                let a:ctx.expand = 'highlight'
                                " TODO: include None
                                return
                              elseif a:ctx.cmd ==# 'highlight'
                                call wilder#cmdline#highlight#do(a:ctx)
                                return
                              elseif a:ctx.cmd ==# 'cscope' ||
                                    \ a:ctx.cmd ==# 'lcscope' ||
                                    \ a:ctx.cmd ==# 'scscope'
                                call wilder#cmdline#cscope#do(a:ctx)
                                return
                              elseif a:ctx.cmd ==# 'sign'
                                call wilder#cmdline#sign#do(a:ctx)
                                return
                              elseif a:ctx.cmd ==# 'bdelete' ||
                                    \ a:ctx.cmd ==# 'bwipeout' ||
                                    \ a:ctx.cmd ==# 'bunload'
                                let a:ctx.expand = 'buffer'
                                return
                              elseif a:ctx.cmd ==# 'buffer' ||
                                    \ a:ctx.cmd ==# 'sbuffer' ||
                                    \ a:ctx.cmd ==# 'checktime'
                                let a:ctx.expand = 'buffer'
                                return
                              elseif a:ctx.cmd ==# 'abbreviate' ||
                                    \ a:ctx.cmd ==# 'unabbreviate' ||
                                    \ a:ctx.cmd[-3 :] ==# 'map' ||
                                    \ a:ctx.cmd[-6 :] ==# 'abbrev'
                                call wilder#cmdline#map#do(a:ctx)
                                return
                              elseif a:ctx.cmd[-8 :] ==# 'mapclear'
                                let a:ctx.expand = 'mapclear'
                                return
                              elseif a:ctx.cmd[-4 :] ==# 'menu'
                                call wilder#cmdline#menu#do(a:ctx)
                                return
                              elseif a:ctx.cmd ==# 'colorscheme'
                                let a:ctx.expand = 'color'
                                return
                              elseif a:ctx.cmd ==# 'compiler'
                                let a:ctx.expand = 'compiler'
                                return
                              elseif a:ctx.cmd ==# 'ownsyntax'
                                let a:ctx.expand = 'ownsyntax'
                                return
                              elseif a:ctx.cmd ==# 'packadd'
                                let a:ctx.expand = 'packadd'
                                return
                              elseif a:ctx.cmd ==# 'language'
                                let l:arg_start = a:ctx.pos
                                call wilder#cmdline#main#skip_nonwhitespace(a:ctx)
                            
                                if a:ctx.pos == len(a:ctx.cmdline)
                                  let a:ctx.expand = 'language'
                                  let a:ctx.pos = l:arg_start
                                else
                                  let l:subcommand = a:ctx.cmdline[l:arg_start : a:ctx.pos - 1]
                                  if l:subcommand ==# 'messages' ||
                                        \ l:subcommand ==# 'ctype' ||
                                        \ l:subcommand ==# 'time'
                                    let a:ctx.expand = 'locales'
                                    call wilder#cmdline#main#skip_whitespace(a:ctx)
                                  endif
                                endif
                              elseif a:ctx.cmd ==# 'profile'
                                call wilder#cmdline#profile#do(a:ctx)
                                return
                              elseif a:ctx.cmd ==# 'checkhealth'
                                let a:ctx.expand = 'checkhealth'
                                call s:move_pos_to_last_arg(a:ctx)
                                return
                              elseif a:ctx.cmd ==# 'behave'
                                let a:ctx.expand = 'behave'
                                return
                              elseif a:ctx.cmd ==# 'messages'
                                let a:ctx.expand = 'messages'
                                return
                              elseif a:ctx.cmd ==# 'history'
                                let a:ctx.expand = 'history'
                                return
                              elseif a:ctx.cmd ==# 'syntime'
                                let a:ctx.expand = 'syntime'
                                return
                              elseif a:ctx.cmd ==# 'argdelete'
                                let a:ctx.expand = 'arglist'
                                return
                              elseif a:ctx.cmd ==# 'lua'
                                let a:ctx.expand = 'lua'
                                return
                              endif
                            endfunction
                            
    1              0.000002 function! wilder#cmdline#main#has_file_args(cmd) abort
                              let l:flags = get(s:command_flags, a:cmd, 0)
                              return and(l:flags, s:XFILE)
                            endfunction
                            
    1              0.000001 function! wilder#cmdline#main#is_whitespace(char) abort
                              let l:nr = char2nr(a:char)
                              return a:char ==# ' ' || l:nr >= 9 && l:nr <= 13
                            endfunction
                            
    1              0.000001 function! wilder#cmdline#main#skip_whitespace(ctx) abort
                              if empty(a:ctx.cmdline[a:ctx.pos])
                                return 0
                              endif
                            
                              while wilder#cmdline#main#is_whitespace(a:ctx.cmdline[a:ctx.pos])
                                let a:ctx.pos += 1
                            
                                if empty(a:ctx.cmdline[a:ctx.pos])
                                  return 0
                                endif
                              endwhile
                            
                              return 1
                            endfunction
                            
    1              0.000001 function! wilder#cmdline#main#skip_nonwhitespace(ctx) abort
                              if empty(a:ctx.cmdline[a:ctx.pos])
                                return 0
                              endif
                            
                              while !wilder#cmdline#main#is_whitespace(a:ctx.cmdline[a:ctx.pos])
                                let a:ctx.pos += 1
                            
                                if empty(a:ctx.cmdline[a:ctx.pos])
                                  return 0
                                endif
                              endwhile
                            
                              return 1
                            endfunction
                            
    1              0.000001 function! wilder#cmdline#main#find_last_whitespace(ctx) abort
                              let l:arg_start = a:ctx.pos
                              let a:ctx.pos = len(a:ctx.cmdline) - 1
                              while a:ctx.pos >= l:arg_start
                                if wilder#cmdline#main#is_whitespace(a:ctx.cmdline[a:ctx.pos])
                                  let l:arg_start = a:ctx.pos + 1
                            
                                  break
                                endif
                                let a:ctx.pos -= 1
                              endwhile
                            endfunction
                            
    1              0.000001 function! s:move_pos_to_last_arg(ctx) abort
                              let l:last_arg = a:ctx.pos
                            
                              " find start of last argument
                              while a:ctx.pos < len(a:ctx.cmdline)
                                let l:char = a:ctx.cmdline[a:ctx.pos]
                            
                                if l:char ==# ' ' || l:char ==# "\t"
                                  let a:ctx.pos += 1
                                  let l:last_arg = a:ctx.pos
                                else
                                  if l:char ==# '\' && a:ctx.pos + 1 < len(a:ctx.cmdline)
                                    let a:ctx.pos += 1
                                  endif
                                  let a:ctx.pos += 1
                                endif
                              endwhile
                            
                              let a:ctx.pos = l:last_arg
                            endfunction
                            
    1              0.000001 function! s:is_filec(c) abort
                              return match(a:c, '\f') != -1
                            endfunction
                            
    1              0.000001 function! s:path_has_wildcard(c) abort
                              if has('win32') || has('win64')
                                let l:wildcards = '?*$[`'
                              else
                                let l:wildcards = "*?[{`'$"
                              endif
                            
                              return stridx(l:wildcards, a:c) != -1
                            endfunction
                            
    1              0.000001 function! s:isfilec_or_wc(c) abort
                              return s:is_filec(a:c) || a:c ==# ']' || s:path_has_wildcard(a:c)
                            endfunction
                            
    1              0.000001 function! s:is_idc(c) abort
                              return match(a:c, '\i') != -1
                            endfunction
                            
    1              0.000001 function! s:or(...) abort
                              let l:result = 0
                            
                              for l:arg in a:000
                                let l:result = or(l:result, l:arg)
                              endfor
                            
                              return l:result
                            endfunc
                            
    1              0.000002 let s:EXTRA      =    0x004
    1              0.000001 let s:XFILE      =    0x008
    1              0.000001 let s:NOSPC      =    0x010
    1              0.000001 let s:TRLBAR     =    0x100
    1              0.000001 let s:EDITCMD    =   0x8000
    1              0.000001 let s:ARGOPT     =  0x40000
                            
    1              0.000010 let s:command_char_pos = {
                                  \ 'a': 0,
                                  \ 'b': 19,
                                  \ 'c': 42,
                                  \ 'd': 104,
                                  \ 'e': 126,
                                  \ 'f': 146,
                                  \ 'g': 161,
                                  \ 'h': 167,
                                  \ 'i': 175,
                                  \ 'j': 193,
                                  \ 'k': 195,
                                  \ 'l': 200,
                                  \ 'm': 258,
                                  \ 'n': 276,
                                  \ 'o': 296,
                                  \ 'p': 307,
                                  \ 'q': 342,
                                  \ 'r': 345,
                                  \ 's': 365,
                                  \ 't': 430,
                                  \ 'u': 471,
                                  \ 'v': 482,
                                  \ 'w': 500,
                                  \ 'x': 516,
                                  \ 'y': 525,
                                  \ 'z': 526,
                                  \ '{': 527,
                                  \ }
                            
    1              0.000177 let s:commands = [
                                  \ 'append',
                                  \ 'abbreviate',
                                  \ 'abclear',
                                  \ 'aboveleft',
                                  \ 'all',
                                  \ 'amenu',
                                  \ 'anoremenu',
                                  \ 'args',
                                  \ 'argadd',
                                  \ 'argdelete',
                                  \ 'argdo',
                                  \ 'argedit',
                                  \ 'argglobal',
                                  \ 'arglocal',
                                  \ 'argument',
                                  \ 'ascii',
                                  \ 'autocmd',
                                  \ 'augroup',
                                  \ 'aunmenu',
                                  \ 'buffer',
                                  \ 'bNext',
                                  \ 'ball',
                                  \ 'badd',
                                  \ 'bdelete',
                                  \ 'behave',
                                  \ 'belowright',
                                  \ 'bfirst',
                                  \ 'blast',
                                  \ 'bmodified',
                                  \ 'bnext',
                                  \ 'botright',
                                  \ 'bprevious',
                                  \ 'brewind',
                                  \ 'break',
                                  \ 'breakadd',
                                  \ 'breakdel',
                                  \ 'breaklist',
                                  \ 'browse',
                                  \ 'buffers',
                                  \ 'bufdo',
                                  \ 'bunload',
                                  \ 'bwipeout',
                                  \ 'change',
                                  \ 'cNext',
                                  \ 'cNfile',
                                  \ 'cabbrev',
                                  \ 'cabclear',
                                  \ 'caddbuffer',
                                  \ 'caddexpr',
                                  \ 'caddfile',
                                  \ 'call',
                                  \ 'catch',
                                  \ 'cbuffer',
                                  \ 'cbottom',
                                  \ 'cc',
                                  \ 'cclose',
                                  \ 'cd',
                                  \ 'cdo',
                                  \ 'center',
                                  \ 'cexpr',
                                  \ 'cfile',
                                  \ 'cfdo',
                                  \ 'cfirst',
                                  \ 'cgetfile',
                                  \ 'cgetbuffer',
                                  \ 'cgetexpr',
                                  \ 'chdir',
                                  \ 'changes',
                                  \ 'checkhealth',
                                  \ 'checkpath',
                                  \ 'checktime',
                                  \ 'chistory',
                                  \ 'clist',
                                  \ 'clast',
                                  \ 'close',
                                  \ 'clearjumps',
                                  \ 'cmap',
                                  \ 'cmapclear',
                                  \ 'cmenu',
                                  \ 'cnext',
                                  \ 'cnewer',
                                  \ 'cnfile',
                                  \ 'cnoremap',
                                  \ 'cnoreabbrev',
                                  \ 'cnoremenu',
                                  \ 'copy',
                                  \ 'colder',
                                  \ 'colorscheme',
                                  \ 'command',
                                  \ 'comclear',
                                  \ 'compiler',
                                  \ 'continue',
                                  \ 'confirm',
                                  \ 'copen',
                                  \ 'cprevious',
                                  \ 'cpfile',
                                  \ 'cquit',
                                  \ 'crewind',
                                  \ 'cscope',
                                  \ 'cstag',
                                  \ 'cunmap',
                                  \ 'cunabbrev',
                                  \ 'cunmenu',
                                  \ 'cwindow',
                                  \ 'delete',
                                  \ 'delmarks',
                                  \ 'debug',
                                  \ 'debuggreedy',
                                  \ 'delcommand',
                                  \ 'delfunction',
                                  \ 'display',
                                  \ 'diffupdate',
                                  \ 'diffget',
                                  \ 'diffoff',
                                  \ 'diffpatch',
                                  \ 'diffput',
                                  \ 'diffsplit',
                                  \ 'diffthis',
                                  \ 'digraphs',
                                  \ 'djump',
                                  \ 'dlist',
                                  \ 'doautocmd',
                                  \ 'doautoall',
                                  \ 'drop',
                                  \ 'dsearch',
                                  \ 'dsplit',
                                  \ 'edit',
                                  \ 'earlier',
                                  \ 'echo',
                                  \ 'echoerr',
                                  \ 'echohl',
                                  \ 'echomsg',
                                  \ 'echon',
                                  \ 'else',
                                  \ 'elseif',
                                  \ 'emenu',
                                  \ 'endif',
                                  \ 'endfunction',
                                  \ 'endfor',
                                  \ 'endtry',
                                  \ 'endwhile',
                                  \ 'enew',
                                  \ 'ex',
                                  \ 'execute',
                                  \ 'exit',
                                  \ 'exusage',
                                  \ 'file',
                                  \ 'files',
                                  \ 'filetype',
                                  \ 'filter',
                                  \ 'find',
                                  \ 'finally',
                                  \ 'finish',
                                  \ 'first',
                                  \ 'fold',
                                  \ 'foldclose',
                                  \ 'folddoopen',
                                  \ 'folddoclosed',
                                  \ 'foldopen',
                                  \ 'for',
                                  \ 'function',
                                  \ 'global',
                                  \ 'goto',
                                  \ 'grep',
                                  \ 'grepadd',
                                  \ 'gui',
                                  \ 'gvim',
                                  \ 'help',
                                  \ 'helpclose',
                                  \ 'helpgrep',
                                  \ 'helptags',
                                  \ 'hardcopy',
                                  \ 'highlight',
                                  \ 'hide',
                                  \ 'history',
                                  \ 'insert',
                                  \ 'iabbrev',
                                  \ 'iabclear',
                                  \ 'if',
                                  \ 'ijump',
                                  \ 'ilist',
                                  \ 'imap',
                                  \ 'imapclear',
                                  \ 'imenu',
                                  \ 'inoremap',
                                  \ 'inoreabbrev',
                                  \ 'inoremenu',
                                  \ 'intro',
                                  \ 'isearch',
                                  \ 'isplit',
                                  \ 'iunmap',
                                  \ 'iunabbrev',
                                  \ 'iunmenu',
                                  \ 'join',
                                  \ 'jumps',
                                  \ 'k',
                                  \ 'keepmarks',
                                  \ 'keepjumps',
                                  \ 'keeppatterns',
                                  \ 'keepalt',
                                  \ 'list',
                                  \ 'lNext',
                                  \ 'lNfile',
                                  \ 'last',
                                  \ 'language',
                                  \ 'laddexpr',
                                  \ 'laddbuffer',
                                  \ 'laddfile',
                                  \ 'later',
                                  \ 'lbuffer',
                                  \ 'lbottom',
                                  \ 'lcd',
                                  \ 'lchdir',
                                  \ 'lclose',
                                  \ 'lcscope',
                                  \ 'ldo',
                                  \ 'left',
                                  \ 'leftabove',
                                  \ 'let',
                                  \ 'lexpr',
                                  \ 'lfile',
                                  \ 'lfdo',
                                  \ 'lfirst',
                                  \ 'lgetfile',
                                  \ 'lgetbuffer',
                                  \ 'lgetexpr',
                                  \ 'lgrep',
                                  \ 'lgrepadd',
                                  \ 'lhelpgrep',
                                  \ 'lhistory',
                                  \ 'll',
                                  \ 'llast',
                                  \ 'llist',
                                  \ 'lmap',
                                  \ 'lmapclear',
                                  \ 'lmake',
                                  \ 'lnoremap',
                                  \ 'lnext',
                                  \ 'lnewer',
                                  \ 'lnfile',
                                  \ 'loadview',
                                  \ 'loadkeymap',
                                  \ 'lockmarks',
                                  \ 'lockvar',
                                  \ 'lolder',
                                  \ 'lopen',
                                  \ 'lprevious',
                                  \ 'lpfile',
                                  \ 'lrewind',
                                  \ 'ltag',
                                  \ 'lunmap',
                                  \ 'lua',
                                  \ 'luado',
                                  \ 'luafile',
                                  \ 'lvimgrep',
                                  \ 'lvimgrepadd',
                                  \ 'lwindow',
                                  \ 'ls',
                                  \ 'move',
                                  \ 'mark',
                                  \ 'make',
                                  \ 'map',
                                  \ 'mapclear',
                                  \ 'marks',
                                  \ 'match',
                                  \ 'menu',
                                  \ 'menutranslate',
                                  \ 'messages',
                                  \ 'mkexrc',
                                  \ 'mksession',
                                  \ 'mkspell',
                                  \ 'mkvimrc',
                                  \ 'mkview',
                                  \ 'mode',
                                  \ 'mzscheme',
                                  \ 'mzfile',
                                  \ 'next',
                                  \ 'nbkey',
                                  \ 'nbclose',
                                  \ 'nbstart',
                                  \ 'new',
                                  \ 'nmap',
                                  \ 'nmapclear',
                                  \ 'nmenu',
                                  \ 'nnoremap',
                                  \ 'nnoremenu',
                                  \ 'noremap',
                                  \ 'noautocmd',
                                  \ 'nohlsearch',
                                  \ 'noreabbrev',
                                  \ 'noremenu',
                                  \ 'noswapfile',
                                  \ 'normal',
                                  \ 'number',
                                  \ 'nunmap',
                                  \ 'nunmenu',
                                  \ 'oldfiles',
                                  \ 'omap',
                                  \ 'omapclear',
                                  \ 'omenu',
                                  \ 'only',
                                  \ 'onoremap',
                                  \ 'onoremenu',
                                  \ 'options',
                                  \ 'ounmap',
                                  \ 'ounmenu',
                                  \ 'ownsyntax',
                                  \ 'print',
                                  \ 'packadd',
                                  \ 'packloadall',
                                  \ 'pclose',
                                  \ 'perl',
                                  \ 'perldo',
                                  \ 'pedit',
                                  \ 'pop',
                                  \ 'popup',
                                  \ 'ppop',
                                  \ 'preserve',
                                  \ 'previous',
                                  \ 'promptfind',
                                  \ 'promptrepl',
                                  \ 'profile',
                                  \ 'profdel',
                                  \ 'psearch',
                                  \ 'ptag',
                                  \ 'ptNext',
                                  \ 'ptfirst',
                                  \ 'ptjump',
                                  \ 'ptlast',
                                  \ 'ptnext',
                                  \ 'ptprevious',
                                  \ 'ptrewind',
                                  \ 'ptselect',
                                  \ 'put',
                                  \ 'pwd',
                                  \ 'python',
                                  \ 'pydo',
                                  \ 'pyfile',
                                  \ 'py3',
                                  \ 'py3do',
                                  \ 'python3',
                                  \ 'py3file',
                                  \ 'quit',
                                  \ 'quitall',
                                  \ 'qall',
                                  \ 'read',
                                  \ 'recover',
                                  \ 'redo',
                                  \ 'redir',
                                  \ 'redraw',
                                  \ 'redrawstatus',
                                  \ 'registers',
                                  \ 'resize',
                                  \ 'retab',
                                  \ 'return',
                                  \ 'rewind',
                                  \ 'right',
                                  \ 'rightbelow',
                                  \ 'rshada',
                                  \ 'runtime',
                                  \ 'rundo',
                                  \ 'ruby',
                                  \ 'rubydo',
                                  \ 'rubyfile',
                                  \ 'rviminfo',
                                  \ 'substitute',
                                  \ 'sNext',
                                  \ 'sargument',
                                  \ 'sall',
                                  \ 'sandbox',
                                  \ 'saveas',
                                  \ 'sbuffer',
                                  \ 'sbNext',
                                  \ 'sball',
                                  \ 'sbfirst',
                                  \ 'sblast',
                                  \ 'sbmodified',
                                  \ 'sbnext',
                                  \ 'sbprevious',
                                  \ 'sbrewind',
                                  \ 'scriptnames',
                                  \ 'scriptencoding',
                                  \ 'scscope',
                                  \ 'set',
                                  \ 'setfiletype',
                                  \ 'setglobal',
                                  \ 'setlocal',
                                  \ 'sfind',
                                  \ 'sfirst',
                                  \ 'simalt',
                                  \ 'sign',
                                  \ 'silent',
                                  \ 'sleep',
                                  \ 'slast',
                                  \ 'smagic',
                                  \ 'smap',
                                  \ 'smapclear',
                                  \ 'smenu',
                                  \ 'snext',
                                  \ 'snomagic',
                                  \ 'snoremap',
                                  \ 'snoremenu',
                                  \ 'source',
                                  \ 'sort',
                                  \ 'split',
                                  \ 'spellgood',
                                  \ 'spelldump',
                                  \ 'spellinfo',
                                  \ 'spellrepall',
                                  \ 'spellundo',
                                  \ 'spellwrong',
                                  \ 'sprevious',
                                  \ 'srewind',
                                  \ 'stop',
                                  \ 'stag',
                                  \ 'startinsert',
                                  \ 'startgreplace',
                                  \ 'startreplace',
                                  \ 'stopinsert',
                                  \ 'stjump',
                                  \ 'stselect',
                                  \ 'sunhide',
                                  \ 'sunmap',
                                  \ 'sunmenu',
                                  \ 'suspend',
                                  \ 'sview',
                                  \ 'swapname',
                                  \ 'syntax',
                                  \ 'syntime',
                                  \ 'syncbind',
                                  \ 't',
                                  \ 'tcd',
                                  \ 'tchdir',
                                  \ 'tNext',
                                  \ 'tag',
                                  \ 'tags',
                                  \ 'tab',
                                  \ 'tabclose',
                                  \ 'tabdo',
                                  \ 'tabedit',
                                  \ 'tabfind',
                                  \ 'tabfirst',
                                  \ 'tabmove',
                                  \ 'tablast',
                                  \ 'tabnext',
                                  \ 'tabnew',
                                  \ 'tabonly',
                                  \ 'tabprevious',
                                  \ 'tabNext',
                                  \ 'tabrewind',
                                  \ 'tabs',
                                  \ 'tcl',
                                  \ 'tcldo',
                                  \ 'tclfile',
                                  \ 'terminal',
                                  \ 'tfirst',
                                  \ 'throw',
                                  \ 'tjump',
                                  \ 'tlast',
                                  \ 'tmap',
                                  \ 'tmapclear',
                                  \ 'tmenu',
                                  \ 'tnext',
                                  \ 'tnoremap',
                                  \ 'topleft',
                                  \ 'tprevious',
                                  \ 'trewind',
                                  \ 'try',
                                  \ 'tselect',
                                  \ 'tunmap',
                                  \ 'tunmenu',
                                  \ 'undo',
                                  \ 'undojoin',
                                  \ 'undolist',
                                  \ 'unabbreviate',
                                  \ 'unhide',
                                  \ 'unlet',
                                  \ 'unlockvar',
                                  \ 'unmap',
                                  \ 'unmenu',
                                  \ 'unsilent',
                                  \ 'update',
                                  \ 'vglobal',
                                  \ 'version',
                                  \ 'verbose',
                                  \ 'vertical',
                                  \ 'visual',
                                  \ 'view',
                                  \ 'vimgrep',
                                  \ 'vimgrepadd',
                                  \ 'viusage',
                                  \ 'vmap',
                                  \ 'vmapclear',
                                  \ 'vmenu',
                                  \ 'vnoremap',
                                  \ 'vnew',
                                  \ 'vnoremenu',
                                  \ 'vsplit',
                                  \ 'vunmap',
                                  \ 'vunmenu',
                                  \ 'write',
                                  \ 'wNext',
                                  \ 'wall',
                                  \ 'while',
                                  \ 'winsize',
                                  \ 'wincmd',
                                  \ 'windo',
                                  \ 'winpos',
                                  \ 'wnext',
                                  \ 'wprevious',
                                  \ 'wq',
                                  \ 'wqall',
                                  \ 'wsverb',
                                  \ 'wshada',
                                  \ 'wundo',
                                  \ 'wviminfo',
                                  \ 'xit',
                                  \ 'xall',
                                  \ 'xmap',
                                  \ 'xmapclear',
                                  \ 'xmenu',
                                  \ 'xnoremap',
                                  \ 'xnoremenu',
                                  \ 'xunmap',
                                  \ 'xunmenu',
                                  \ 'yank',
                                  \ 'z',
                                  \ '!',
                                  \ '#',
                                  \ '&',
                                  \ '<',
                                  \ ':',
                                  \ '>',
                                  \ '@',
                                  \ 'Next',
                                  \ '~',
                                  \ ]
                            
    1              0.000247 let s:command_flags = {
                                  \ 'append': 3150083,
                                  \ 'abbreviate': 1059076,
                                  \ 'abclear': 1048836,
                                  \ 'aboveleft': 2180,
                                  \ 'all': 17667,
                                  \ 'amenu': 1079557,
                                  \ 'anoremenu': 1079557,
                                  \ 'args': 295182,
                                  \ 'argadd': 20751,
                                  \ 'argdelete': 16655,
                                  \ 'argdo': 18599,
                                  \ 'argedit': 315791,
                                  \ 'argglobal': 295182,
                                  \ 'arglocal': 295182,
                                  \ 'argument': 312583,
                                  \ 'ascii': 1573120,
                                  \ 'autocmd': 1058822,
                                  \ 'augroup': 1048854,
                                  \ 'aunmenu': 1059076,
                                  \ 'buffer': 247047,
                                  \ 'bNext': 50435,
                                  \ 'ball': 17665,
                                  \ 'badd': 1081756,
                                  \ 'bdelete': 83207,
                                  \ 'behave': 1048980,
                                  \ 'belowright': 2180,
                                  \ 'bfirst': 49411,
                                  \ 'blast': 49411,
                                  \ 'bmodified': 50435,
                                  \ 'bnext': 50435,
                                  \ 'botright': 2180,
                                  \ 'bprevious': 50435,
                                  \ 'brewind': 49411,
                                  \ 'break': 1573120,
                                  \ 'breakadd': 1048836,
                                  \ 'breakdel': 1048836,
                                  \ 'breaklist': 1048836,
                                  \ 'browse': 1050756,
                                  \ 'buffers': 1048838,
                                  \ 'bufdo': 18599,
                                  \ 'bunload': 83207,
                                  \ 'bwipeout': 214279,
                                  \ 'change': 3147075,
                                  \ 'cNext': 17667,
                                  \ 'cNfile': 17667,
                                  \ 'cabbrev': 1059076,
                                  \ 'cabclear': 1048836,
                                  \ 'caddbuffer': 16661,
                                  \ 'caddexpr': 2452,
                                  \ 'caddfile': 284,
                                  \ 'call': 1575045,
                                  \ 'catch': 1572868,
                                  \ 'cbuffer': 16663,
                                  \ 'cbottom': 256,
                                  \ 'cc': 17667,
                                  \ 'cclose': 17665,
                                  \ 'cd': 1048862,
                                  \ 'cdo': 18599,
                                  \ 'center': 3146053,
                                  \ 'cexpr': 2454,
                                  \ 'cfile': 286,
                                  \ 'cfdo': 18599,
                                  \ 'cfirst': 17667,
                                  \ 'cgetfile': 284,
                                  \ 'cgetbuffer': 16661,
                                  \ 'cgetexpr': 2452,
                                  \ 'chdir': 1048862,
                                  \ 'changes': 1048832,
                                  \ 'checkhealth': 260,
                                  \ 'checkpath': 1048834,
                                  \ 'checktime': 83205,
                                  \ 'chistory': 256,
                                  \ 'clist': 1048838,
                                  \ 'clast': 17667,
                                  \ 'close': 1066243,
                                  \ 'clearjumps': 1048832,
                                  \ 'cmap': 1059076,
                                  \ 'cmapclear': 1048836,
                                  \ 'cmenu': 1079557,
                                  \ 'cnext': 17667,
                                  \ 'cnewer': 17665,
                                  \ 'cnfile': 17667,
                                  \ 'cnoremap': 1059076,
                                  \ 'cnoreabbrev': 1059076,
                                  \ 'cnoremenu': 1079557,
                                  \ 'copy': 3146053,
                                  \ 'colder': 17665,
                                  \ 'colorscheme': 1048852,
                                  \ 'command': 1058822,
                                  \ 'comclear': 1048832,
                                  \ 'compiler': 1048854,
                                  \ 'continue': 1573120,
                                  \ 'confirm': 1050756,
                                  \ 'copen': 17665,
                                  \ 'cprevious': 17667,
                                  \ 'cpfile': 17667,
                                  \ 'cquit': 21763,
                                  \ 'crewind': 17667,
                                  \ 'cscope': 2060,
                                  \ 'cstag': 278,
                                  \ 'cunmap': 1059076,
                                  \ 'cunabbrev': 1059076,
                                  \ 'cunmenu': 1059076,
                                  \ 'cwindow': 17665,
                                  \ 'delete': 3147585,
                                  \ 'delmarks': 1048838,
                                  \ 'debug': 1575044,
                                  \ 'debuggreedy': 1069313,
                                  \ 'delcommand': 1048982,
                                  \ 'delfunction': 1048726,
                                  \ 'display': 1575172,
                                  \ 'diffupdate': 258,
                                  \ 'diffget': 2097413,
                                  \ 'diffoff': 258,
                                  \ 'diffpatch': 2097436,
                                  \ 'diffput': 261,
                                  \ 'diffsplit': 284,
                                  \ 'diffthis': 256,
                                  \ 'digraphs': 1048836,
                                  \ 'djump': 103,
                                  \ 'dlist': 1048679,
                                  \ 'doautocmd': 1048836,
                                  \ 'doautoall': 1048836,
                                  \ 'drop': 295308,
                                  \ 'dsearch': 1048679,
                                  \ 'dsplit': 103,
                                  \ 'edit': 295198,
                                  \ 'earlier': 1048852,
                                  \ 'echo': 1574916,
                                  \ 'echoerr': 1574916,
                                  \ 'echohl': 1573124,
                                  \ 'echomsg': 1574916,
                                  \ 'echon': 1574916,
                                  \ 'else': 1573120,
                                  \ 'elseif': 1574916,
                                  \ 'emenu': 1067397,
                                  \ 'endif': 1573120,
                                  \ 'endfunction': 1048832,
                                  \ 'endfor': 1573120,
                                  \ 'endtry': 1573120,
                                  \ 'endwhile': 1573120,
                                  \ 'enew': 258,
                                  \ 'ex': 295198,
                                  \ 'execute': 1574916,
                                  \ 'exit': 1311103,
                                  \ 'exusage': 256,
                                  \ 'file': 20767,
                                  \ 'files': 1048838,
                                  \ 'filetype': 1048836,
                                  \ 'filter': 2182,
                                  \ 'find': 311583,
                                  \ 'finally': 1573120,
                                  \ 'finish': 1573120,
                                  \ 'first': 295174,
                                  \ 'fold': 1573185,
                                  \ 'foldclose': 1573187,
                                  \ 'folddoopen': 2213,
                                  \ 'folddoclosed': 2213,
                                  \ 'foldopen': 1573187,
                                  \ 'for': 1574916,
                                  \ 'function': 1048582,
                                  \ 'global': 1572967,
                                  \ 'goto': 1590529,
                                  \ 'grep': 18831,
                                  \ 'grepadd': 18831,
                                  \ 'gui': 1343758,
                                  \ 'gvim': 1343758,
                                  \ 'help': 2054,
                                  \ 'helpclose': 17665,
                                  \ 'helpgrep': 2180,
                                  \ 'helptags': 1048972,
                                  \ 'hardcopy': 1319,
                                  \ 'highlight': 1573126,
                                  \ 'hide': 17671,
                                  \ 'history': 1048836,
                                  \ 'insert': 3145987,
                                  \ 'iabbrev': 1059076,
                                  \ 'iabclear': 1048836,
                                  \ 'if': 1574916,
                                  \ 'ijump': 103,
                                  \ 'ilist': 1048679,
                                  \ 'imap': 1059076,
                                  \ 'imapclear': 1048836,
                                  \ 'imenu': 1079557,
                                  \ 'inoremap': 1059076,
                                  \ 'inoreabbrev': 1059076,
                                  \ 'inoremenu': 1079557,
                                  \ 'intro': 1048832,
                                  \ 'isearch': 1048679,
                                  \ 'isplit': 103,
                                  \ 'iunmap': 1059076,
                                  \ 'iunabbrev': 1059076,
                                  \ 'iunmenu': 1059076,
                                  \ 'join': 7341379,
                                  \ 'jumps': 1048832,
                                  \ 'k': 1573141,
                                  \ 'keepmarks': 2180,
                                  \ 'keepjumps': 2180,
                                  \ 'keeppatterns': 2180,
                                  \ 'keepalt': 2180,
                                  \ 'list': 5244225,
                                  \ 'lNext': 17667,
                                  \ 'lNfile': 17667,
                                  \ 'last': 295174,
                                  \ 'language': 1048836,
                                  \ 'laddexpr': 2452,
                                  \ 'laddbuffer': 16661,
                                  \ 'laddfile': 284,
                                  \ 'later': 1048852,
                                  \ 'lbuffer': 16663,
                                  \ 'lbottom': 256,
                                  \ 'lcd': 1048862,
                                  \ 'lchdir': 1048862,
                                  \ 'lclose': 17665,
                                  \ 'lcscope': 2060,
                                  \ 'ldo': 18599,
                                  \ 'left': 3146053,
                                  \ 'leftabove': 2180,
                                  \ 'let': 1574916,
                                  \ 'lexpr': 2454,
                                  \ 'lfile': 286,
                                  \ 'lfdo': 18599,
                                  \ 'lfirst': 17667,
                                  \ 'lgetfile': 284,
                                  \ 'lgetbuffer': 16661,
                                  \ 'lgetexpr': 2452,
                                  \ 'lgrep': 18831,
                                  \ 'lgrepadd': 18831,
                                  \ 'lhelpgrep': 2180,
                                  \ 'lhistory': 256,
                                  \ 'll': 17667,
                                  \ 'llast': 17667,
                                  \ 'llist': 1048838,
                                  \ 'lmap': 1059076,
                                  \ 'lmapclear': 1048836,
                                  \ 'lmake': 2318,
                                  \ 'lnoremap': 1059076,
                                  \ 'lnext': 17667,
                                  \ 'lnewer': 17665,
                                  \ 'lnfile': 17667,
                                  \ 'loadview': 284,
                                  \ 'loadkeymap': 1048576,
                                  \ 'lockmarks': 2180,
                                  \ 'lockvar': 1572998,
                                  \ 'lolder': 17665,
                                  \ 'lopen': 17665,
                                  \ 'lprevious': 17667,
                                  \ 'lpfile': 17667,
                                  \ 'lrewind': 17667,
                                  \ 'ltag': 16662,
                                  \ 'lunmap': 1059076,
                                  \ 'lua': 1048709,
                                  \ 'luado': 1048741,
                                  \ 'luafile': 1048733,
                                  \ 'lvimgrep': 18831,
                                  \ 'lvimgrepadd': 18831,
                                  \ 'lwindow': 17665,
                                  \ 'ls': 1048838,
                                  \ 'move': 3146053,
                                  \ 'mark': 1573141,
                                  \ 'make': 2318,
                                  \ 'map': 1059078,
                                  \ 'mapclear': 1048838,
                                  \ 'marks': 1048836,
                                  \ 'match': 1064965,
                                  \ 'menu': 1079559,
                                  \ 'menutranslate': 1059076,
                                  \ 'messages': 1048837,
                                  \ 'mkexrc': 1048862,
                                  \ 'mksession': 286,
                                  \ 'mkspell': 2446,
                                  \ 'mkvimrc': 1048862,
                                  \ 'mkview': 286,
                                  \ 'mode': 1048852,
                                  \ 'mzscheme': 1573029,
                                  \ 'mzfile': 1048733,
                                  \ 'next': 311567,
                                  \ 'nbkey': 16516,
                                  \ 'nbclose': 1048832,
                                  \ 'nbstart': 1048852,
                                  \ 'new': 311583,
                                  \ 'nmap': 1059076,
                                  \ 'nmapclear': 1048836,
                                  \ 'nmenu': 1079557,
                                  \ 'nnoremap': 1059076,
                                  \ 'nnoremenu': 1079557,
                                  \ 'noremap': 1059078,
                                  \ 'noautocmd': 2180,
                                  \ 'nohlsearch': 1573120,
                                  \ 'noreabbrev': 1059076,
                                  \ 'noremenu': 1079559,
                                  \ 'noswapfile': 2180,
                                  \ 'normal': 1583239,
                                  \ 'number': 5244225,
                                  \ 'nunmap': 1059076,
                                  \ 'nunmenu': 1059076,
                                  \ 'oldfiles': 1573122,
                                  \ 'omap': 1059076,
                                  \ 'omapclear': 1048836,
                                  \ 'omenu': 1079557,
                                  \ 'only': 17667,
                                  \ 'onoremap': 1059076,
                                  \ 'onoremenu': 1079557,
                                  \ 'options': 256,
                                  \ 'ounmap': 1059076,
                                  \ 'ounmenu': 1059076,
                                  \ 'ownsyntax': 1574916,
                                  \ 'print': 5768513,
                                  \ 'packadd': 1573278,
                                  \ 'packloadall': 1573122,
                                  \ 'pclose': 258,
                                  \ 'perl': 1573029,
                                  \ 'perldo': 1048741,
                                  \ 'pedit': 295198,
                                  \ 'pop': 21763,
                                  \ 'popup': 1051014,
                                  \ 'ppop': 21763,
                                  \ 'preserve': 256,
                                  \ 'previous': 312583,
                                  \ 'promptfind': 1050628,
                                  \ 'promptrepl': 1050628,
                                  \ 'profile': 1048838,
                                  \ 'profdel': 1048836,
                                  \ 'psearch': 103,
                                  \ 'ptag': 20759,
                                  \ 'ptNext': 20739,
                                  \ 'ptfirst': 20739,
                                  \ 'ptjump': 278,
                                  \ 'ptlast': 258,
                                  \ 'ptnext': 20739,
                                  \ 'ptprevious': 20739,
                                  \ 'ptrewind': 20739,
                                  \ 'ptselect': 278,
                                  \ 'put': 3150659,
                                  \ 'pwd': 1048832,
                                  \ 'python': 1048709,
                                  \ 'pydo': 1048741,
                                  \ 'pyfile': 1048733,
                                  \ 'py3': 1048709,
                                  \ 'py3do': 1048741,
                                  \ 'python3': 1048709,
                                  \ 'py3file': 1048733,
                                  \ 'quit': 1066243,
                                  \ 'quitall': 258,
                                  \ 'qall': 1048834,
                                  \ 'read': 3412319,
                                  \ 'recover': 286,
                                  \ 'redo': 1048832,
                                  \ 'redir': 1048846,
                                  \ 'redraw': 1048834,
                                  \ 'redrawstatus': 1048834,
                                  \ 'registers': 1050884,
                                  \ 'resize': 1065237,
                                  \ 'retab': 3146103,
                                  \ 'return': 1574916,
                                  \ 'rewind': 295174,
                                  \ 'right': 3146053,
                                  \ 'rightbelow': 2180,
                                  \ 'rshada': 1048862,
                                  \ 'runtime': 1573262,
                                  \ 'rundo': 156,
                                  \ 'ruby': 1048709,
                                  \ 'rubydo': 1048741,
                                  \ 'rubyfile': 1048733,
                                  \ 'rviminfo': 1048862,
                                  \ 'substitute': 1048645,
                                  \ 'sNext': 312583,
                                  \ 'sargument': 312583,
                                  \ 'sall': 17667,
                                  \ 'sandbox': 2180,
                                  \ 'saveas': 1311038,
                                  \ 'sbuffer': 247047,
                                  \ 'sbNext': 50433,
                                  \ 'sball': 50433,
                                  \ 'sbfirst': 33024,
                                  \ 'sblast': 33024,
                                  \ 'sbmodified': 50433,
                                  \ 'sbnext': 50433,
                                  \ 'sbprevious': 50433,
                                  \ 'sbrewind': 33024,
                                  \ 'scriptnames': 1048832,
                                  \ 'scriptencoding': 1048852,
                                  \ 'scscope': 2052,
                                  \ 'set': 1573124,
                                  \ 'setfiletype': 1048964,
                                  \ 'setglobal': 1573124,
                                  \ 'setlocal': 1573124,
                                  \ 'sfind': 311583,
                                  \ 'sfirst': 295174,
                                  \ 'simalt': 1048980,
                                  \ 'sign': 1065093,
                                  \ 'silent': 1575046,
                                  \ 'sleep': 1066245,
                                  \ 'slast': 295174,
                                  \ 'smagic': 1048645,
                                  \ 'smap': 1059076,
                                  \ 'smapclear': 1048836,
                                  \ 'smenu': 1079557,
                                  \ 'snext': 311567,
                                  \ 'snomagic': 1048645,
                                  \ 'snoremap': 1059076,
                                  \ 'snoremenu': 1079557,
                                  \ 'source': 1573150,
                                  \ 'sort': 2099303,
                                  \ 'split': 311583,
                                  \ 'spellgood': 16775,
                                  \ 'spelldump': 258,
                                  \ 'spellinfo': 256,
                                  \ 'spellrepall': 256,
                                  \ 'spellundo': 16775,
                                  \ 'spellwrong': 16775,
                                  \ 'sprevious': 312583,
                                  \ 'srewind': 295174,
                                  \ 'stop': 1048834,
                                  \ 'stag': 20759,
                                  \ 'startinsert': 1048834,
                                  \ 'startgreplace': 1048834,
                                  \ 'startreplace': 1048834,
                                  \ 'stopinsert': 1048834,
                                  \ 'stjump': 278,
                                  \ 'stselect': 278,
                                  \ 'sunhide': 17665,
                                  \ 'sunmap': 1059076,
                                  \ 'sunmenu': 1059076,
                                  \ 'suspend': 1048834,
                                  \ 'sview': 311583,
                                  \ 'swapname': 1048832,
                                  \ 'syntax': 1050628,
                                  \ 'syntime': 1048980,
                                  \ 'syncbind': 256,
                                  \ 't': 3146053,
                                  \ 'tcd': 1048862,
                                  \ 'tchdir': 1048862,
                                  \ 'tNext': 20739,
                                  \ 'tag': 20759,
                                  \ 'tags': 1048832,
                                  \ 'tab': 2180,
                                  \ 'tabclose': 1069335,
                                  \ 'tabdo': 18597,
                                  \ 'tabedit': 315679,
                                  \ 'tabfind': 315807,
                                  \ 'tabfirst': 256,
                                  \ 'tabmove': 20757,
                                  \ 'tablast': 256,
                                  \ 'tabnext': 20757,
                                  \ 'tabnew': 315679,
                                  \ 'tabonly': 1069335,
                                  \ 'tabprevious': 20757,
                                  \ 'tabNext': 20757,
                                  \ 'tabrewind': 256,
                                  \ 'tabs': 1048832,
                                  \ 'tcl': 1048709,
                                  \ 'tcldo': 1048741,
                                  \ 'tclfile': 1048733,
                                  \ 'terminal': 1048590,
                                  \ 'tfirst': 20739,
                                  \ 'throw': 1572996,
                                  \ 'tjump': 278,
                                  \ 'tlast': 258,
                                  \ 'tmap': 1059076,
                                  \ 'tmapclear': 1048836,
                                  \ 'tmenu': 1079557,
                                  \ 'tnext': 20739,
                                  \ 'tnoremap': 1059076,
                                  \ 'topleft': 2180,
                                  \ 'tprevious': 20739,
                                  \ 'trewind': 20739,
                                  \ 'try': 1573120,
                                  \ 'tselect': 278,
                                  \ 'tunmap': 1059076,
                                  \ 'tunmenu': 1059076,
                                  \ 'undo': 1070337,
                                  \ 'undojoin': 1048832,
                                  \ 'undolist': 1048832,
                                  \ 'unabbreviate': 1059076,
                                  \ 'unhide': 17665,
                                  \ 'unlet': 1572998,
                                  \ 'unlockvar': 1572998,
                                  \ 'unmap': 1059078,
                                  \ 'unmenu': 1059078,
                                  \ 'unsilent': 1575044,
                                  \ 'update': 262527,
                                  \ 'vglobal': 1048677,
                                  \ 'version': 1048836,
                                  \ 'verbose': 1591429,
                                  \ 'vertical': 2180,
                                  \ 'visual': 295198,
                                  \ 'view': 295198,
                                  \ 'vimgrep': 18831,
                                  \ 'vimgrepadd': 18831,
                                  \ 'viusage': 256,
                                  \ 'vmap': 1059076,
                                  \ 'vmapclear': 1048836,
                                  \ 'vmenu': 1079557,
                                  \ 'vnoremap': 1059076,
                                  \ 'vnew': 311583,
                                  \ 'vnoremenu': 1079557,
                                  \ 'vsplit': 311583,
                                  \ 'vunmap': 1059076,
                                  \ 'vunmenu': 1059076,
                                  \ 'write': 1311103,
                                  \ 'wNext': 278879,
                                  \ 'wall': 1048834,
                                  \ 'while': 1574916,
                                  \ 'winsize': 388,
                                  \ 'wincmd': 1065109,
                                  \ 'windo': 18597,
                                  \ 'winpos': 1048836,
                                  \ 'wnext': 278815,
                                  \ 'wprevious': 278815,
                                  \ 'wq': 262527,
                                  \ 'wqall': 262462,
                                  \ 'wsverb': 16516,
                                  \ 'wshada': 1048862,
                                  \ 'wundo': 158,
                                  \ 'wviminfo': 1048862,
                                  \ 'xit': 1311103,
                                  \ 'xall': 258,
                                  \ 'xmap': 1059076,
                                  \ 'xmapclear': 1048836,
                                  \ 'xmenu': 1079557,
                                  \ 'xnoremap': 1059076,
                                  \ 'xnoremenu': 1079557,
                                  \ 'xunmap': 1059076,
                                  \ 'xunmenu': 1059076,
                                  \ 'yank': 1050433,
                                  \ 'z': 5243205,
                                  \ '!': 1048655,
                                  \ '#': 5244225,
                                  \ '&': 3145797,
                                  \ '<': 7341377,
                                  \ ':': 5243169,
                                  \ '>': 7341377,
                                  \ '@': 1048901,
                                  \ 'Next': 312583,
                                  \ '~': 3145797,
                                  \ }

SCRIPT  /Users/kaizhi/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/cmdline/skip_range.vim
Sourced 1 time
Total time:   0.000942
 Self time:   0.000942

count  total (s)   self (s)
    1              0.000004 let s:chars = " \t0123456789.$%'/?-+,;\\"
                            
    1              0.000002 function! wilder#cmdline#skip_range#do(ctx) abort
                              while a:ctx.pos < len(a:ctx.cmdline) &&
                                    \ stridx(s:chars, a:ctx.cmdline[a:ctx.pos]) != -1
                                let l:char = a:ctx.cmdline[a:ctx.pos]
                                if l:char ==# '\'
                                  if a:ctx.pos + 1 >= len(a:ctx.cmdline)
                                    return 1
                                  endif
                            
                                  let l:second_char = a:ctx.cmdline[a:ctx.pos + 1]
                            
                                  if l:second_char ==# '?' ||
                                        \ l:second_char ==# '/' ||
                                        \ l:second_char ==# '&'
                                    let a:ctx.pos += 2
                                  else
                                    return 1
                                  endif
                                elseif l:char ==# "'"
                                  let a:ctx.pos += 1
                                elseif l:char ==# '/' || l:char ==# '?'
                                  let l:delim = l:char
                                  let a:ctx.pos += 1
                            
                                  while a:ctx.pos < len(a:ctx.cmdline) && a:ctx.cmdline[a:ctx.pos] !=# l:delim
                                    if a:ctx.cmdline[a:ctx.pos] ==# '\' &&
                                          \ a:ctx.pos + 1 < len (a:ctx.cmdline)
                                      let a:ctx.pos += 1
                                    endif
                            
                                    let a:ctx.pos += 1
                                  endwhile
                            
                                  if a:ctx.pos == len(a:ctx.cmdline)
                                    return
                                  endif
                                endif
                            
                                let a:ctx.pos += 1
                              endwhile
                            endfunc

FUNCTION  <SNR>58_clear_all_highlights()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer/nvim_api.vim:255
Called 3 times
Total time:   0.000044
 Self time:   0.000044

count  total (s)   self (s)
    3              0.000005   if !bufexists(self.state.buf)
                                return
    3              0.000001   endif
                            
    3              0.000035   call nvim_buf_clear_namespace(self.state.buf, self.state.ns_id, 0, -1)

FUNCTION  <lambda>380()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/pipe/branch.vim:5
Called 1 time
Total time:   0.000180
 Self time:   0.000004

count  total (s)   self (s)
                            return s:branch(a:args, ctx, x)

FUNCTION  <lambda>382()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/pipeline.vim:105
Called 1 time
Total time:   0.000563
 Self time:   0.000005

count  total (s)   self (s)
                            return s:run(a:pipeline, a:on_finish, a:on_error, ctx, x, a:i)

FUNCTION  <SNR>109_start()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/main.vim:94
Called 4 times
Total time:   0.004067
 Self time:   0.000171

count  total (s)   self (s)
    4   0.000046   0.000023   if !wilder#main#in_mode() || !s:enabled
    3   0.000021   0.000010     call wilder#main#stop()
    3              0.000001     return
    1              0.000001   endif
                            
    1   0.000023   0.000005   if !s:init && wilder#options#get('use_python_remote_plugin')
    1              0.000002     let s:init = 1
                            
    1              0.000001     try
    1              0.000002       if !has('nvim')
                                    " set up yarp
                                    call wilder#yarp#init()
    1              0.000000       endif
                            
    1              0.000014       call _wilder_init({'num_workers': s:opts.num_workers})
    1              0.000010     catch
    1              0.000002       echohl ErrorMsg
    1              0.000012       echomsg 'wilder: Python initialization failed'
    1              0.000007       echomsg v:exception
    1              0.000001       echohl Normal
    1              0.000001     endtry
    1              0.000000   endif
                            
    1              0.000001   if s:opts.use_cmdlinechanged
    1              0.000003     if !exists('#WilderCmdlineChanged')
    1              0.000002       augroup WilderCmdlineChanged
    1              0.000011         autocmd!
                                    " call from a timer so statusline does not change during mappings
    1              0.000003         autocmd CmdlineChanged * call timer_start(0, {_ -> s:do(1)})
    1              0.000000       augroup END
    1              0.000000     endif
                              elseif s:timer is v:null
                                  let s:timer = timer_start(s:opts.interval, {_ -> s:do(1)}, {'repeat': -1})
    1              0.000000   endif
                            
    1              0.000001   if !exists('#WilderCmdlineLeave')
    1              0.000001     augroup WilderCmdlineLeave
    1              0.000003       autocmd!
    1              0.000002       autocmd CmdlineLeave * call wilder#main#stop()
    1              0.000002       autocmd CmdwinEnter * call wilder#main#stop()
    1              0.000000     augroup END
    1              0.000000   endif
                            
    1              0.000002   if !exists('#WilderVimResized')
    1              0.000001     augroup WilderVimResized
    1              0.000003       autocmd!
    1              0.000002         autocmd VimResized * call timer_start(0, {_ -> s:draw_resized()})
    1              0.000000     augroup END
    1              0.000000   endif
                            
    1              0.000001   let s:active = 1
    1              0.000001   let s:hidden = 0
                            
    1              0.000001   if !has_key(s:opts, 'renderer')
                                let s:opts.renderer = wilder#wildmenu_renderer()
    1              0.000000   endif
                            
    1              0.000001   if !has_key(s:opts, 'pipeline')
                                let s:opts.pipeline = [ wilder#branch(   wilder#cmdline_pipeline(),   has('nvim') && has('python3')     ? wilder#python_search_pipeline()     : wilder#vim_search_pipeline(), ), ]
    1              0.000000   endif
                            
    1              0.000002   let s:session_id += 1
                            
    1   0.003122   0.000005   call s:pre_hook()
                            
    1   0.000733   0.000004   call s:do(0)

FUNCTION  <SNR>58__open_win()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer/nvim_api.vim:82
Called 1 time
Total time:   0.031266
 Self time:   0.000133

count  total (s)   self (s)
                              " window might have been open or closed already.
    1              0.000001   if self.state.window_state !=# 'pending'
                                return
    1              0.000000   endif
                            
                              " Fix E5555 when re-showing wilder when inccommand is cancelled.
    1              0.000005   let l:buf = has('nvim-0.6') && !has('nvim-0.7') ? 0 : self.state.buf
                            
    1              0.000004   let l:win_opts = { 'relative': 'editor', 'height': 1, 'width': 1, 'row': &lines - 1, 'col': 0, 'focusable': 0, }
                            
    1              0.000001   if has('nvim-0.5.1')
    1              0.000001     let l:win_opts.zindex = self.state.zindex
    1              0.000000   endif
                            
    1   0.031141   0.000060   let self.state.win = nvim_open_win(l:buf, 0, l:win_opts)
                            
    1              0.000002   let self.state.window_state = 'showing'
                            
    1              0.000004   if has('nvim-0.6') && !has('nvim-0.7')
                                try
                                  call self._set_buf()
                                catch
                                  call timer_start(0, {-> self._set_buf()})
                                endtry
    1              0.000000   else
    1              0.000011     call nvim_win_set_config(self.state.win, { 'style': 'minimal', })
    1              0.000000   endif
                            
    1   0.000042   0.000006   call self.set_option('winhighlight', 'Search:None,IncSearch:None,Normal:' . self.state.normal_highlight)
    1              0.000002   if self.state.pumblend != -1
                                call self.set_option('winblend', self.state.pumblend)
    1              0.000000   else
    1   0.000020   0.000004     call self.set_option('winblend', &pumblend)
    1              0.000000   endif
                            
    1              0.000001   if self.state.firstline isnot -1
                                call nvim_win_set_cursor(self.state.win, [self.state.firstline, 0])
    1              0.000000   endif
                            
    1              0.000001   if self.state.dimensions isnot -1
                                let [l:row, l:col, l:height, l:width] = self.state.dimensions
                                call nvim_win_set_config(self.state.win, { 'relative': 'editor', 'row': l:row, 'col': l:col, 'height': l:height, 'width': l:width, })
    1              0.000000   endif
                            
    1              0.000002   for l:option in keys(self.state.options)
                                let l:value = self.state.options[l:option]
                                call nvim_win_set_option(self.state.win, l:option, l:value)
    1              0.000001   endfor
                            
    1              0.000001   let self.state.firstline = -1
    1              0.000001   let self.state.dimensions = -1
    1              0.000002   let self.state.options = {}

FUNCTION  <lambda>529()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/pipeline.vim:171
Called 1 time
Total time:   0.000037
 Self time:   0.000004

count  total (s)   self (s)
                            return s:wait_start(l:state, ctx)

FUNCTION  <lambda>388()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/pipe/branch.vim:38
Called 1 time
Total time:   0.000032
 Self time:   0.000018

count  total (s)   self (s)
                            return s:on_finish(a:state, ctx, x)

FUNCTION  <lambda>188()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer/popupmenu_palette_theme.vim:415
Called 14 times
Total time:   0.000790
 Self time:   0.000104

count  total (s)   self (s)
                            return s:prompt_update_cursor(a:state)

FUNCTION  <lambda>80()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer/popupmenu.vim:113
Called 5 times
Total time:   0.001586
 Self time:   0.000023

count  total (s)   self (s)
                            return s:render(l:state, ctx, result)

FUNCTION  <lambda>81()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer/popupmenu.vim:113
Called 1 time
Total time:   0.001753
 Self time:   0.000005

count  total (s)   self (s)
                            return s:pre_hook(l:state, ctx)

FUNCTION  <lambda>390()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/pipe/branch.vim:5
Called 1 time
Total time:   0.000588
 Self time:   0.000028

count  total (s)   self (s)
                            return s:branch(a:args, ctx, x)

FUNCTION  <lambda>391()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/pipeline.vim:105
Called 1 time
Total time:   0.000102
 Self time:   0.000005

count  total (s)   self (s)
                            return s:run(a:pipeline, a:on_finish, a:on_error, ctx, x, a:i)

FUNCTION  <lambda>191()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/pipeline.vim:105
Called 1 time
Total time:   0.000708
 Self time:   0.000005

count  total (s)   self (s)
                            return s:run(a:pipeline, a:on_finish, a:on_error, ctx, x, a:i)

FUNCTION  <lambda>91()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/cmdline.vim:1325
Called 2 times
Total time:   0.000002
 Self time:   0.000002

count  total (s)   self (s)
                            return res[0] ? res : v:false

FUNCTION  <lambda>94()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/cmdline.vim:1344
Called 2 times
Total time:   0.000001
 Self time:   0.000001

count  total (s)   self (s)
                            return res[2]

FUNCTION  <lambda>95()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/transform.vim:95
Called 2 times
Total time:   0.000039
 Self time:   0.000011

count  total (s)   self (s)
                            return wilder#vim_fuzzy_filt(ctx, {}, xs, q)

FUNCTION  <lambda>96()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/cmdline.vim:1127
Called 2 times
Total time:   0.000016
 Self time:   0.000010

count  total (s)   self (s)
                            return wilder#cmdline#is_file_expansion(res.expand)

FUNCTION  <SNR>55_render_lines()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer/popupmenu.vim:285
Called 3 times
Total time:   0.068258
 Self time:   0.007535

count  total (s)   self (s)
    3              0.000004   if !has_key(a:ctx, 'error')
                                " +1 to account for the cmdline prompt.
    3              0.000005     let l:pos = get(a:result, 'pos', 0) + 1
    3              0.000004     let l:pos -= a:state.left_offset
    3              0.000002     if l:pos < 0
                                  let l:pos = 0
    3              0.000001     endif
                              else
                                let l:cmdline = getcmdline()
                                let l:parsed = wilder#cmdline#parse(l:cmdline)
                                let l:pos = l:parsed.pos
    3              0.000001   endif
                            
    3              0.000003   let l:selected = a:ctx.selected
    3              0.000003   let l:reverse = a:state.reverse
                            
    3              0.000005   let [l:page_start, l:page_end] = a:state.page
                            
    3              0.000003   if a:state.page != [-1, -1]
                                " draw candidates
    3   0.015741   0.000055     let [l:lines, l:width] = s:make_lines(a:state, a:ctx, a:result)
    3              0.000005     let l:lines = l:reverse ? reverse(l:lines) : l:lines
                              else
                                if has_key(a:ctx, 'error')
                                  " draw error
                                  let l:lines = s:make_message(a:state, a:ctx, a:state.error_message, s:empty_result, a:ctx.error, 'error')
                                else
                                  " draw empty message
                                  let l:lines = s:make_message(a:state, a:ctx, a:state.empty_message, a:result, a:result, 'empty_message')
                                endif
                            
                                let l:width = empty(l:lines) ? a:state.get_min_width(a:ctx, a:result) : wilder#render#chunks_displaywidth(l:lines[0])
    3              0.000001   endif
                            
    3              0.000020   let l:ctx = extend({'width': l:width}, a:ctx)
                            
                              " height excluding top and bottom
    3              0.000004   let l:lines_height = len(l:lines)
                            
    3              0.000003   let l:top_lines = []
    3              0.000003   let l:top_height = 0
   12              0.000012   for l:Top in a:state.top
    9   0.003772   0.000058     let l:line = s:draw_top_or_bottom_line(l:Top, l:ctx, a:result)
                            
    9              0.000009     if empty(l:line)
                                  continue
    9              0.000003     endif
                            
    9              0.000015     call add(l:top_lines, l:line)
    9              0.000010     let l:top_height += 1
   12              0.000005   endfor
    3              0.000007   let l:lines = l:top_lines + l:lines
                            
    3              0.000003   let l:bottom_height = 0
    6              0.000010   for l:Bottom in a:state.bottom
    3   0.000891   0.000017     let l:line = s:draw_top_or_bottom_line(l:Bottom, l:ctx, a:result)
                            
    3              0.000003     if empty(l:line)
                                  continue
    3              0.000001     endif
                            
    3              0.000004     call add(l:lines, l:line)
    3              0.000003     let l:bottom_height += 1
    6              0.000003   endfor
                            
    3              0.000002   if empty(l:lines)
                                call a:state.api.hide()
                                return
    3              0.000001   endif
                            
    3   0.031298   0.000012   call a:state.api.show()
                            
    3              0.000004   let l:height = len(l:lines)
    3   0.000047   0.000012   let l:max_height = a:state.get_max_height(a:ctx, a:result)
    3              0.000002   if l:max_height > &lines
                                let l:max_height = &lines
    3              0.000001   endif
    3   0.000231   0.000083   let [l:row, l:col] = a:state.position(a:ctx, l:pos, {'height': l:height, 'width': l:width, 'max_height': l:max_height})
                            
    3   0.000053   0.000012   call a:state.api.move(l:row, l:col, l:height, l:width)
    3   0.000059   0.000011   call a:state.api.set_option('wrap', v:false)
    3   0.000057   0.000013   call a:state.api.clear_all_highlights()
    3   0.000129   0.000039   call a:state.api.delete_all_lines()
                            
    3              0.000007   let l:default_hl = a:state.highlights['default']
    3              0.000004   let l:selected_hl = a:state.highlights['selected']
                            
    3              0.000002   let l:i = 0
   68              0.000059   while l:i < len(l:lines)
   65              0.000059     let l:chunks = l:lines[l:i]
                            
   65              0.000038     let l:text = ''
  481              0.000197     for l:chunk in l:chunks
  416              0.000399       let l:text .= l:chunk[0]
  481              0.000117     endfor
                            
   65   0.000966   0.000203     call a:state.api.set_line(l:i, l:text)
                            
                                " Don't apply selected for top lines or error or empty message.
   65              0.000141     if l:page_start == -1 || (!l:reverse && l:i < l:top_height) || (l:reverse && l:i >= l:top_height + l:lines_height)
    9              0.000008       let l:is_selected = 0
   56              0.000014     else
   56              0.000150       let l:is_selected = l:reverse ?  l:page_start + (l:height - l:i - l:bottom_height - 1) == l:selected : l:page_start + l:i - l:top_height == l:selected
   65              0.000016     endif
                            
   65              0.000035     let l:start = 0
  481              0.000206     for l:chunk in l:chunks
  416              0.000501       let l:end = l:start + len(l:chunk[0])
                            
  416              0.000188       if l:is_selected
                                    if len(l:chunk) == 1
                                      let l:hl = l:selected_hl
                                    elseif len(l:chunk) == 2
                                      let l:hl = l:chunk[1]
                                    else
                                      let l:hl = l:chunk[2]
                                    endif
  416              0.000092       else
  416              0.000500         let l:hl = get(l:chunk, 1, l:default_hl)
  416              0.000098       endif
                            
  416              0.000295       if l:hl !=# l:default_hl
   53   0.000384   0.000209         call a:state.api.add_highlight(l:hl, l:i, l:start, l:end)
  416              0.000099       endif
                            
  416              0.000244       let l:start = l:end
  481              0.000221     endfor
                            
   65              0.000039     let l:i += 1
   68              0.000023   endwhile
                            
    3   0.000039   0.000011   call a:state.api.set_firstline(1)
    3   0.007805   0.000015   call wilder#renderer#redraw(a:state.apply_incsearch_fix)

FUNCTION  wilder#transform#uniq_filt()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/transform.vim:57
Called 1 time
Total time:   0.000022
 Self time:   0.000022

count  total (s)   self (s)
    1              0.000001   let l:seen = {}
    1              0.000001   let l:res = []
                            
    4              0.000003   for l:x in a:xs
    3              0.000003     if !has_key(l:seen, l:x)
    3              0.000003       let l:seen[l:x] = 1
    3              0.000004       call add(l:res, l:x)
    3              0.000001     endif
    4              0.000002   endfor
                            
    1              0.000001   return l:res

FUNCTION  <SNR>110_pre_draw()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer.vim:62
Called 40 times
Total time:   0.000696
 Self time:   0.000616

count  total (s)   self (s)
   40              0.000043   if type(a:component) isnot v:t_dict
   36              0.000020     return a:ctx.done
    4              0.000001   endif
                            
    4              0.000005   if has_key(a:component, 'pre_draw')
    4   0.000612   0.000532     return a:component.pre_draw(a:ctx, a:result)
                              endif
                            
                              return a:ctx.done || get(a:component, 'dynamic', 0)

FUNCTION  <SNR>51_prompt()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer/popupmenu_palette_theme.vim:165
Called 3 times
Total time:   0.000533
 Self time:   0.000487

count  total (s)   self (s)
    3              0.000005   let l:cmdline = getcmdline()
    3              0.000004   let a:state.cmdpos = getcmdpos()
    3   0.000063   0.000017   let l:cmdline_data = s:get_cmdline_data(a:state, l:cmdline)
    3              0.000003   let l:hl = a:state.hl
                            
                              " cmdpos includes the prompt character
    3              0.000004   let l:cursor_pos = a:state.cmdpos - 1
                              " -1 as the prompt char is always drawn
    3              0.000003   let l:max_displaywidth = a:ctx.width - 1
    3              0.000002   let l:displaywidth = 0
    3              0.000004   let l:previous_start = len(l:cmdline)
    3              0.000002   let l:previous_end = 0
                            
                              " cursor is at end of cmdline
    3              0.000004   if l:cursor_pos >= len(l:cmdline)
                                " -1 for the cursor
    3              0.000003     let l:max_displaywidth -= 1
    3              0.000002     let l:displaywidth = 0
    3              0.000002     let l:prompt_str = ''
                            
                                " draw entire cmdline starting from the back
    3              0.000004     let l:i = len(l:cmdline_data) - 1
    5              0.000004     while l:i >= 0
                                  " [char, byte_len, strdisplaywidth, byte_pos, displaywidth_pos]
    2              0.000002       let l:data = l:cmdline_data[l:i]
                            
    2              0.000003       if l:displaywidth + l:data[2] > l:max_displaywidth
                                    break
    2              0.000001       endif
                            
    2              0.000002       let l:displaywidth += l:data[2]
    2              0.000003       let l:prompt_str = l:data[0] . l:prompt_str
    2              0.000003       let l:previous_start = l:data[3]
                            
    2              0.000001       let l:i -= 1
    5              0.000003     endwhile
                            
    3              0.000018     let l:previous_end = len(l:cmdline)
    3              0.000008     let l:chunks = [[l:prompt_str, l:hl], [' ', a:state.cursor_hl]]
                              else
                                let l:chunks = v:null
                            
                                " check if the cursor fits within previous_start and previous_end
                                " if it does, draw the prompt with the same bounds
                                if strdisplaywidth(l:cmdline) <= l:max_displaywidth || (l:cursor_pos >= a:state.previous_start && l:cursor_pos < a:state.previous_end)
                                  let l:start_seen = 0
                                  let l:cursor_char = ''
                                  let l:before_cursor_str = ''
                                  let l:after_cursor_str = ''
                            
                                  let l:i = 0
                                  while l:i < len(l:cmdline_data)
                                    " [char, byte_len, strdisplaywidth, byte_pos, displaywidth_pos]
                                    let l:data = l:cmdline_data[l:i]
                            
                                    if l:data[3] < a:state.previous_start
                                      let l:i += 1
                                      continue
                                    endif
                            
                                    if !l:start_seen
                                      let l:start_seen = 1
                                      let l:previous_start = l:data[3]
                                    endif
                            
                                    if l:data[3] > a:state.previous_end
                                      break
                                    endif
                            
                                    if l:displaywidth + l:data[2] > l:max_displaywidth
                                      break
                                    endif
                            
                                    let l:displaywidth += l:data[2]
                            
                                    if l:data[3] == l:cursor_pos
                                      let l:cursor_char = l:data[0]
                                    elseif l:data[3] < l:cursor_pos
                                      let l:before_cursor_str .= l:data[0]
                                    else
                                      let l:after_cursor_str .= l:data[0]
                                    endif
                            
                                    let l:previous_end = l:data[1] + l:data[3]
                            
                                    let l:i += 1
                                  endwhile
                            
                                  " max_displaywidth reached but cursor is not inside bounds
                                  if l:cursor_char !=# ''
                                    let l:chunks = [[l:before_cursor_str, l:hl], [l:cursor_char, a:state.cursor_hl], [l:after_cursor_str, l:hl]]
                                  endif
                                endif
                            
                                " cursor is not within old bounds, draw new bounds with cursor starting
                                " at the front or end depending on which direction it moved
                                if l:chunks is v:null
                                  let l:displaywidth = 0
                            
                                  if l:cursor_pos < a:state.previous_cursor_pos
                                    " cursor at start
                                    let l:cursor_char = ''
                                    let l:prompt_str = ''
                            
                                    let l:i = 0
                                    while l:i < len(l:cmdline_data)
                                      " [char, byte_len, strdisplaywidth, byte_pos, displaywidth_pos]
                                      let l:data = l:cmdline_data[l:i]
                            
                                      if l:data[3] < l:cursor_pos
                                        let l:i += 1
                                        continue
                                      endif
                            
                                      if l:displaywidth + l:data[2] > l:max_displaywidth
                                        break
                                      endif
                            
                                      let l:displaywidth += l:data[2]
                            
                                      if l:data[3] == l:cursor_pos
                                        let l:previous_start = l:data[3]
                                        let l:cursor_char = l:data[0]
                                      else
                                        let l:prompt_str .= l:data[0]
                                      endif
                            
                                      let l:previous_end = l:data[3] + l:data[1]
                            
                                      let l:i += 1
                                    endwhile
                            
                                    let l:chunks = [[l:cursor_char, a:state.cursor_hl], [l:prompt_str, l:hl]]
                                  else
                                    " cursor at end
                                    let l:cursor_char = ''
                                    let l:prompt_str = ''
                            
                                    let l:i = len(l:cmdline_data) - 1
                                    while l:i >= 0
                                      " [char, byte_len, strdisplaywidth, byte_pos, displaywidth_pos]
                                      let l:data = l:cmdline_data[l:i]
                            
                                      if l:data[3] > l:cursor_pos
                                        let l:i -= 1
                                        continue
                                      endif
                            
                                      if l:displaywidth + l:data[2] > l:max_displaywidth
                                        break
                                      endif
                            
                                      let l:displaywidth += l:data[2]
                            
                                      if l:data[3] == l:cursor_pos
                                        let l:previous_end = l:data[3]
                                        let l:cursor_char = l:data[0]
                                      else
                                        let l:prompt_str = l:data[0] . l:prompt_str
                                      endif
                            
                                      let l:previous_start = l:data[3] + l:data[1]
                            
                                      let l:i -= 1
                                    endwhile
                            
                                    let l:chunks = [[l:prompt_str, l:hl], [l:cursor_char, a:state.cursor_hl]]
                                  endif
                                endif
    3              0.000001   endif
                            
                              " if there is space leftover, add characters depending on the direction
                              " which the cursor moved
    3              0.000003   if l:displaywidth < l:max_displaywidth
    3              0.000002     let l:str = ''
                            
                                " cursor moved left, add characters to the end
    3              0.000003     if l:cursor_pos < a:state.previous_cursor_pos
                                  let l:i = 0
                                  while l:i < len(l:cmdline_data)
                                    " [char, byte_len, strdisplaywidth, byte_pos, displaywidth_pos]
                                    let l:data = l:cmdline_data[l:i]
                            
                                    if l:data[3] < l:previous_end
                                      let l:i += 1
                                      continue
                                    endif
                            
                                    if l:displaywidth + l:data[2] > l:max_displaywidth
                                      break
                                    endif
                            
                                    let l:displaywidth += l:data[2]
                                    let l:str .= l:data[0]
                                    let l:previous_end = l:data[1] + l:data[3]
                            
                                    let l:i += 1
                                  endwhile
                            
                                  call add(l:chunks, [l:str, l:hl])
    3              0.000001     else
                                  " cursor moved right, add characters to the start
    3              0.000004       let l:i = len(l:cmdline_data) - 1
    5              0.000003       while l:i >= 0
                                    " [char, byte_len, strdisplaywidth, byte_pos, displaywidth_pos]
    2              0.000002         let l:data = l:cmdline_data[l:i]
                            
    2              0.000002         if l:data[3] >= l:previous_start
    2              0.000001           let l:i -= 1
    2              0.000001           continue
                                    endif
                            
                                    if l:displaywidth + l:data[2] > l:max_displaywidth
                                      break
                                    endif
                            
                                    let l:displaywidth += l:data[2]
                                    let l:str = l:data[0] . l:str
                                    let l:previous_start = l:data[3]
                            
                                    let l:i -= 1
    3              0.000002       endwhile
                            
    3              0.000007       call insert(l:chunks, [l:str, l:hl], 0)
    3              0.000001     endif
    3              0.000001   endif
                            
                              " add padding for the rest of the leftover space
    3              0.000003   if l:displaywidth < l:max_displaywidth
    3              0.000009     call add(l:chunks, [repeat(' ', l:max_displaywidth - l:displaywidth), l:hl])
    3              0.000001   endif
                            
    3              0.000006   call insert(l:chunks, [getcmdtype(), l:hl], 0)
                            
    3              0.000004   let a:state.previous_start = l:previous_start
    3              0.000003   let a:state.previous_end = l:previous_end
    3              0.000003   let a:state.previous_cursor_pos = l:cursor_pos
                            
    3              0.000002   return l:chunks

FUNCTION  <SNR>44_wrap_function()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/lua.vim:32
Called 4 times
Total time:   0.000031
 Self time:   0.000031

count  total (s)   self (s)
    4              0.000004   let l:index = s:index
    4              0.000003   let s:index += 1
                            
    4              0.000007   let s:functions[l:index] = a:f
    4              0.000013   return { 'index': l:index, 'name': get(a:f, 'name'), '__wilder_wrapped__': s:token, }

FUNCTION  wilder#cmdline#parse()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/cmdline.vim:3
Called 2 times
Total time:   0.002825
 Self time:   0.000185

count  total (s)   self (s)
    2   0.000015   0.000010   if !s:cmdline_cache.has_key(a:cmdline)
    2              0.000005     let l:ctx = {'cmdline': a:cmdline, 'pos': 0, 'cmd': '', 'expand': ''}
    2   0.002711   0.000140     call wilder#cmdline#main#do(l:ctx)
                            
    2              0.000004     let l:ctx['arg'] = l:ctx['cmdline'][l:ctx.pos :]
    2              0.000002     let l:ctx['pos'] = l:ctx.pos
    2   0.000071   0.000010     call s:cmdline_cache.set(a:cmdline, l:ctx)
    2              0.000001   endif
                            
    2   0.000013   0.000010   return copy(s:cmdline_cache.get(a:cmdline))

FUNCTION  wilder#highlight#init_hl()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/highlight.vim:16
Called 1 time
Total time:   0.001329
 Self time:   0.000021

count  total (s)   self (s)
    3              0.000005   for [l:name, l:x, l:xs] in s:hl_list
    2   0.001321   0.000013     call s:make_hl(l:name, l:x, l:xs)
    3              0.000001   endfor

FUNCTION  <SNR>58_new()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer/nvim_api.vim:43
Called 1 time
Total time:   0.000581
 Self time:   0.000022

count  total (s)   self (s)
                              " If the buffer is somehow unloaded, bufload(self.state.buf) doesn't restore
                              " it so we have to create a new one
    1              0.000003   if !bufexists(self.state.buf) || !bufloaded(self.state.buf)
    1   0.000327   0.000004     let self.state.buf = s:new_buf()
    1              0.000000   endif
                            
    1              0.000002   if !bufexists(self.state.dummy_buf) || !bufloaded(self.state.dummy_buf)
    1   0.000240   0.000004     let self.state.dummy_buf = s:new_buf()
    1              0.000000   endif
                            
    1              0.000003   let self.state.normal_highlight = get(a:opts, 'normal_highlight', 'Normal')
    1              0.000002   let self.state.pumblend = get(a:opts, 'pumblend', -1)
    1              0.000001   let self.state.zindex = get(a:opts, 'zindex', 0)

FUNCTION  <SNR>49_mru_get()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/cache.vim:41
Called 2 times
Total time:   0.000003
 Self time:   0.000003

count  total (s)   self (s)
    2              0.000003   return self['_cache'][a:key]

FUNCTION  wilder#resolve()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder.vim:37
Called 10 times
Total time:   0.000033
 Self time:   0.000033

count  total (s)   self (s)
   10              0.000031   call timer_start(0, {-> wilder#pipeline#resolve(a:ctx, a:x)})

FUNCTION  <lambda>17()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer/popupmenu_palette_theme.vim:118
Called 1 time
Total time:   0.000007
 Self time:   0.000005

count  total (s)   self (s)
                            return s:prompt_post_hook(a:state)

FUNCTION  <SNR>43_Event()
    Defined: ~/.local/share/nvim/lazy/copilot.vim/plugin/copilot.vim:45
Called 14 times
Total time:   0.000269
 Self time:   0.000104

count  total (s)   self (s)
   14              0.000008   try
   14   0.000224   0.000059     call call('copilot#On' . a:type, [])
                              catch
                                call copilot#logger#Exception('autocmd.' . a:type)
   14              0.000007   endtry

FUNCTION  <SNR>57_combine_hl_list()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/highlight.vim:71
Called 2 times
Total time:   0.000087
 Self time:   0.000087

count  total (s)   self (s)
    2              0.000003   let l:term_hl = copy(a:l[0])
    2              0.000002   let l:cterm_hl = copy(a:l[1])
    2              0.000002   let l:gui_hl = copy(a:l[2])
                            
    2              0.000002   if len(l:term_hl) <= 2
    2              0.000002     let l:term_hl = copy(a:m[0])
                              else
                                let l:term_hl += a:m[0][2:]
    2              0.000001   endif
                            
    2              0.000003   let l:cterm_fg = get(a:m[1], 0, -1)
    2              0.000003   if l:cterm_fg isnot 'NONE' && l:cterm_fg isnot -1
                                if empty(l:cterm_hl)
                                  let l:cterm_hl = [l:cterm_fg]
                                else
                                  let l:cterm_hl[0] = l:cterm_fg
                                endif
    2              0.000001   endif
                            
    2              0.000003   let l:cterm_bg = get(a:m[1], 1, -1)
    2              0.000002   if l:cterm_bg isnot 'NONE' && l:cterm_bg isnot -1
                                if empty(l:cterm_hl)
                                  let l:cterm_hl = ['NONE', l:cterm_bg]
                                else
                                  let l:cterm_hl[1] = l:cterm_bg
                                endif
    2              0.000000   endif
                            
    2              0.000002   if len(a:m[1]) > 2
    2              0.000002     if empty(l:cterm_hl)
                                  let l:cterm_hl = ['NONE', 'NONE'] + a:m[1][2:]
    2              0.000001     else
    2              0.000003       let l:cterm_hl += a:m[1][2:]
    2              0.000001     endif
    2              0.000000   endif
                            
    2              0.000003   let l:gui_fg = get(a:m[2], 0, -1)
    2              0.000002   if l:gui_fg isnot 'NONE' && l:gui_fg isnot -1
                                if empty(l:gui_hl)
                                  let l:gui_hl = [l:gui_fg]
                                else
                                  let l:gui_hl[0] = l:gui_fg
                                endif
    2              0.000000   endif
                            
    2              0.000002   let l:gui_bg = get(a:m[2], 1, -1)
    2              0.000002   if l:gui_bg isnot 'NONE' && l:gui_bg isnot -1
                                if empty(l:gui_hl)
                                  let l:gui_hl = ['NONE', l:gui_bg]
                                else
                                  let l:gui_hl[1] = l:gui_bg
                                endif
    2              0.000000   endif
                            
    2              0.000002   if len(a:m[2]) > 2
    2              0.000002     if empty(l:gui_hl)
                                  let l:gui_hl = ['NONE', 'NONE'] + a:m[2][2:]
    2              0.000001     else
    2              0.000003       let l:gui_hl += a:m[2][2:]
    2              0.000001     endif
    2              0.000001   endif
                            
    2              0.000002   return [l:term_hl, l:cterm_hl, l:gui_hl]

FUNCTION  <lambda>189()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/pipe/branch.vim:5
Called 1 time
Total time:   0.002081
 Self time:   0.000005

count  total (s)   self (s)
                            return s:branch(a:args, ctx, x)

FUNCTION  <SNR>109_post_hook()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/main.vim:236
Called 1 time
Total time:   0.000313
 Self time:   0.000022

count  total (s)   self (s)
    1   0.000010   0.000005   call wilder#pipeline#clear_handlers()
                            
    1              0.000003   if has_key(s:opts.renderer, 'post_hook')
    1   0.000296   0.000010     call s:opts.renderer.post_hook({})
    1              0.000000   endif
                            
    1              0.000001   if has_key(s:opts, 'post_hook')
                                call s:opts.post_hook({})
    1              0.000000   endif

FUNCTION  <SNR>48_devicons()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer/component/popupmenu_devicons.vim:24
Called 3 times
Total time:   0.000025
 Self time:   0.000025

count  total (s)   self (s)
    3              0.000005   if !has_key(a:result, 'data')
                                return ''
    3              0.000001   endif
                            
    3              0.000005   let l:expand = get(a:result.data, 'cmdline.expand', '')
                            
    3              0.000008   if l:expand !=# 'file' && l:expand !=# 'file_in_path' && l:expand !=# 'dir' && l:expand !=# 'shellcmd' && l:expand !=# 'buffer'
    3              0.000001     return ''
                              endif
                            
                              let l:session_id = a:ctx.session_id
                              if a:state.session_id != l:session_id
                                call a:state.cache.clear()
                                let a:state.created_hls = {}
                                let a:state.session_id = l:session_id
                              endif
                            
                              let l:slash = !has('win32') && !has('win64') ? '/' : &shellslash ? '/' : '\'
                            
                              let [l:start, l:end] = a:ctx.page
                            
                              let l:rows = repeat([0], l:end - l:start + 1)
                            
                              if !has_key(a:state, 'get_icon')
                                let a:state.get_icon = s:get_icon_func()
                              endif
                            
                              if a:state.get_icon is v:null
                                return []
                              endif
                            
                              if !has_key(a:state, 'get_hl')
                                let a:state.get_hl = s:get_hl_func()
                              endif
                            
                              let l:i = l:start
                              while l:i <= l:end
                                let l:index = l:i - l:start
                            
                                let l:x = wilder#main#get_candidate(a:ctx, a:result, l:i)
                            
                                if a:state.cache.has_key(l:x)
                                  let l:rows[l:index] = a:state.cache.get(l:x)
                            
                                  let l:i += 1
                                  continue
                                endif
                            
                                let l:is_dir = l:x[-1:] ==# l:slash || l:x[-1:] ==# '/'
                            
                                let l:icon = a:state.get_icon(a:ctx, l:x, l:is_dir)
                                let l:icon_width = strdisplaywidth(l:icon)
                                if l:icon_width < a:state.min_width
                                  let l:icon .= repeat(' ', a:state.min_width - l:icon_width)
                                endif
                            
                                if a:state.get_hl is v:null
                                  let l:chunks = [[a:state.left_padding . l:icon . a:state.right_padding]]
                                else
                                  let l:hl = a:state.get_hl(a:ctx, l:x, l:is_dir, l:icon)
                            
                                  if !has_key(a:state.created_hls, l:hl)
                                    let l:guifg = s:get_guifg(l:hl)
                                    let l:default_hl = s:make_temp_hl(l:hl, a:ctx.highlights['default'], l:guifg)
                            
                                    if a:state.combine_selected_hl
                                      let l:selected_hl = s:make_temp_hl(l:hl . '_Selected', a:ctx.highlights['selected'], l:guifg)
                                    else
                                      let l:selected_hl = a:ctx.highlights['selected']
                                    endif
                            
                                    let a:state.created_hls[l:hl] = [l:default_hl, l:selected_hl]
                                  endif
                            
                                  let [l:default_hl, l:selected_hl] = a:state.created_hls[l:hl]
                                  let l:chunks = [[a:state.left_padding], [l:icon, l:default_hl, l:selected_hl], [a:state.right_padding]]
                                endif
                            
                                call a:state.cache.set(l:x, l:chunks)
                            
                                let l:rows[l:index] = l:chunks
                            
                                let l:i += 1
                              endwhile
                            
                              let l:height = a:ctx.height
                              let l:width = empty(l:rows) ? 0 : wilder#render#chunks_displaywidth(l:rows[0])
                              let l:empty_row = [[repeat(' ', l:width)]]
                              let l:rows += repeat([l:empty_row], l:height - len(l:rows))
                            
                              return l:rows

FUNCTION  <SNR>58_need_timer()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer/nvim_api.vim:263
Called 4 times
Total time:   0.000016
 Self time:   0.000016

count  total (s)   self (s)
    4              0.000010   if has('nvim-0.7')
                                " See https://github.com/neovim/neovim/issues/17810.
                                " Avoid calling nvim_buf_set_lines(), so assume timer is always needed.
    4              0.000002     return 1
                              endif
                            
                              try
                                call nvim_buf_set_lines(self.state.dummy_buf, 0, -1, v:true, [])
                              catch
                                return 1
                              endtry
                            
                              return 0

FUNCTION  wilder#highlight#get_hl()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/highlight.vim:229
Called 2 times
Total time:   0.000035
 Self time:   0.000014

count  total (s)   self (s)
    2              0.000003   if has('nvim')
    2   0.000031   0.000010     return wilder#highlight#get_hl_nvim(a:group)
                              else
                                return wilder#highlight#get_hl_vim(a:group)
                              endif

FUNCTION  <SNR>57_to_hl_list()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/highlight.vim:45
Called 4 times
Total time:   0.000785
 Self time:   0.000118

count  total (s)   self (s)
    4              0.000006   if type(a:x) is v:t_string
    2   0.000044   0.000009     let l:x = wilder#highlight#get_hl(a:x)
    2              0.000001   else
    2              0.000001     let l:x = a:x
    4              0.000001   endif
                            
    4              0.000009   if type(l:x) is v:t_list && type(l:x[0]) is v:t_list
                                return l:x
    4              0.000001   endif
                            
    4   0.000228   0.000019   let l:term_hl = s:get_attrs_as_list(l:x[0])
                            
    4   0.000232   0.000027   let l:cterm_hl = [ get(l:x[1], 'foreground', 'NONE'), get(l:x[1], 'background', 'NONE') ] + s:get_attrs_as_list(l:x[1])
                            
    4   0.000242   0.000025   let l:gui_hl = [ get(l:x[2], 'foreground', 'NONE'), get(l:x[2], 'background', 'NONE') ] + s:get_attrs_as_list(l:x[2])
                            
    4              0.000005   return [l:term_hl, l:cterm_hl, l:gui_hl]

FUNCTION  <SNR>57_normalise_attrs()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/highlight.vim:137
Called 6 times
Total time:   0.000237
 Self time:   0.000237

count  total (s)   self (s)
    6              0.000010   let l:attr_map = copy(s:attr_map)
                            
   15              0.000010   for l:attr in a:hl[2:]
    9              0.000009     if has_key(l:attr_map, l:attr)
    9              0.000009       let l:attr_map[l:attr] = 1
                                elseif l:attr[:1] ==# 'no' && has_key(l:attr_map, l:attr[2:])
                                  let l:attr_map[l:attr[2:]] = 0
    9              0.000002     endif
   15              0.000005   endfor
                            
    6              0.000004   let l:result = []
   48              0.000028   for l:attr in keys(l:attr_map)
   42              0.000028     if l:attr_map[l:attr]
    9              0.000009       call add(l:result, l:attr)
   42              0.000010     endif
   48              0.000026   endfor
                            
    6              0.000007   return a:hl[:1] + l:result

FUNCTION  <lambda>221()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/cmdline.vim:793
Called 1 time
Total time:   0.000313
 Self time:   0.000007

count  total (s)   self (s)
                            return wilder#cmdline#get_fuzzy_completion( ctx, x, l:Completion_func, a:fuzzy, a:use_python)

FUNCTION  <SNR>102_BufferDisabled()
    Defined: ~/.local/share/nvim/lazy/copilot.vim/autoload/copilot.vim:140
Called 4 times
Total time:   0.000129
 Self time:   0.000129

count  total (s)   self (s)
    4              0.000027   if &buftype =~# '^\%(help\|prompt\|quickfix\|terminal\)$'
                                return 5
    4              0.000001   endif
    4              0.000005   if exists('b:copilot_disabled')
                                return empty(b:copilot_disabled) ? 0 : 3
    4              0.000001   endif
    4              0.000004   if exists('b:copilot_enabled')
                                return empty(b:copilot_enabled) ? 4 : 0
    4              0.000001   endif
    4              0.000014   let short = empty(&l:filetype) ? '.' : split(&l:filetype, '\.', 1)[0]
    4              0.000004   let config = {}
    4              0.000010   if type(get(g:, 'copilot_filetypes')) == v:t_dict
    4              0.000005     let config = g:copilot_filetypes
    4              0.000001   endif
    4              0.000005   if has_key(config, &l:filetype)
                                return empty(config[&l:filetype])
    4              0.000005   elseif has_key(config, short)
                                return empty(config[short])
    4              0.000004   elseif has_key(config, '*')
                                return empty(config['*'])
    4              0.000001   else
    4              0.000008     return get(s:filetype_defaults, short, 1) == 0 ? 2 : 0
                              endif

FUNCTION  <SNR>1_LoadFTPlugin()
    Defined: /opt/homebrew/Cellar/neovim/0.10.1/share/nvim/runtime/ftplugin.vim:15
Called 4 times
Total time:   0.011086
 Self time:   0.011086

count  total (s)   self (s)
    4              0.000009     if exists("b:undo_ftplugin")
                                  exe b:undo_ftplugin
                                  unlet! b:undo_ftplugin b:did_ftplugin
    4              0.000002     endif
                            
    4              0.000008     let s = expand("<amatch>")
    4              0.000003     if s != ""
    4              0.000009       if &cpo =~# "S" && exists("b:did_ftplugin")
                            	" In compatible mode options are reset to the global values, need to
                            	" set the local values also when a plugin was already used.
                            	unlet b:did_ftplugin
    4              0.000001       endif
                            
                                  " When there is a dot it is used to separate filetype names.  Thus for
                                  " "aaa.bbb" load "aaa" and then "bbb".
    8              0.000012       for name in split(s, '\.')
                                    " Load Lua ftplugins after Vim ftplugins _per directory_
                                    " TODO(clason): use nvim__get_runtime when supports globs and modeline
                                    " XXX: "[.]" in the first pattern makes it a wildcard on Windows
    4              0.011005         exe $'runtime! ftplugin/{name}[.]{{vim,lua}} ftplugin/{name}_*.{{vim,lua}} ftplugin/{name}/*.{{vim,lua}}'
    8              0.000006       endfor
    4              0.000001     endif

FUNCTION  <SNR>111_run()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/pipeline.vim:118
Called 22 times
Total time:   0.019174
 Self time:   0.001737

count  total (s)   self (s)
   22              0.000026   if a:x is v:false || a:x is v:true
                                call a:on_finish(a:ctx, a:x)
                                return
   22              0.000006   endif
                            
   22              0.000021   if type(a:x) is v:t_func
                                let l:ctx = copy(a:ctx)
                                call s:prepare_call(a:x, a:pipeline, a:on_finish, a:on_error, l:ctx, a:i)
                                return
   22              0.000005   endif
                            
   22              0.000015   let l:x = a:x
   22              0.000014   let l:i = a:i
                            
   48              0.000055   while l:i < len(a:pipeline)
   40              0.000052     let l:F = a:pipeline[l:i]
                            
   40              0.000040     if type(l:F) isnot v:t_func
                                  call a:on_error(a:ctx, 'pipeline: expected function but got: ' . string(l:F))
                                  return
   40              0.000011     endif
                            
   40              0.000014     try
   40   0.014560   0.000738       let l:Result = l:F(a:ctx, l:x)
                                catch
                                  call a:on_error(a:ctx, 'pipeline: ' . v:exception)
                                  return
   40              0.000017     endtry
                            
   40              0.000051     if l:Result is v:false || l:Result is v:true
    6              0.000171       call a:on_finish(a:ctx, l:Result)
    6              0.000002       return
   34              0.000009     endif
                            
   34              0.000042     if type(l:Result) is v:t_func
    8              0.000013       let l:ctx = copy(a:ctx)
    8   0.000168   0.000052       call s:prepare_call(l:Result, a:pipeline, a:on_finish, a:on_error, l:ctx, l:i+1)
    8              0.000003       return
   26              0.000006     endif
                            
   26              0.000022     let l:x = l:Result
   26              0.000019     let l:i += 1
   34              0.000018   endwhile
                            
    8   0.001234   0.000044   call a:on_finish(a:ctx, l:x)

FUNCTION  <SNR>49_mru_update()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/cache.vim:56
Called 2 times
Total time:   0.000033
 Self time:   0.000033

count  total (s)   self (s)
    2              0.000003   let l:queue = self['_queue']
    2              0.000002   let l:counts = self['_counts']
                            
    2              0.000004   call add(l:queue, a:key)
    2              0.000003   if !has_key(l:counts, a:key)
    2              0.000002     let l:counts[a:key] = 1
                              else
                                let l:counts[a:key] += 1
    2              0.000001   endif
                            
    2              0.000003   if len(l:queue) > self['_max_size']
                                let l:removed_key = remove(l:queue, 0)
                                let l:counts[l:removed_key] -= 1
                            
                                if l:counts[l:removed_key] == 0
                                  unlet l:counts[l:removed_key]
                                  unlet self['_cache'][l:removed_key]
                                endif
    2              0.000001   endif

FUNCTION  <SNR>55_render()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer/popupmenu.vim:121
Called 5 times
Total time:   0.001563
 Self time:   0.000359

count  total (s)   self (s)
    5              0.000010   call timer_stop(a:state.empty_message_first_draw_timer)
                            
    5              0.000005   if a:state.run_id != a:ctx.run_id
    2              0.000002     let a:state.longest_line_width = 0
    2   0.000014   0.000010     call a:state.draw_cache.clear()
    2   0.000008   0.000005     call a:state.highlight_cache.clear()
    5              0.000002   endif
                            
    5              0.000005   let a:state.run_id = a:ctx.run_id
                            
    5              0.000003   if a:ctx.clear_previous
    2              0.000003     let a:state.page = [-1, -1]
    5              0.000001   endif
                            
    5   0.000196   0.000024   let l:page = s:make_page(a:state, a:ctx, a:result)
    5              0.000005   let a:ctx.page = l:page
    5              0.000005   let a:state.page = l:page
                            
    5              0.000011   let l:height = l:page == [-1, -1] ? 0 : l:page[1] - l:page[0] + 1
                            
    5   0.000042   0.000017   let l:min_height = a:state.get_min_height(a:ctx, a:result)
    5              0.000007   let l:min_height -= len(a:state.top)
    5              0.000006   let l:min_height -= len(a:state.bottom)
    5              0.000004   if l:height < l:min_height
                                let l:height = l:min_height
    5              0.000001   endif
                            
    5              0.000005   let a:ctx.height = l:height
    5              0.000006   let a:ctx.highlights = a:state.highlights
                            
                              " Hide popupmenu if there is nothing to draw and empty message is not set
    5              0.000012   if a:state.page == [-1, -1] && !has_key(a:ctx, 'error') && a:state.empty_message is 0
                                call a:state.api.hide()
                                return
    5              0.000001   endif
                            
    5              0.000006   let l:was_first_draw = a:state.is_first_draw
    5              0.000004   let a:state.is_first_draw = 0
                            
                              " Rough hack to prevent empty message from showing for the first draw.
                              " If the pipeline is async, the first draw will always have an empty result.
                              " This delays the empty message from showing to prevent flicker.
    5              0.000013   if l:was_first_draw && a:state.page == [-1, -1] && a:state.empty_message isnot 0 && !a:ctx.done && a:state.empty_message_first_draw_delay > 0
    1              0.000003     let a:state.empty_message_first_draw_timer = timer_start(a:state.empty_message_first_draw_delay, {-> wilder#main#draw()})
    1              0.000000     return
    4              0.000001   endif
                            
                              " If error or empty message is not showing, check if we need to draw.
    4   0.001035   0.000051   if !has_key(a:ctx, 'error') && a:state.page != [-1, -1] && !wilder#renderer#pre_draw(a:state.left + a:state.right + a:state.top + a:state.bottom, a:ctx, a:result)
                                return
    4              0.000001   endif
                            
    4              0.000004   let a:state.render_id += 1
                            
    4   0.000040   0.000024   if a:state.api.need_timer()
    4              0.000004     let l:render_id = a:state.render_id
    4              0.000016     call timer_start(0, {-> s:render_lines_from_timer(l:render_id, a:state, a:ctx, a:result)})
                              else
                                call s:render_lines(a:state, a:ctx, a:result)
    4              0.000001   endif

FUNCTION  wilder#render#chunks_displaywidth()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/render.vim:250
Called 159 times
Total time:   0.001941
 Self time:   0.001941

count  total (s)   self (s)
  159              0.000092   let l:width = 0
                            
  474              0.000235   for l:chunk in a:chunks
  315              0.000211     if !empty(l:chunk)
  315              0.000394       let l:width += strdisplaywidth(l:chunk[0])
  315              0.000073     endif
  474              0.000447   endfor
                            
  159              0.000078   return l:width

FUNCTION  <SNR>2_LoadIndent()
    Defined: /opt/homebrew/Cellar/neovim/0.10.1/share/nvim/runtime/indent.vim:14
Called 4 times
Total time:   0.003105
 Self time:   0.003105

count  total (s)   self (s)
    4              0.000006     if exists("b:undo_indent")
                                  exe b:undo_indent
                                  unlet! b:undo_indent b:did_indent
    4              0.000001     endif
    4              0.000006     let s = expand("<amatch>")
    4              0.000003     if s != ""
    4              0.000004       if exists("b:did_indent")
                            	unlet b:did_indent
    4              0.000001       endif
                            
                                  " When there is a dot it is used to separate filetype names.  Thus for
                                  " "aaa.bbb" load "indent/aaa.vim" and then "indent/bbb.vim".
    8              0.000011       for name in split(s, '\.')
                                    " XXX: "[.]" in the pattern makes it a wildcard on Windows
    4              0.003046         exe $'runtime! indent/{name}[.]{{vim,lua}}'
    8              0.000005       endfor
    4              0.000001     endif

FUNCTION  <SNR>62_check()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/pipe/check.vim:5
Called 6 times
Total time:   0.000069
 Self time:   0.000049

count  total (s)   self (s)
    6              0.000004   let l:i = 0
                            
    8              0.000010   for l:Check in a:checks
    6   0.000037   0.000017     if !l:Check(a:ctx, a:x)
    4              0.000003       return v:false
    2              0.000001     endif
    4              0.000002   endfor
                            
    2              0.000001   return a:x

FUNCTION  <SNR>109_do()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/main.vim:248
Called 2 times
Total time:   0.001616
 Self time:   0.000099

count  total (s)   self (s)
    2              0.000003   if !s:active || !s:enabled
                                return
    2              0.000001   endif
                            
    2   0.000014   0.000007   if a:check && !wilder#main#in_mode()
                                call wilder#main#stop()
                                return
    2              0.000001   endif
                            
    2   0.000016   0.000010   let l:input = s:getcmdline()
                            
    2              0.000003   let l:has_completion = l:input ==# s:completion
    2              0.000004   let l:is_new_input = s:previous_cmdline is v:null
    2              0.000004   let l:input_changed = s:previous_cmdline isnot v:null && s:previous_cmdline !=# l:input
    2              0.000005   let l:should_keep_completion = s:completion_from_reject_completion isnot v:null && s:completion_from_reject_completion ==# l:input
                            
    2              0.000003   if !l:has_completion && !l:should_keep_completion
    2              0.000002     let s:completion = v:null
    2              0.000002     let s:replaced_cmdline = v:null
    2              0.000002     let s:completion_stack = []
    2              0.000001   endif
                            
    2              0.000001   if !l:should_keep_completion
    2              0.000002     let s:completion_from_reject_completion = v:null
    2              0.000000   endif
                            
    2              0.000002   if s:previous_cmdline is v:null || l:input_changed
    2              0.000002     let s:previous_cmdline = l:input
    2              0.000001   endif
                            
    2              0.000002   let s:draw_done = 0
                            
    2              0.000003   if !l:has_completion && (l:input_changed || l:is_new_input)
    2   0.000717   0.000010     call s:run_pipeline(l:input)
                            
    2              0.000002     if !s:draw_done
    2   0.000806   0.000009       call s:draw()
    2              0.000001     endif
    2              0.000001   endif
                            
    2              0.000001   let s:force = 0

FUNCTION  wilder#main#start()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/main.vim:79
Called 2 times
Total time:   0.000045
 Self time:   0.000027

count  total (s)   self (s)
                              " Workaround for https://github.com/neovim/neovim/issues/15403
    2   0.000029   0.000011   if wilder#main#in_mode() && s:enabled
                                " use timer_start so statusline does not flicker
                                " when using mappings which performs a command
    2              0.000010     call timer_start(0, {-> s:start()})
    2              0.000002   endif

FUNCTION  wilder#cmdline#getcompletion()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/cmdline.vim:345
Called 3 times
Total time:   0.000444
 Self time:   0.000444

count  total (s)   self (s)
    3              0.000004   if has_key(a:res, 'completions')
                                return a:res['completions']
    3              0.000001   endif
                            
    3              0.000003   let l:expand_arg = a:res.expand_arg
                            
                              " getting all shellcmds takes a significant amount of time
    3              0.000004   if a:res.expand ==# 'shellcmd' && empty(l:expand_arg)
                                return []
    3              0.000001   endif
                            
    3              0.000006   if a:res.expand ==# 'dir' || a:res.expand ==# 'file' || a:res.expand ==# 'file_in_path' || a:res.expand ==# 'shellcmd'
                            
                                if get(a:res, 'has_wildcard', 0)
                                  let l:xs = expand(l:expand_arg, 0, 1)
                            
                                  if len(l:xs) == 1 && l:xs[0] ==# l:expand_arg
                                    return []
                                  endif
                            
                                  return l:xs
                                endif
                            
                                return getcompletion(l:expand_arg, a:res.expand, 1)
    3              0.000001   endif
                            
    3              0.000004   if a:res.expand ==# 'nothing' || a:res.expand ==# 'unsuccessful'
                                return []
    3              0.000002   elseif a:res.expand ==# 'augroup'
                                return getcompletion(l:expand_arg, 'augroup')
    3              0.000002   elseif a:res.expand ==# 'arglist'
                                return getcompletion(l:expand_arg, 'arglist')
    3              0.000002   elseif a:res.expand ==# 'behave'
                                return getcompletion(l:expand_arg, 'behave')
    3              0.000002   elseif a:res.expand ==# 'buffer'
                                let l:buffers = getcompletion(l:expand_arg, 'buffer')
                                return map(l:buffers, {_, x -> fnamemodify(x, ':~:.')})
    3              0.000002   elseif a:res.expand ==# 'checkhealth'
                                return has('nvim') ? getcompletion(l:expand_arg, 'checkhealth') : []
    3              0.000002   elseif a:res.expand ==# 'color'
                                return getcompletion(l:expand_arg, 'color')
    3              0.000002   elseif a:res.expand ==# 'command'
    3              0.000349     return getcompletion(l:expand_arg, 'command')
                              elseif a:res.expand ==# 'compiler'
                                return getcompletion(l:expand_arg, 'compiler')
                              elseif a:res.expand ==# 'cscope'
                                return getcompletion(a:res.cmdline[a:res.subcommand_start :], 'cscope')
                              elseif a:res.expand ==# 'event'
                                return getcompletion(l:expand_arg, 'event')
                              elseif a:res.expand ==# 'event_and_augroup'
                                return getcompletion(l:expand_arg, 'event') + getcompletion(l:expand_arg, 'augroup')
                              elseif a:res.expand ==# 'expression'
                                return getcompletion(l:expand_arg, 'expression')
                              elseif a:res.expand ==# 'environment'
                                return getcompletion(l:expand_arg, 'environment')
                              elseif a:res.expand ==# 'file_opt'
                                let l:opts = ['bad', 'bin', 'enc', 'ff', 'nobin']
                                if a:res.cmd ==# 'read'
                                  call insert(l:opts, 'edit', 2)
                                endif
                            
                                return filter(l:opts, {_, x -> s:is_prefix(x, l:expand_arg)})
                              elseif a:res.expand ==# 'function'
                                return getcompletion(l:expand_arg, 'function')
                              elseif a:res.expand ==# 'help'
                                return getcompletion(l:expand_arg, 'help')
                              elseif a:res.expand ==# 'highlight'
                                return getcompletion(l:expand_arg, 'highlight')
                              elseif a:res.expand ==# 'history'
                                return getcompletion(l:expand_arg, 'history')
                              elseif a:res.expand ==# 'language'
                                return getcompletion(l:expand_arg, 'locale') + filter(['ctype', 'messages', 'time'], {_, x -> s:is_prefix(x, l:expand_arg)})
                              elseif a:res.expand ==# 'locale'
                                return getcompletion(l:expand_arg, 'locale')
                              elseif a:res.expand ==# 'lua'
                                " Lua completion handled by s:get_lua_completion()
                                return []
                              elseif a:res.expand ==# 'mapping'
                                let l:map_args = get(a:res, 'map_args', {})
                            
                                let l:result = []
                            
                                if l:expand_arg ==# '' || l:expand_arg[0] ==# '<'
                                  for l:map_arg in ['<buffer>', '<unique>', '<nowait>', '<silent>', '<special>', '<script>', '<expr>']
                                    if !has_key(l:map_args, l:map_arg)
                                      call add(l:result, l:map_arg)
                                    endif
                                  endfor
                            
                                  if l:expand_arg[0] ==# '<'
                                    call filter(l:result, {_, x -> s:is_prefix(x, l:expand_arg)})
                                  endif
                                endif
                            
                                if a:res.cmd[-5 :] ==# 'unmap'
                                  let l:mode = a:res.cmd ==# 'unmap' ? '' : a:res.cmd[0]
                                  let l:cmd = 'map'
                                elseif a:res.cmd[-3 :] ==# 'map'
                                  let l:mode = a:res.cmd ==# 'map' || a:res.cmd ==# 'noremap' ? '' : a:res.cmd[0]
                                  let l:cmd = 'map'
                                elseif a:res.cmd[-12 :] ==# 'unabbreviate'
                                  let l:mode = a:res.cmd ==# 'unabbreviate' ? '' : a:res.cmd[0]
                                  let l:cmd = 'abbrev'
                                elseif a:res.cmd ==# 'abbreviate'
                                  let l:mode = ''
                                  let l:cmd = 'abbrev'
                                elseif a:res.cmd[-6 :] ==# 'abbrev'
                                  let l:mode = a:res.cmd ==# 'noreabbrev' ? '' : a:res.cmd[0]
                                  let l:cmd = 'abbrev'
                                else
                                  let l:mode = ''
                                  let l:cmd = 'map'
                                endif
                            
                                let l:lines = split(execute(l:mode . l:cmd . ' ' . join(keys(l:map_args), ' ') . ' ' . l:expand_arg), "\n")
                            
                                if len(l:lines) != 1 || (l:lines[0] !=# 'No mapping found' && l:lines[0] !=# 'No abbreviation found')
                                  for l:line in l:lines
                                    let l:words = split(l:line,'\s\+')
                                    if l:line[0] ==# ' '
                                      let l:map_lhs = l:words[0]
                                    else
                                      let l:map_lhs = l:words[1]
                                    endif
                            
                                    call add(l:result, l:map_lhs)
                                  endfor
                                endif
                            
                                return wilder#uniq_filt(0, 0, l:result)
                              elseif a:res.expand ==# 'mapclear'
                                return s:is_prefix('<buffer>', l:expand_arg) ? ['<buffer>'] : []
                              elseif a:res.expand ==# 'menu'
                                if !has_key(a:res, 'menu_arg')
                                  return []
                                endif
                                return getcompletion(a:res.menu_arg, 'menu')
                              elseif a:res.expand ==# 'messages'
                                return getcompletion(l:expand_arg, 'messages')
                              elseif a:res.expand ==# 'option'
                                return getcompletion(l:expand_arg, 'option')
                              elseif a:res.expand ==# 'option_bool'
                                return filter(wilder#cmdline#set#get_bool_options(), {_, x -> s:is_prefix(x, l:expand_arg)})
                              elseif a:res.expand ==# 'option_old'
                                let l:old_option = eval('&' . a:res.option)
                                return [type(l:old_option) is v:t_string ? l:old_option : string(l:old_option)]
                              elseif a:res.expand ==# 'packadd'
                                return getcompletion(l:expand_arg, 'packadd')
                              elseif a:res.expand ==# 'profile'
                                return filter(['continue', 'dump', 'file', 'func', 'pause', 'start'], {_, x -> s:is_prefix(x, l:expand_arg)})
                              elseif a:res.expand ==# 'ownsyntax'
                                return getcompletion(l:expand_arg, 'syntax')
                              elseif a:res.expand ==# 'shellcmd'
                                return getcompletion(l:expand_arg, 'shellcmd')
                              elseif a:res.expand ==# 'sign'
                                return getcompletion(a:res.cmdline[a:res.subcommand_start :], 'sign')
                              elseif a:res.expand ==# 'syntax'
                                return getcompletion(l:expand_arg, 'syntax')
                              elseif a:res.expand ==# 'syntax_subcommand'
                                return filter(['case', 'clear', 'cluster', 'conceal', 'enable', 'foldlevel', 'include', 'iskeyword', 'keyword', 'list', 'manual', 'match', 'off', 'on', 'region', 'reset', 'spell', 'sync'], {_, x -> s:is_prefix(x, l:expand_arg)})
                                return getcompletion(l:expand_arg, 'syntax')
                              elseif a:res.expand ==# 'syntime'
                                return getcompletion(l:expand_arg, 'syntime')
                              elseif a:res.expand ==# 'user'
                                return getcompletion(l:expand_arg, 'user')
                              elseif a:res.expand ==# 'user_func'
                                let l:functions = getcompletion(l:expand_arg, 'function')
                                let l:functions = filter(l:functions, {_, x -> !(x[0] >= 'a' && x[0] <= 'z')})
                                return map(l:functions, {_, x -> x[-1 :] ==# ')' ? x[: -3] : x[: -2]})
                              elseif a:res.expand ==# 'user_addr_type'
                                return filter(['arguments', 'buffers', 'lines', 'loaded_buffers', 'quickfix', 'tabs', 'windows'], {_, x -> s:is_prefix(x, l:expand_arg)})
                              elseif a:res.expand ==# 'user_cmd_flags'
                                return filter(['addr', 'bar', 'buffer', 'complete', 'count', 'nargs', 'range', 'register'], {_, x -> s:is_prefix(x, l:expand_arg)})
                              elseif a:res.expand ==# 'user_complete'
                                return filter(['arglist', 'augroup', 'behave', 'buffer', 'checkhealth', 'color', 'command', 'compiler', 'cscope', 'custom', 'customlist', 'dir', 'environment', 'event', 'expression', 'file', 'file_in_path', 'filetype', 'function', 'help', 'highlight', 'history', 'locale', 'mapclear', 'mapping', 'menu', 'messages', 'option', 'packadd', 'shellcmd', 'sign', 'syntax', 'syntime', 'tag', 'tag_listfiles', 'user', 'var'], {_, x -> s:is_prefix(x, l:expand_arg)})
                              elseif a:res.expand ==# 'user_nargs'
                                if empty(l:expand_arg)
                                  return ['*', '+', '0', '1', '?']
                                endif
                            
                                if l:expand_arg ==# '*' || l:expand_arg ==# '+' || l:expand_arg ==# '0' || l:expand_arg ==# '1' || l:expand_arg ==# '?'
                                  return [l:expand_arg]
                                endif
                            
                                return []
                              elseif a:res.expand ==# 'user_commands'
                                return filter(getcompletion(l:expand_arg, 'command'), {_, x -> x[0] >=# 'A' && x[0] <=# 'Z'})
                              elseif a:res.expand ==# 'tags'
                                if a:ctx.session_id > s:cached_tags_session_id
                                  let s:cached_tags_session_id = a:ctx.session_id
                                  let s:cached_tags = {}
                                endif
                            
                                let l:arg = a:res.expand_arg
                                if l:arg[0] ==# '/'
                                  let l:taglist_arg = l:arg[1:]
                                else
                                  let l:taglist_arg = l:arg
                                endif
                            
                                if empty(l:taglist_arg)
                                  let l:taglist_arg = '.'
                                endif
                            
                                if !has_key(s:cached_tags, l:taglist_arg)
                                  let s:cached_tags[l:taglist_arg] = map(taglist(l:taglist_arg), {_, x -> x.name})
                                endif
                            
                                return copy(s:cached_tags[l:taglist_arg])
                              elseif a:res.expand ==# 'var'
                                return getcompletion(l:expand_arg, 'var')
                              endif
                            
                              if !exists('s:has_get_completion_cmdline')
                                try
                                  " cmdline completion only available in Vim 8.2+
                                  call getcompletion('foo', 'cmdline')
                                  let s:has_getcompletion_cmdline = 1
                                catch
                                  let s:has_getcompletion_cmdline = 0
                                endtry
                              endif
                            
                              " fallback to cmdline getcompletion
                              if s:has_getcompletion_cmdline
                                return getcompletion(a:res.cmdline, 'cmdline')
                              endif
                            
                              return []

FUNCTION  <lambda>195()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/pipe/branch.vim:16
Called 1 time
Total time:   0.000020
 Self time:   0.000004

count  total (s)   self (s)
                            return s:on_finish(l:state, ctx, x)

FUNCTION  wilder#pipeline#wait()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/pipeline.vim:166
Called 4 times
Total time:   0.000019
 Self time:   0.000019

count  total (s)   self (s)
    4              0.000008   let l:state = { 'f': a:f, 'on_finish': a:on_finish, }
                            
    4              0.000009   return {ctx -> s:wait_start(l:state, ctx)}

FUNCTION  <SNR>63_result_start()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/pipe/result.vim:6
Called 6 times
Total time:   0.000562
 Self time:   0.000129

count  total (s)   self (s)
    6              0.000004   let l:kvs = []
   14              0.000016   for l:key in keys(a:args)
    8              0.000021     call add(l:kvs, {'key': l:key, 'value': a:args[l:key]})
   14              0.000022   endfor
                            
    6              0.000012   let l:result = type(a:x) isnot v:t_dict ? {'value': a:x} : a:x
                            
    6              0.000005   if empty(l:kvs)
                                return l:result
    6              0.000002   endif
                            
    6   0.000458   0.000025   return s:result(l:kvs, a:ctx, l:result)

FUNCTION  <lambda>97()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/pipe/check.vim:1
Called 2 times
Total time:   0.000036
 Self time:   0.000008

count  total (s)   self (s)
                            return s:check(a:args, ctx, x)

FUNCTION  wilder#cmdline#get_fuzzy_completion()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/cmdline.vim:261
Called 2 times
Total time:   0.000449
 Self time:   0.000071

count  total (s)   self (s)
                              " Use tag-regexp to get fuzzy completions from taglist()
    2              0.000002   if a:res.expand ==# 'tags'
                                let l:fuzzy_char = get(a:res, 'fuzzy_char', '')
                            
                                if empty(l:fuzzy_char)
                                  let a:res.expand_arg = '.'
                                else
                                  let a:res.expand_arg = '/'
                                  if toupper(l:fuzzy_char) !=# l:fuzzy_char
                                    let a:res.expand_arg .= '\c'
                                  endif
                            
                                  if a:fuzzy_mode == 1
                                    let a:res.expand_arg .= '^'
                                  endif
                            
                                  let a:res.expand_arg .= l:fuzzy_char
                                endif
                            
                                return a:getcompletion(a:ctx, a:res)
    2              0.000000   endif
                            
                              " If argument is empty, use normal completions
                              " Don't fuzzy complete for vim help since a maximum of 300 help tags are returned
    2              0.000004   if a:res.pos == len(a:res.cmdline) || (a:res.expand ==# 'help' && !a:use_python)
    1   0.000290   0.000005     return a:getcompletion(a:ctx, a:res)
    1              0.000000   endif
                            
    1              0.000002   let l:fuzzy_char = get(a:res, 'fuzzy_char', '')
                            
                              " Keep leading . in file expansion to search hidden directories
    1              0.000002   if a:fuzzy_mode == 2 && !(wilder#cmdline#is_file_expansion(a:res.expand) && l:fuzzy_char ==# '.')
                                let l:fuzzy_char = ''
    1              0.000000   endif
                            
    1              0.000003   if toupper(l:fuzzy_char) ==# l:fuzzy_char
                                let a:res.expand_arg = a:res.expand_arg . l:fuzzy_char
                                return a:getcompletion(a:ctx, a:res)
    1              0.000000   endif
                            
    1              0.000002   let l:lower_res = copy(a:res)
    1              0.000002   let l:lower_res.expand_arg = a:res.expand_arg . l:fuzzy_char
                            
    1              0.000002   let l:upper_res = copy(a:res)
    1              0.000002   let l:upper_res.expand_arg = a:res.expand_arg . toupper(l:fuzzy_char)
                            
    1   0.000108   0.000015   return wilder#wait(a:getcompletion(a:ctx, l:upper_res), {ctx, upper_xs -> wilder#resolve(ctx, wilder#wait(a:getcompletion(ctx, l:lower_res), {ctx, lower_xs -> wilder#resolve(ctx, wilder#uniq_filt(0, 0, lower_xs + upper_xs))}))})

FUNCTION  wilder#renderer#popupmenu#draw_column()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer/popupmenu.vim:572
Called 18 times
Total time:   0.006663
 Self time:   0.001042

count  total (s)   self (s)
   18              0.000017   let l:Column = a:column
   18              0.000014   let l:height = a:ctx.height
                            
   18              0.000018   if type(l:Column) is v:t_dict
                                let l:Column = l:Column.value
   18              0.000005   endif
                            
   18              0.000017   if type(l:Column) is v:t_func
    6   0.006392   0.000770     let l:Column = l:Column(a:ctx, a:result)
   18              0.000005   endif
                            
   18              0.000017   if type(l:Column) is v:t_string
    9              0.000007     if empty(l:Column)
    3              0.000002       return []
    6              0.000002     endif
                            
    6              0.000012     return repeat([[[l:Column]]], l:height)
    9              0.000002   endif
                            
                              " v:t_list
    9              0.000007   if empty(l:Column)
    1              0.000000     return []
    8              0.000002   endif
                            
    8              0.000009   if empty(l:Column[0])
                                return []
    8              0.000002   endif
                            
                              " highlight chunk
    8              0.000009   if type(l:Column[0]) is v:t_string
    6              0.000012     return repeat([[l:Column]], l:height)
    2              0.000000   endif
                            
                              " list of highlight chunks
    2              0.000002   if type(l:Column[0][0]) is v:t_string
                                return repeat([l:Column], l:height)
    2              0.000001   endif
                            
                              " list of list of highlight chunks
    2              0.000001   return l:Column

FUNCTION  <SNR>58_delete_all_lines()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer/nvim_api.vim:243
Called 3 times
Total time:   0.000091
 Self time:   0.000091

count  total (s)   self (s)
    3              0.000090   call nvim_buf_set_lines(self.state.buf, 0, -1, v:true, [])

FUNCTION  <SNR>109_getcmdline()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/main.vim:634
Called 2 times
Total time:   0.000007
 Self time:   0.000007

count  total (s)   self (s)
    2              0.000003   if s:opts.use_cmdlinechanged || !s:opts.before_cursor
    2              0.000002     return getcmdline()
                              endif
                            
                              if a:0
                                let l:cmdline = a:1
                                let l:cmdpos = a:2
                              else
                                let l:cmdline = getcmdline()
                                let l:cmdpos = getcmdpos()
                              endif
                            
                              if l:cmdpos <= 1
                                return ''
                              else
                                return l:cmdline[: l:cmdpos - 2]
                              endif

FUNCTION  wilder#cmdline#main#is_whitespace()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/cmdline/main.vim:678
Called 2 times
Total time:   0.000008
 Self time:   0.000008

count  total (s)   self (s)
    2              0.000003   let l:nr = char2nr(a:char)
    2              0.000004   return a:char ==# ' ' || l:nr >= 9 && l:nr <= 13

FUNCTION  <lambda>202()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/pipe/branch.vim:5
Called 1 time
Total time:   0.000164
 Self time:   0.000004

count  total (s)   self (s)
                            return s:branch(a:args, ctx, x)

FUNCTION  <lambda>204()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/pipeline.vim:105
Called 1 time
Total time:   0.008881
 Self time:   0.000004

count  total (s)   self (s)
                            return s:run(a:pipeline, a:on_finish, a:on_error, ctx, x, a:i)

FUNCTION  <lambda>209()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/pipe/branch.vim:38
Called 1 time
Total time:   0.000033
 Self time:   0.000003

count  total (s)   self (s)
                            return s:on_finish(a:state, ctx, x)

FUNCTION  wilder#render#draw_candidate()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/render.vim:10
Called 53 times
Total time:   0.001297
 Self time:   0.000916

count  total (s)   self (s)
   53   0.000296   0.000226   let l:x = wilder#main#get_candidate(a:ctx, a:result, a:i)
                            
   53              0.000053   if has_key(a:result, 'draw')
                                let l:ctx = { 'i': a:i, 'selected': a:ctx.selected == a:i, }
                            
                                for l:F in a:result.draw
                                  if type(l:F) isnot v:t_func
                                    let l:F = function(l:F)
                                  endif
                            
                                  let l:x = l:F(l:ctx, l:x, get(a:result, 'data', {}))
                                endfor
   53              0.000013   endif
                            
   53   0.000593   0.000283   return wilder#render#to_printable(l:x)

FUNCTION  <SNR>64_on_finish()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/pipe/branch.vim:26
Called 12 times
Total time:   0.002225
 Self time:   0.000115

count  total (s)   self (s)
   12              0.000011   if a:x isnot v:false
    6   0.000097   0.000036     call s:resolve(a:state, a:ctx, a:x)
    6              0.000003     return
    6              0.000002   endif
                            
    6              0.000006   let a:state.index += 1
                            
    6              0.000008   if a:state.index >= len(a:state.pipelines)
                                call s:resolve(a:state, a:ctx, v:false)
                                return
    6              0.000001   endif
                            
    6   0.001157   0.000149   call wilder#pipeline#run( a:state.pipelines[a:state.index], {ctx, x -> s:on_finish(a:state, ctx, x)}, {ctx, x -> s:on_error(a:state, ctx, x)}, copy(a:state.original_ctx), copy(a:state.original_x), )

FUNCTION  <SNR>58_add_highlight()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer/nvim_api.vim:251
Called 53 times
Total time:   0.000175
 Self time:   0.000175

count  total (s)   self (s)
   53              0.000165   call nvim_buf_add_highlight(self.state.buf, self.state.ns_id, a:hl, a:line, a:col_start, a:col_end)

FUNCTION  <lambda>211()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/pipe/branch.vim:5
Called 1 time
Total time:   0.000647
 Self time:   0.000004

count  total (s)   self (s)
                            return s:branch(a:args, ctx, x)

FUNCTION  <lambda>212()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/pipeline.vim:105
Called 1 time
Total time:   0.000105
 Self time:   0.000005

count  total (s)   self (s)
                            return s:run(a:pipeline, a:on_finish, a:on_error, ctx, x, a:i)

FUNCTION  wilder#lua#call_wrapped_function()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/lua.vim:44
Called 60 times
Total time:   0.031994
 Self time:   0.000783

count  total (s)   self (s)
   60              0.000124   let l:F = s:functions[a:index]
   60   0.008872   0.003905   let l:Result = call(l:F, a:000)
   60   0.015508   0.000237   return wilder#lua#wrap(l:Result)

FUNCTION  <lambda>219()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/pipe/branch.vim:38
Called 1 time
Total time:   0.000022
 Self time:   0.000004

count  total (s)   self (s)
                            return s:on_finish(a:state, ctx, x)

FUNCTION  copilot#OnFileType()
    Defined: ~/.local/share/nvim/lazy/copilot.vim/autoload/copilot.vim:446
Called 4 times
Total time:   0.000164
 Self time:   0.000034

count  total (s)   self (s)
    4   0.000153   0.000024   if empty(s:BufferDisabled()) && &l:modifiable && &l:buflisted
                                call copilot#util#Defer(function('s:Attach'), bufnr(''))
    4              0.000001   endif

FUNCTION  <lambda>222()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/cmdline.vim:799
Called 1 time
Total time:   0.000028
 Self time:   0.000010

count  total (s)   self (s)
                            return wilder#resolve(ctx, { 'value': xs, 'pos': a:res.pos, 'data': s:convert_result_to_data(a:res), })

FUNCTION  <lambda>223()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/pipeline.vim:171
Called 1 time
Total time:   0.000059
 Self time:   0.000004

count  total (s)   self (s)
                            return s:wait_start(l:state, ctx)

FUNCTION  <lambda>224()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/pipeline.vim:105
Called 1 time
Total time:   0.000310
 Self time:   0.000006

count  total (s)   self (s)
                            return s:run(a:pipeline, a:on_finish, a:on_error, ctx, x, a:i)

FUNCTION  <SNR>55_make_lines()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer/popupmenu.vim:446
Called 3 times
Total time:   0.015686
 Self time:   0.003388

count  total (s)   self (s)
    3              0.000006   let l:Highlighter = get(a:state, 'highlighter', [])
                            
    3              0.000003   let l:height = a:ctx.height
                            
    3              0.000002   if l:height > 0
    3   0.000128   0.000123     let l:left_column_chunks = map(repeat([0], l:height), {-> []})
    3   0.001465   0.000018     call s:draw_columns(l:left_column_chunks, a:state.left, a:ctx, a:result)
                            
    3   0.000126   0.000122     let l:right_column_chunks = map(repeat([0], l:height), {-> []})
    3   0.006367   0.000020     call s:draw_columns(l:right_column_chunks, a:state.right, a:ctx, a:result)
                              else
                                let l:left_column_chunks = []
                                let l:right_column_chunks = []
    3              0.000001   endif
                            
                              " [[left_column, chunks, right_column]]
    3              0.000006   let l:raw_lines = repeat([0], l:height)
                              " [[chunks_width, total_width]]
    3              0.000005   let l:widths = repeat([0], l:height)
                            
                              " Draw each line and calculate the width taken by the chunks.
    3              0.000005   let [l:start, l:end] = a:state.page
    3              0.000002   let l:i = 0
   56              0.000033   while l:i < l:height
   53              0.000042     let l:index = l:start + l:i
   53              0.000031     if l:index <= l:end
   53   0.002772   0.000284       let l:chunks = s:draw_candidates_chunks(a:state, a:ctx, a:result, l:index)
                                else
                                  let l:chunks = []
   53              0.000013     endif
   53              0.000060     let l:left_column = l:left_column_chunks[l:i]
   53              0.000058     let l:right_column = l:right_column_chunks[l:i]
                            
   53   0.000969   0.000333     let l:left_width = wilder#render#chunks_displaywidth(l:left_column)
   53   0.000720   0.000246     let l:chunks_width = wilder#render#chunks_displaywidth(l:chunks)
   53   0.001073   0.000243     let l:right_width = wilder#render#chunks_displaywidth(l:right_column)
                            
   53              0.000069     let l:total_width = l:left_width + l:chunks_width + l:right_width
                            
                                " Store the longest line width seen so far.
   53              0.000045     if l:total_width > a:state.longest_line_width
    9              0.000009       let a:state.longest_line_width = l:total_width
   53              0.000013     endif
                            
   53              0.000043     let l:index = l:i - l:start
   53              0.000082     let l:raw_lines[l:i] = [l:left_column, l:chunks, l:right_column]
   53              0.000066     let l:widths[l:i] = [l:chunks_width, l:total_width]
                            
   53              0.000031     let l:i += 1
   56              0.000018   endwhile
                            
    3   0.000060   0.000019   let l:max_width = a:state.get_max_width(a:ctx, a:result)
    3   0.000036   0.000010   let l:min_width = a:state.get_min_width(a:ctx, a:result)
                            
                              " Try to fit the longest line seen so far, if possible.
    3              0.000007   let l:expected_width = min([ l:max_width, a:state.longest_line_width, ])
    3              0.000003   if l:expected_width < l:min_width
    3              0.000003     let l:expected_width = l:min_width
    3              0.000001   endif
                            
                              " lines is the list of list of chunks which will be drawn.
                              " Each element represents one line of the popupmenu.
    3              0.000005   let l:lines = repeat([0], l:height)
                            
    3              0.000002   let l:i = 0
   56              0.000051   while l:i < len(l:raw_lines)
   53              0.000077     let [l:left_column, l:chunks, l:right_column] = l:raw_lines[l:i]
   53              0.000066     let [l:chunks_width, l:total_width] = l:widths[l:i]
                            
                                " Truncate or pad if necessary
   53              0.000040     if l:total_width > l:expected_width
                                  let l:ellipsis = a:state.ellipsis
                                  let l:ellipsis_width = strdisplaywidth(l:ellipsis)
                            
                                  let l:left_right_width = l:total_width - l:chunks_width
                                  let l:truncated_width = l:expected_width - l:left_right_width - l:ellipsis_width
                                  let l:chunks = wilder#render#truncate_chunks(l:truncated_width, l:chunks)
                            
                                  call add(l:chunks, [l:ellipsis])
                                  call add(l:chunks, [repeat(' ', l:truncated_width - wilder#render#chunks_displaywidth(l:chunks))])
   53              0.000041     elseif l:total_width < l:expected_width
   53              0.000053       let l:to_pad = l:expected_width - l:total_width
   53              0.000086       let l:chunks += [[repeat(' ', l:to_pad)]]
   53              0.000012     endif
                            
   53              0.000094     let l:lines[l:i] = l:left_column + l:chunks + l:right_column
                            
   53              0.000028     let l:i += 1
   56              0.000031   endwhile
                            
    3              0.000003   return [l:lines, l:expected_width]

FUNCTION  <SNR>58_set_option()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer/nvim_api.vim:230
Called 5 times
Total time:   0.000100
 Self time:   0.000051

count  total (s)   self (s)
    5              0.000004   if self.state.window_state ==# 'hidden'
                                return
    5              0.000001   endif
                            
    5              0.000004   if self.state.window_state ==# 'pending'
                                let self.state.options[a:option] = a:value
                                return
    5              0.000001   endif
                            
    5   0.000077   0.000028   call nvim_win_set_option(self.state.win, a:option, a:value)

FUNCTION  wilder#main#stop()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/main.vim:172
Called 4 times
Total time:   0.000385
 Self time:   0.000072

count  total (s)   self (s)
    4              0.000007   let s:select_next = 0
                            
    4              0.000003   if !s:active
    3              0.000001     return
    1              0.000000   endif
                            
    1              0.000002   if exists('#WilderCmdlineChanged')
    1              0.000001     augroup WilderCmdlineChanged
    1              0.000005       autocmd!
    1              0.000000     augroup END
    1              0.000003     augroup! WilderCmdlineChanged
    1              0.000000   endif
                            
    1              0.000002   if s:timer isnot v:null
                                call timer_stop(s:timer)
                                let s:timer = v:null
    1              0.000000   endif
                            
    1              0.000001   if exists('#WilderCmdlineLeave')
    1              0.000000     augroup WilderCmdlineLeave
    1              0.000004       autocmd!
    1              0.000000     augroup END
    1              0.000002     augroup! WilderCmdlineLeave
    1              0.000000   endif
                            
    1              0.000001   if exists('#WilderVimResized')
    1              0.000000     augroup WilderVimResized
    1              0.000003       autocmd!
    1              0.000000     augroup END
    1              0.000002     augroup! WilderVimResized
    1              0.000000   endif
                            
    1              0.000001   let s:active = 0
    1              0.000003   let s:result = {'value': [], 'data': {}}
    1              0.000001   let s:selected = -1
    1              0.000001   let s:selection_was_made = 0
    1              0.000001   let s:clear_previous_renderer_state = 0
    1              0.000001   let s:completion_stack = []
    1              0.000001   let s:previous_cmdline = v:null
    1              0.000001   let s:completion = v:null
    1              0.000001   let s:error = v:null
    1              0.000001   let s:replaced_cmdline = v:null
    1              0.000001   let s:completion_from_reject_completion = v:null
                            
    1              0.000001   if !s:hidden
    1   0.000317   0.000004     call s:post_hook()
    1              0.000000   endif
                            
    1              0.000001   let s:hidden = 0

FUNCTION  <SNR>76_Highlight_Matching_Pair()
    Defined: /opt/homebrew/Cellar/neovim/0.10.1/share/nvim/runtime/plugin/matchparen.vim:44
Called 4 times
Total time:   0.000300
 Self time:   0.000262

count  total (s)   self (s)
    4              0.000016   if !exists("w:matchparen_ids")
                                let w:matchparen_ids = []
    4              0.000003   endif
                              " Remove any previous match.
    4   0.000073   0.000035   call s:Remove_Matches()
                            
                              " Avoid that we remove the popup menu.
                              " Return when there are no colors (looks like the cursor jumps).
    4              0.000013   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
                                return
    4              0.000001   endif
                            
                              " Get the character under the cursor and check if it's in 'matchpairs'.
    4              0.000008   let c_lnum = line('.')
    4              0.000006   let c_col = col('.')
    4              0.000003   let before = 0
                            
    4              0.000010   let text = getline(c_lnum)
    4              0.000040   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
    4              0.000006   if empty(matches)
                                let [c_before, c] = ['', '']
    4              0.000002   else
    4              0.000011     let [c_before, c] = matches[1:2]
    4              0.000002   endif
    4              0.000034   let plist = split(&matchpairs, '.\zs[:,]')
    4              0.000009   let i = index(plist, c)
    4              0.000003   if i < 0
                                " not found, in Insert mode try character before the cursor
    4              0.000011     if c_col > 1 && (mode() == 'i' || mode() == 'R')
                                  let before = strlen(c_before)
                                  let c = c_before
                                  let i = index(plist, c)
    4              0.000001     endif
    4              0.000002     if i < 0
                                  " not found, nothing to do
    4              0.000004       return
                                endif
                              endif
                            
                              " Figure out the arguments for searchpairpos().
                              if i % 2 == 0
                                let s_flags = 'nW'
                                let c2 = plist[i + 1]
                              else
                                let s_flags = 'nbW'
                                let c2 = c
                                let c = plist[i - 1]
                              endif
                              if c == '['
                                let c = '\['
                                let c2 = '\]'
                              endif
                            
                              " Find the match.  When it was just before the cursor move it there for a
                              " moment.
                              if before > 0
                                let has_getcurpos = exists("*getcurpos")
                                if has_getcurpos
                                  " getcurpos() is more efficient but doesn't exist before 7.4.313.
                                  let save_cursor = getcurpos()
                                else
                                  let save_cursor = winsaveview()
                                endif
                                call cursor(c_lnum, c_col - before)
                              endif
                            
                              if !has("syntax") || !exists("g:syntax_on")
                                let s_skip = "0"
                              else
                                " Build an expression that detects whether the current cursor position is
                                " in certain syntax types (string, comment, etc.), for use as
                                " searchpairpos()'s skip argument.
                                " We match "escape" for special items, such as lispEscapeSpecial, and
                                " match "symbol" for lispBarSymbol.
                                let s_skip = 'synstack(".", col("."))' . '->indexof({_, id -> synIDattr(id, "name") =~? ' . '"string\\|character\\|singlequote\\|escape\\|symbol\\|comment"}) >= 0'
                                " If executing the expression determines that the cursor is currently in
                                " one of the syntax types, then we want searchpairpos() to find the pair
                                " within those syntax types (i.e., not skip).  Otherwise, the cursor is
                                " outside of the syntax types and s_skip should keep its value so we skip
                                " any matching pair inside the syntax types.
                                " Catch if this throws E363: pattern uses more memory than 'maxmempattern'.
                                try
                                  execute 'if ' . s_skip . ' | let s_skip = "0" | endif'
                                catch /^Vim\%((\a\+)\)\=:E363/
                                  " We won't find anything, so skip searching, should keep Vim responsive.
                                  return
                                endtry
                              endif
                            
                              " Limit the search to lines visible in the window.
                              let stoplinebottom = line('w$')
                              let stoplinetop = line('w0')
                              if i % 2 == 0
                                let stopline = stoplinebottom
                              else
                                let stopline = stoplinetop
                              endif
                            
                              " Limit the search time to 300 msec to avoid a hang on very long lines.
                              " This fails when a timeout is not supported.
                              if mode() == 'i' || mode() == 'R'
                                let timeout = exists("b:matchparen_insert_timeout") ? b:matchparen_insert_timeout : g:matchparen_insert_timeout
                              else
                                let timeout = exists("b:matchparen_timeout") ? b:matchparen_timeout : g:matchparen_timeout
                              endif
                              try
                                let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline, timeout)
                              catch /E118/
                                " Can't use the timeout, restrict the stopline a bit more to avoid taking
                                " a long time on closed folds and long lines.
                                " The "viewable" variables give a range in which we can scroll while
                                " keeping the cursor at the same position.
                                " adjustedScrolloff accounts for very large numbers of scrolloff.
                                let adjustedScrolloff = min([&scrolloff, (line('w$') - line('w0')) / 2])
                                let bottom_viewable = min([line('$'), c_lnum + &lines - adjustedScrolloff - 2])
                                let top_viewable = max([1, c_lnum-&lines+adjustedScrolloff + 2])
                                " one of these stoplines will be adjusted below, but the current values are
                                " minimal boundaries within the current window
                                if i % 2 == 0
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = min([line2byte("$"), line2byte(".") + col(".") + &smc * 2])
                            	let stopline = min([bottom_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = min([bottom_viewable, c_lnum + 100])
                                  endif
                                  let stoplinebottom = stopline
                                else
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = max([1, line2byte(".") + col(".") - &smc * 2])
                            	let stopline = max([top_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = max([top_viewable, c_lnum - 100])
                                  endif
                                  let stoplinetop = stopline
                                endif
                                let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline)
                              endtry
                            
                              if before > 0
                                if has_getcurpos
                                  call setpos('.', save_cursor)
                                else
                                  call winrestview(save_cursor)
                                endif
                              endif
                            
                              " If a match is found setup match highlighting.
                              if m_lnum > 0 && m_lnum >= stoplinetop && m_lnum <= stoplinebottom 
                                if s:has_matchaddpos
                                  call add(w:matchparen_ids, matchaddpos('MatchParen', [[c_lnum, c_col - before], [m_lnum, m_col]], 10))
                                else
                                  exe '3match MatchParen /\(\%' . c_lnum . 'l\%' . (c_col - before) . 'c\)\|\(\%' . m_lnum . 'l\%' . m_col . 'c\)/'
                                  call add(w:matchparen_ids, 3)
                                endif
                                let w:paren_hl_on = 1
                              endif

FUNCTION  wilder#renderer#redraw()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer.vim:1
Called 3 times
Total time:   0.007791
 Self time:   0.000017

count  total (s)   self (s)
    3   0.007790   0.000016   call s:redraw(a:apply_incsearch_fix, 0)

FUNCTION  <SNR>55_make_page()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer/popupmenu.vim:195
Called 5 times
Total time:   0.000172
 Self time:   0.000137

count  total (s)   self (s)
    5              0.000006   if empty(a:result.value)
    1              0.000001     return [-1, -1]
    4              0.000001   endif
                            
    4              0.000003   let l:page = a:state.page
    4              0.000003   let l:selected = a:ctx.selected
                              " Adjust -1 (unselected) to show the top of the list.
    4              0.000006   let l:selected = l:selected == -1 ? 0 : l:selected
                            
                              " Adjust previous page.
    4              0.000005   if l:page != [-1, -1]
    2              0.000003     if l:page[0] > len(a:result.value)
                                  let l:page = [-1, -1]
    2              0.000003     elseif l:page[1] > len(a:result.value)
                                  let l:page[1] = len(a:result.value) - 1
    2              0.000001     endif
    4              0.000001   endif
                            
    4              0.000003   if l:page != [-1, -1]
                                " Selected is within current page, reuse the page.
    2              0.000004     if l:selected != -1 && l:selected >= l:page[0] && l:selected <= l:page[1]
    2              0.000001       return l:page
                                endif
                            
                                " Scroll the page forward.
                                if a:ctx.direction >= 0 && l:page[1] < l:selected
                                  " calculate distance moved.
                                  let l:moved = l:selected - l:page[1]
                                  return [l:page[0] + l:moved, l:selected]
                                endif
                            
                                " Scroll the page backward.
                                if a:ctx.direction < 0 && l:page[0] > l:selected
                                  " calculate distance moved.
                                  let l:moved = l:page[0] - l:selected
                                  return [l:selected, l:page[1] - l:moved]
                                endif
    2              0.000000   endif
                            
                              " Otherwise make a new page.
                            
    2   0.000033   0.000008   let l:max_height = a:state.get_max_height(a:ctx, a:result)
    2   0.000015   0.000006   let l:min_height = a:state.get_min_height(a:ctx, a:result)
    2              0.000002   if l:max_height < l:min_height
                                let l:max_height = l:min_height
    2              0.000000   endif
    2              0.000003   let l:max_height -= len(a:state.top)
    2              0.000003   let l:max_height -= len(a:state.bottom)
                              " Assume the worst case scenario that the cursor is on the top row of the
                              " cmdline.
    2              0.000005   let l:max_height = min([l:max_height, &lines - &cmdheight - 1])
                            
                              " Page starts at selected.
    2              0.000001   if a:ctx.direction >= 0
    2              0.000002     let l:start = l:selected
                            
                                " Try to include all candidates after selected.
    2              0.000003     let l:height = len(a:result.value) - l:selected
                            
    2              0.000002     if l:height > l:max_height
    1              0.000001       let l:height = l:max_height
    2              0.000001     endif
                            
    2              0.000003     return [l:start, l:start + l:height - 1]
                              endif
                            
                              " Page ends at selected.
                              let l:end = l:selected
                            
                              " Try to include all candidates before selected.
                              let l:height = l:selected
                            
                              if l:height > l:max_height
                                let l:height = l:max_height
                              endif
                            
                              return [l:end - l:height + 1, l:end]

FUNCTION  wilder#main#in_mode()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/main.vim:53
Called 7 times
Total time:   0.000047
 Self time:   0.000047

count  total (s)   self (s)
    7              0.000042   return mode(1) ==# 'c' && index(s:opts.modes, getcmdtype()) >= 0

FUNCTION  <SNR>58_set_line()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer/nvim_api.vim:247
Called 65 times
Total time:   0.000763
 Self time:   0.000763

count  total (s)   self (s)
   65              0.000750   call nvim_buf_set_lines(self.state.buf, a:line, a:line, v:true, [a:str])

FUNCTION  wilder#pipeline#run()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/pipeline.vim:87
Called 14 times
Total time:   0.007922
 Self time:   0.000059

count  total (s)   self (s)
   14              0.000031   let l:pipeline = type(a:pipeline) isnot v:t_list ? [a:pipeline] : a:pipeline
                            
   14   0.005845   0.000423   return s:run(l:pipeline, a:on_finish, a:on_error, a:ctx, a:x, 0)

FUNCTION  wilder#renderer#call_component_post_hook()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer.vim:81
Called 12 times
Total time:   0.000075
 Self time:   0.000053

count  total (s)   self (s)
   12              0.000020   if type(a:component) is v:t_dict && has_key(a:component, 'post_hook')
    1   0.000040   0.000018     call a:component['post_hook'](a:ctx)
   12              0.000003   endif

FUNCTION  <lambda>82()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer/popupmenu.vim:113
Called 1 time
Total time:   0.000272
 Self time:   0.000006

count  total (s)   self (s)
                            return s:post_hook(l:state, ctx)

FUNCTION  wilder#highlight#get_hl_nvim()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/highlight.vim:237
Called 2 times
Total time:   0.000021
 Self time:   0.000021

count  total (s)   self (s)
    2              0.000001   try
    2              0.000007     let l:cterm_hl = nvim_get_hl_by_name(a:group, 0)
    2              0.000004     let l:gui_hl = nvim_get_hl_by_name(a:group, 1)
                            
    2              0.000003     return [{}, l:cterm_hl, l:gui_hl]
                              catch
                                return [{}, {}, {}]
    2              0.000001   endtry

FUNCTION  wilder#pipeline#resolve()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/pipeline.vim:12
Called 10 times
Total time:   0.011903
 Self time:   0.000047

count  total (s)   self (s)
   10   0.011900   0.000044   call s:handle(a:ctx, a:x, 'resolve')

FUNCTION  <SNR>50_scrollbar()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer/component/popupmenu_scrollbar.vim:17
Called 3 times
Total time:   0.000083
 Self time:   0.000083

count  total (s)   self (s)
    3              0.000004   let [l:start, l:end] = a:ctx.page
    3              0.000004   let l:num_candidates = len(a:result.value)
    3              0.000002   let l:height = a:ctx.height
                            
    3              0.000003   if l:num_candidates <= l:height
    1              0.000001     if a:state.collapse
    1              0.000000       return []
                                else
                                  return repeat([[a:state.scrollbar_chunk]], l:height)
                                endif
    2              0.000000   endif
                            
    2              0.000007   let l:thumb_start = float2nr(1.0 * l:start * l:height / l:num_candidates)
    2              0.000004   let l:thumb_size = float2nr(1.0 * l:height * l:height / l:num_candidates) + 1
    2              0.000003   let l:thumb_end = l:thumb_start + l:thumb_size
                            
                              " Due to floating point rounding, thumb can exceed height.
                              " Adjust the thumb back 1 row so that visually the thumb size remains fixed.
                              " The position of the thumb will be wrong but the fixed thumb size is more
                              " important.
    2              0.000002   if l:thumb_end > l:height
                                let l:thumb_start -= 1
                                let l:thumb_end -= 1
    2              0.000000   endif
                            
                              " Adjust case where rounding causes l:thumb_size to equal l:height.
    2              0.000002   if l:thumb_size == l:height
                                let l:thumb_size -= 1
                            
                                if l:end < l:num_candidates - 1
                                  let l:thumb_end -= 1
                                else
                                  let l:thumb_start += 1
                                endif
    2              0.000000   endif
                            
    2              0.000002   let l:thumb_chunk = a:state.thumb_chunk
    2              0.000002   let l:scrollbar_chunk = a:state.scrollbar_chunk
                            
    2              0.000005   let l:before_thumb_chunks = repeat([[l:scrollbar_chunk]], l:thumb_start)
    2              0.000004   let l:thumb_chunks = repeat([[l:thumb_chunk]], l:thumb_size)
    2              0.000005   let l:after_thumb_chunks = repeat([[l:scrollbar_chunk]], l:height - l:thumb_end)
                            
    2              0.000005   return l:before_thumb_chunks + l:thumb_chunks + l:after_thumb_chunks

FUNCTION  wilder#render#to_printable()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/render.vim:98
Called 53 times
Total time:   0.000310
 Self time:   0.000310

count  total (s)   self (s)
   53              0.000038   if !s:has_strtrans_issue
                                " check if first character is a combining character
   53              0.000112     if strdisplaywidth(' ' . a:x) == strdisplaywidth(a:x)
                                  return strtrans(' ' . a:x)
   53              0.000016     endif
                            
   53              0.000062     return strtrans(a:x)
                              endif
                            
                              let l:transformed = strtrans(a:x)
                              " strtrans is ok
                              if strdisplaywidth(a:x) == strdisplaywidth(l:transformed)
                                " check if first character is a combining character
                                if strdisplaywidth(' ' . a:x) == strdisplaywidth(a:x)
                                  return strtrans(' ' . a:x)
                                endif
                            
                                return strtrans(a:x)
                              endif
                            
                              let l:res = ''
                              let l:first = 1
                            
                              for l:char in split(a:x, '\zs')
                                let l:transformed_char = strtrans(l:char)
                            
                                let l:transformed_width = strdisplaywidth(l:transformed_char)
                                let l:width = strdisplaywidth(l:char)
                            
                                if l:transformed_width == l:width
                                  " strtrans is ok
                                  let l:res .= l:transformed_char
                                elseif l:transformed_width == 0
                                  " strtrans returns empty character, use original char
                                  if l:first && strdisplaywidth(' ' . l:char) == strdisplaywidth(l:char)
                                    " check if first character is combining character
                                    let l:res .= ' ' . l:char
                                  else
                                    let l:res .= l:char
                                  endif
                                else
                                  " fallback to hex representation
                                  let l:res .= '<' . printf('%02x', char2nr(l:char)) . '>'
                                endif
                            
                                let l:first = 0
                              endfor
                            
                              return l:res

FUNCTION  <SNR>109_draw()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/main.vim:429
Called 5 times
Total time:   0.002305
 Self time:   0.000642

count  total (s)   self (s)
    5              0.000003   if s:hidden
                                return
    5              0.000001   endif
                            
    5              0.000002   try
    5              0.000007       let l:direction = a:0 >= 1 ? a:1 : 0
                            
    5              0.000013       if s:selected == -1 && !s:opts.noselect && !s:selection_was_made && !empty(s:result.value)
                                    let l:selected = 0
    5              0.000002       else
    5              0.000005         let l:selected = s:selected
    5              0.000002       endif
                            
    5              0.000030       let l:ctx = { 'clear_previous': get(s:, 'clear_previous_renderer_state', 0), 'selected': l:selected, 'direction': l:direction, 'run_id': s:result_run_id, 'done': s:run_id == s:result_run_id, 'session_id': s:result_session_id, }
    5              0.000005       let s:clear_previous_renderer_state = 0
                            
    5              0.000006       let l:has_error = s:error isnot v:null
                            
    5              0.000003       if l:has_error
                                    let l:ctx.error = s:error
                                    let l:value = {'value': []}
    5              0.000001       else
    5              0.000005         let l:value = s:result
    5              0.000001       endif
                            
    5   0.002161   0.000499       call s:opts.renderer.render(l:ctx, l:value)
                              catch
                                echohl ErrorMsg
                                echomsg 'wilder: draw: ' . v:exception
                                echohl Normal
    5              0.000004   finally
    5              0.000004     let s:draw_done = 1
    5              0.000003   endtry

FUNCTION  <SNR>55_post_hook()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer/popupmenu.vim:698
Called 1 time
Total time:   0.000266
 Self time:   0.000142

count  total (s)   self (s)
    1   0.000053   0.000004   call a:state.api.hide()
                            
   13              0.000019   for l:Component in [a:state.empty_message, a:state.error_message] + a:state.left + a:state.right + a:state.top + a:state.bottom
   12   0.000139   0.000064     call wilder#renderer#call_component_post_hook(a:ctx, l:Component)
   13              0.000047   endfor
                            
    1              0.000002   call timer_stop(a:state.empty_message_first_draw_timer)
                            
    1              0.000001   let a:state.active = 0

FUNCTION  <SNR>55_draw_candidates_chunks()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer/popupmenu.vim:615
Called 53 times
Total time:   0.002487
 Self time:   0.000534

count  total (s)   self (s)
   53              0.000055   let l:is_selected = a:ctx.selected == a:i
                            
   53   0.002261   0.000308   let l:str = s:draw_candidate(a:state, a:ctx, a:result, a:i)
                            
   53              0.000052   let l:Highlighter = a:state.highlighter
                            
   53              0.000034   if l:Highlighter is 0
   53              0.000035     return [[l:str]]
                              endif
                            
                              if !l:is_selected && a:state.highlight_cache.has_key(l:str)
                                return copy(a:state.highlight_cache.get(l:str))
                              endif
                            
                              let l:data = get(a:result, 'data', {})
                              let l:spans = l:Highlighter(a:ctx, l:str, l:data)
                            
                              if l:spans is 0
                                return [[l:str]]
                              endif
                            
                              if a:state.highlight_mode ==# 'basic'
                                let l:spans = s:merge_spans(l:spans)
                              endif
                            
                              let l:chunks = wilder#render#spans_to_chunks( l:str, l:spans, l:is_selected, a:ctx.highlights)
                            
                              if !l:is_selected
                                call a:state.highlight_cache.set(l:str, l:chunks)
                                let l:chunks = copy(l:chunks)
                              endif
                            
                              return l:chunks

FUNCTION  <SNR>64_resolve()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/pipe/branch.vim:48
Called 6 times
Total time:   0.000061
 Self time:   0.000041

count  total (s)   self (s)
    6              0.000010   let l:ctx = copy(a:ctx)
    6              0.000008   let l:ctx.handler_id = a:state.original_ctx.handler_id
                            
    6   0.000039   0.000019   call wilder#resolve(l:ctx, a:x)

FUNCTION  copilot#OnVimLeavePre()
    Defined: ~/.local/share/nvim/lazy/copilot.vim/autoload/copilot.vim:487
Called 1 time
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)

FUNCTION  <SNR>49_mru_set()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/cache.vim:45
Called 2 times
Total time:   0.000061
 Self time:   0.000028

count  total (s)   self (s)
    2              0.000004   let self['_cache'][a:key] = a:value
                            
    2   0.000056   0.000023   call self.mru_update(a:key)

FUNCTION  wilder#main#on_finish()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/main.vim:315
Called 2 times
Total time:   0.001045
 Self time:   0.000091

count  total (s)   self (s)
    2              0.000003   if !s:active || !s:enabled
                                return
    2              0.000000   endif
                            
    2              0.000002   if a:ctx.run_id != s:run_id
                                return
    2              0.000000   endif
                            
    2              0.000002   let s:result_run_id = a:ctx.run_id
    2              0.000002   let s:result_session_id = a:ctx.session_id
                            
    2              0.000004   let l:result = (a:x is v:false || a:x is v:true) ? {'value': []} : a:x
    2              0.000002   if type(l:result) isnot v:t_dict
                                let s:result = {'value': l:result}
    2              0.000001   else
    2              0.000003     let s:result = l:result
    2              0.000001   endif
                            
    2              0.000002   if !has_key(s:result, 'data')
                                let s:result.data = {}
    2              0.000000   endif
                            
    2              0.000002   if !has_key(s:result.data, 'query')
                                let s:result.data.query = a:ctx.input
    2              0.000000   endif
                            
                              " When a new result arrives, the previous results are cleared. If there is a
                              " selection, treat the current cmdline as being replaced.
    2              0.000001   if s:selected >= 0
                                let s:replaced_cmdline = getcmdline()
    2              0.000000   endif
                            
    2              0.000002   let s:selected = -1
    2              0.000002   let s:selection_was_made = 0
    2              0.000002   let s:clear_previous_renderer_state = 1
                              " keep previous completion
                            
    2              0.000002   let s:error = v:null
                            
    2              0.000001   if a:x is v:true
                                if !s:hidden
                                  let s:hidden = 1
                            
                                  call s:post_hook()
                                endif
                            
                                return
    2              0.000000   endif
                            
    2              0.000001   if s:hidden
                                let s:hidden = 0
                            
                                call s:pre_hook()
    2              0.000000   endif
                            
    2              0.000001   if s:select_next
                                call wilder#main#next()
                            
                                let s:select_next = 0
                                return
    2              0.000000   endif
                            
    2              0.000004   if !empty(s:completion_stack) && get(a:ctx, 'auto_select', 0)
                                " removing previous_cmdline causes this to be treated as a new input
                                let s:previous_cmdline = v:null
                            
                                call wilder#main#next()
                                return
    2              0.000000   endif
                            
    2   0.000961   0.000008   call s:draw()

FUNCTION  <SNR>55_draw_top_or_bottom_line()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer/popupmenu.vim:795
Called 12 times
Total time:   0.004589
 Self time:   0.001863

count  total (s)   self (s)
   12              0.000011   let l:width = a:ctx.width
                            
   12              0.000013   let l:Line = a:line
   12              0.000013   if type(l:Line) is v:t_dict
    3              0.000004     let l:Line = l:Line.value
   12              0.000003   endif
                            
   12              0.000012   if type(l:Line) is v:t_func
   12   0.004436   0.001711     let l:Line = l:Line(a:ctx, a:result)
   12              0.000005   endif
                            
   12              0.000013   if type(l:Line) is v:t_string
                                if empty(l:Line)
                                  return l:Line
                                endif
                            
                                let l:Line = [[wilder#render#truncate_and_pad(a:ctx.width, l:Line)]]
   12              0.000003   endif
                            
   12              0.000007   return l:Line

FUNCTION  wilder#transform#vim_fuzzy_filt()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/transform.vim:99
Called 2 times
Total time:   0.000014
 Self time:   0.000014

count  total (s)   self (s)
    2              0.000002   if empty(a:query)
    1              0.000001     return a:candidates
    1              0.000000   endif
                            
    1              0.000002   if exists('*matchfuzzy')
    1              0.000007     return matchfuzzy(a:candidates, a:query)
                              endif
                            
                              return s:vim_fuzzy_filt(a:ctx, a:candidates, a:query)

FUNCTION  wilder#uniq_filt()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder.vim:382
Called 1 time
Total time:   0.000028
 Self time:   0.000007

count  total (s)   self (s)
    1   0.000028   0.000006   return call('wilder#transform#uniq_filt', a:000)

FUNCTION  <SNR>57_get_attrs_as_list()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/highlight.vim:209
Called 12 times
Total time:   0.000632
 Self time:   0.000632

count  total (s)   self (s)
   12              0.000007   let l:res = []
                            
  108              0.000050   for l:attr in s:attr_list
   96              0.000086     if has_key(a:attrs, l:attr)
    9              0.000006       if l:attr ==# 'inverse'
                                    let l:attr = 'reverse'
    9              0.000002       endif
                            
    9              0.000007       if a:attrs[l:attr]
    9              0.000010         call add(l:res, l:attr)
                                  else
                                    call add(l:res, 'no' . l:attr)
    9              0.000003       endif
   96              0.000021     endif
  108              0.000042   endfor
                            
   12              0.000006   return l:res

FUNCTION  <SNR>57_make_hl_from_list()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/highlight.vim:158
Called 2 times
Total time:   0.000357
 Self time:   0.000119

count  total (s)   self (s)
    2   0.000088   0.000010   let l:term_hl = s:normalise_attrs(a:args[0])
    2   0.000088   0.000009   let l:cterm_hl = s:normalise_attrs(a:args[1])
    2   0.000089   0.000009   let l:gui_hl = s:normalise_attrs(a:args[2])
                            
    2              0.000003   let l:cmd = 'hi! ' . a:name . ' '
                            
    2              0.000002   let l:term_attr = l:term_hl[2:]
    2              0.000002   if len(l:term_hl) >= 2
                                let l:cmd .= 'term=' . join(l:term_attr, ',') . ' '
    2              0.000001   endif
                            
    2              0.000002   let l:cterm_attr = l:cterm_hl[2:]
    2              0.000002   if !empty(l:cterm_attr)
    2              0.000006     let l:cmd .= 'cterm=' . join(l:cterm_attr, ',') . ' '
    2              0.000001   endif
                            
    2              0.000002   if len(l:cterm_hl) >= 1
    2              0.000002     if l:cterm_hl[0] >= 0
    2              0.000004       let l:cmd .= 'ctermfg=' . l:cterm_hl[0] . ' '
    2              0.000001     endif
                            
    2              0.000003     if len(l:cterm_hl) >= 2 && l:cterm_hl[1] >= 0
    2              0.000003       let l:cmd .= 'ctermbg=' . l:cterm_hl[1] . ' '
    2              0.000000     endif
    2              0.000000   endif
                            
    2              0.000002   let l:gui_attr = l:gui_hl[2:]
    2              0.000002   if !empty(l:gui_attr)
    2              0.000005     let l:cmd .= 'gui=' . join(l:gui_attr, ',') . ' '
    2              0.000000   endif
                            
    2              0.000002   if len(l:gui_hl) >= 1
    2              0.000003     if type(l:gui_hl[0]) == v:t_number
    1              0.000004       let l:cmd .= 'guifg=' . printf('#%06x', l:gui_hl[0]) . ' '
    1              0.000000     else
    1              0.000002       let l:cmd .= 'guifg=' . l:gui_hl[0] . ' '
    2              0.000001     endif
                            
    2              0.000002     if len(l:gui_hl) >= 2
    2              0.000002       if type(l:gui_hl[1]) == v:t_number
    1              0.000003         let l:cmd .= 'guibg=' . printf('#%06x', l:gui_hl[1]) . ' '
    1              0.000000       else
    1              0.000002         let l:cmd .= 'guibg=' . l:gui_hl[1] . ' '
    2              0.000001       endif
    2              0.000000     endif
    2              0.000000   endif
                            
    2              0.000012   exe l:cmd

FUNCTION  <SNR>58_show()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer/nvim_api.vim:67
Called 3 times
Total time:   0.031286
 Self time:   0.000019

count  total (s)   self (s)
    3              0.000006   if self.state.win != -1 || self.state.window_state !=# 'hidden'
    2              0.000001     return
    1              0.000000   endif
                            
    1              0.000001   let self.state.window_state = 'pending'
                            
    1              0.000001   try
    1   0.031271   0.000005     call self._open_win()
                              catch
                                call timer_start(0, {-> self._open_win()})
    1              0.000000   endtry

FUNCTION  wilder#pipeline#clear_handlers()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/pipeline.vim:6
Called 1 time
Total time:   0.000005
 Self time:   0.000005

count  total (s)   self (s)
    1              0.000001   let s:last_cleared_id = s:id_index
    1              0.000001   let s:handler_registry = {}
    1              0.000001   let s:partial_results = {}

FUNCTION  <SNR>55_pre_hook()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer/popupmenu.vim:682
Called 1 time
Total time:   0.001748
 Self time:   0.000272

count  total (s)   self (s)
    1   0.000589   0.000008   call a:state.api.new({ 'normal_highlight': a:state.highlights.default, 'zindex': get(a:state, 'zindex', 0), 'pumblend': get(a:state, 'pumblend', -1) })
                            
   13              0.000019   for l:Component in [a:state.empty_message, a:state.error_message] + a:state.left + a:state.right + a:state.top + a:state.bottom
   12   0.001115   0.000220     call wilder#renderer#call_component_pre_hook(a:ctx, l:Component)
   13              0.000018   endfor
                            
    1              0.000001   let a:state.active = 1
    1              0.000001   let a:state.is_first_draw = 1

FUNCTION  <SNR>63_result()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/pipe/result.vim:23
Called 6 times
Total time:   0.000432
 Self time:   0.000340

count  total (s)   self (s)
    6              0.000004   if empty(a:kvs)
                                return a:result
    6              0.000002   endif
                            
    6              0.000005   let l:kvs = a:kvs
                            
   14              0.000012   while !empty(l:kvs)
    8              0.000008     let l:kv = l:kvs[0]
    8              0.000008     let l:kvs = l:kvs[1:]
    8              0.000006     let l:key = l:kv.key
    8              0.000008     let l:Value = l:kv.value
                            
    8              0.000008     if type(l:Value) is v:t_func
    6   0.000140   0.000047       let l:R = l:Value(a:ctx, get(a:result, l:key, v:null), get(a:result, 'data', {}))
                            
    6              0.000006       if type(l:R) is v:t_func
                                    return wilder#wait(l:R, {ctx, value -> wilder#resolve(ctx, s:result(l:kvs, ctx, s:add_key(a:result, l:key, value)))})
    6              0.000002       endif
                            
    6              0.000008       let a:result[l:key] = l:R
    2              0.000002     elseif type(l:Value) is v:t_list
    2              0.000005       let a:result[l:key] = get(a:result, l:key, []) + l:Value
                                elseif type(l:Value) is v:t_dict
                                  let a:result[l:key] = extend(get(a:result, l:key, {}), l:Value)
                                else
                                  let a:result[l:key] = l:Value
    8              0.000005     endif
   14              0.000009   endwhile
                            
    6              0.000004   return a:result

FUNCTION  <SNR>59_prepare_fuzzy_completion()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/cmdline.vim:46
Called 2 times
Total time:   0.000034
 Self time:   0.000034

count  total (s)   self (s)
                              " For non-python completion, a maximum of 300 help tags are returned, so
                              " getting all the candidates and filtering will miss out on a lot of matches
                              " If argument is empty, don't fuzzy match except for expanding 'help', where
                              " the default argument is 'help'
    2              0.000004   if (a:res.expand ==# 'help' && !a:use_python) || a:res.pos == len(a:res.cmdline)
    1              0.000001     return a:res
    1              0.000000   endif
                            
                              " Remove the starting s: and g: so the fuzzy filter does not match against
                              " that them.
    1              0.000003   if (a:res.expand ==# 'expression' || a:res.expand ==# 'var') && a:res.expand_arg[1] ==# ':' && (a:res.expand_arg[0] ==# 'g' || a:res.expand_arg[0] ==# 's')
                                let a:res.fuzzy_char = a:res.expand_arg[2]
                                let a:res.match_arg = a:res.expand_arg[2 :]
                                let a:res.expand_arg = a:res.expand_arg[0: 1]
                            
                              " For tag-regexp, keep the argument and don't do fuzzy matching
    1              0.000001   elseif a:res.expand ==# 'tags' && a:res.expand_arg[0] ==# '/'
                                let a:res.fuzzy_char = ''
                                let a:res.match_arg = ''
                            
                              " Return all candidates and let the fuzzy filter remove the non-matching
                              " candidates for the following cases:
                              "
                              " mapping: special keys such as <Space> cannot be fuzzy completed since
                              " < will not get completions for <Space>.
                              "
                              " buffer: getcompletion() for buffers checks against the file name, but
                              " we want to check against the full path.
                              "
                              " help: help tag matching does not have to start from beginning of word.
    1              0.000002   elseif a:res.expand ==# 'mapping' || a:res.expand ==# 'buffer' || a:res.expand ==# 'help'
                                " Default argument for help completion is 'help'
                                if a:res.expand ==# 'help' && empty(a:res.expand_arg)
                                  let a:res.match_arg = 'help'
                                else
                                  let a:res.match_arg = a:res.expand_arg
                                endif
                            
                                let a:res.expand_arg = ''
                                let a:res.fuzzy_char = ''
    1              0.000000   else
                                " Default case, expand with the fuzzy_char
    1              0.000003     let a:res.fuzzy_char = strcharpart(a:res.expand_arg, 0, 1)
    1              0.000001     let a:res.expand_arg = ''
    1              0.000000   endif
                            
    1              0.000001   return a:res

FUNCTION  <SNR>111_prepare_call()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/pipeline.vim:105
Called 8 times
Total time:   0.000116
 Self time:   0.000116

count  total (s)   self (s)
    8              0.000044   let l:handler = { 'on_finish': {ctx, x -> s:run(a:pipeline, a:on_finish, a:on_error, ctx, x, a:i)}, 'on_error': {ctx, x -> a:on_error(ctx, x)}, }
                            
    8              0.000008   let s:id_index += 1
    8              0.000009   let l:handler_id = s:id_index
    8              0.000014   let s:handler_registry[s:id_index] = l:handler
                            
    8              0.000031   call timer_start(0, {_ -> s:call(a:f, a:ctx, l:handler_id)})

FUNCTION  <SNR>53_make_top_or_bottom_border()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer/popupmenu_border_theme.vim:155
Called 9 times
Total time:   0.000391
 Self time:   0.000391

count  total (s)   self (s)
    9              0.000019   let l:left = a:is_top ? a:border_chars[0] : a:border_chars[5]
    9              0.000014   let l:middle = a:is_top ? a:border_chars[1] : a:border_chars[6]
    9              0.000012   let l:right = a:is_top ? a:border_chars[2] : a:border_chars[7]
                            
    9              0.000015   let l:left_width = strdisplaywidth(l:left)
    9              0.000013   let l:middle_width = strdisplaywidth(l:middle)
    9              0.000011   let l:right_width = strdisplaywidth(l:right)
                            
    9              0.000017   let l:expected_middle_width = a:ctx.width - l:left_width - l:right_width
    9              0.000015   let l:middle_repeat =  l:expected_middle_width / l:middle_width
    9              0.000007   if l:middle_repeat < 0
                                let l:middle_repeat = 0
    9              0.000003   endif
                            
    9              0.000023   let l:middle_str = repeat(l:middle, l:middle_repeat)
    9              0.000057   let l:actual_middle_width = strdisplaywidth(l:middle_str)
    9              0.000010   if l:actual_middle_width < l:expected_middle_width
                                let l:middle_chars = split(l:middle, '\zs')
                            
                                let l:i = 0
                                for l:char in l:middle_chars
                                  let l:new_middle_width = l:actual_middle_width + strdisplaywidth(l:char)
                            
                                  if l:new_middle_width > l:expected_middle_width
                                    break
                                  endif
                            
                                  let l:middle_str .= l:char
                                  let l:actual_middle_width = l:new_middle_width
                                endfor
                            
                                let l:middle_str .= repeat(' ', l:expected_middle_width - l:actual_middle_width)
    9              0.000002   endif
                            
    9              0.000010   let l:border_hl = a:ctx.highlights.border
    9              0.000016   let l:middle_hl = a:is_top ? l:border_hl : a:ctx.highlights.bottom_border
                            
    9              0.000023   return [[l:left, l:border_hl], [l:middle_str, l:middle_hl], [l:right, l:border_hl]]

FUNCTION  <SNR>49_has_key()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/cache.vim:19
Called 2 times
Total time:   0.000005
 Self time:   0.000005

count  total (s)   self (s)
    2              0.000004   return has_key(self['_cache'], a:key)

FUNCTION  <SNR>111_wait_start()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/pipeline.vim:175
Called 4 times
Total time:   0.000318
 Self time:   0.000060

count  total (s)   self (s)
    4              0.000005   let a:state.wait_handler_id = a:ctx.handler_id
                            
    4              0.000021   let a:state.handler = { 'on_finish': {ctx, x -> s:wait_on_finish(a:state, ctx, x)}, 'on_error': {ctx, x -> s:wait_on_error(a:state, ctx, x)}, }
                            
    4   0.000287   0.000030   call s:wait_call(a:state, a:ctx)

FUNCTION  <SNR>109_run_pipeline()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/main.vim:293
Called 2 times
Total time:   0.000706
 Self time:   0.000161

count  total (s)   self (s)
    2              0.000003   let s:run_id += 1
                            
    2              0.000006   let l:ctx = { 'input': a:input, 'run_id': s:run_id, 'session_id': s:session_id, }
                            
    2              0.000002   if a:0 > 0
                                call extend(l:ctx, a:1)
    2              0.000001   endif
                            
    2   0.000690   0.000145   call wilder#pipeline#run( s:opts.pipeline, function('wilder#main#on_finish'), function('wilder#main#on_error'), l:ctx, a:input, )

FUNCTION  <SNR>109_pre_hook()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/main.vim:224
Called 1 time
Total time:   0.003117
 Self time:   0.000022

count  total (s)   self (s)
    1   0.001334   0.000005   call wilder#highlight#init_hl()
                            
    1              0.000001   if has_key(s:opts, 'pre_hook')
                                call s:opts.pre_hook({})
    1              0.000000   endif
                            
    1              0.000002   if has_key(s:opts.renderer, 'pre_hook')
    1   0.001777   0.000012     call s:opts.renderer.pre_hook({})
    1              0.000000   endif

FUNCTION  <SNR>111_wait_call()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/pipeline.vim:186
Called 5 times
Total time:   0.000275
 Self time:   0.000101

count  total (s)   self (s)
    5              0.000002   try
    5              0.000007     if type(a:state.f) is v:t_func
    2              0.000004       let l:ctx = copy(a:ctx)
                            
    2              0.000002       let s:id_index += 1
    2              0.000002       let l:id_index = s:id_index
    2              0.000004       let s:handler_registry[s:id_index] = a:state.handler
                            
    2              0.000007       call timer_start(0, {_ -> s:call(a:state.f, l:ctx, l:id_index)})
    3              0.000001     else
    3              0.000003       let a:ctx.handler_id = a:state.wait_handler_id
    3   0.000198   0.000024       call a:state.on_finish(a:ctx, a:state.f)
    5              0.000002     endif
                              catch
                                let a:ctx.handler_id = a:state.wait_handler_id
                                call s:wait_on_error(a:state, a:ctx, v:exception)
    5              0.000002   endtry

FUNCTION  wilder#lua#wrap()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/lua.vim:9
Called 2272 times
Total time:   0.036299
 Self time:   0.031809

count  total (s)   self (s)
 2272              0.004422   if type(a:t) is v:t_string || type(a:t) is v:t_number || type(a:t) is v:t_bool || a:t is v:null
 1975              0.000899     return a:t
  297              0.000076   endif
                            
  297              0.000230   if type(a:t) is v:t_func
    4   0.000048   0.000017     return s:wrap_function(a:t)
  293              0.000071   endif
                            
  293              0.000226   if type(a:t) is v:t_dict
   94              0.000060     for l:key in keys(a:t)
   80              0.000077       let l:Value = a:t[l:key]
   80              0.000087       let a:t[l:key] = wilder#lua#wrap(l:Value)
   94              0.000027     endfor
  293              0.000070   endif
                            
                              " v:t_list
  293              0.001424   return map(a:t, {_, x -> wilder#lua#wrap(x)})

FUNCTION  <SNR>55_draw_candidate()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer/popupmenu.vim:656
Called 53 times
Total time:   0.001953
 Self time:   0.000656

count  total (s)   self (s)
   53              0.000054   let l:use_cache = a:ctx.selected == a:i
   53              0.000068   if l:use_cache && a:state.draw_cache.has_key(a:i)
                                return a:state.draw_cache.get(a:i)
   53              0.000014   endif
                            
   53   0.001594   0.000297   let l:x = wilder#render#draw_candidate(a:ctx, a:result, a:i)
                            
   53              0.000025   if l:use_cache
                                call a:state.draw_cache.set(a:i, l:x)
   53              0.000013   endif
                            
   53              0.000026   return l:x

FUNCTION  wilder#renderer#call_component_pre_hook()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer.vim:74
Called 12 times
Total time:   0.000084
 Self time:   0.000047

count  total (s)   self (s)
   12              0.000022   if type(a:component) is v:t_dict && has_key(a:component, 'pre_hook')
    1   0.000045   0.000009     call a:component['pre_hook'](a:ctx)
   12              0.000004   endif

FUNCTION  <SNR>59_set_query()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/cmdline.vim:1473
Called 2 times
Total time:   0.000018
 Self time:   0.000018

count  total (s)   self (s)
    2              0.000003   let l:data = a:data is v:null ? {} : a:data
    2              0.000003   let l:match_arg = get(l:data, 'cmdline.match_arg', '')
                            
    2              0.000010   return extend(l:data, {'query': l:match_arg})

FUNCTION  <SNR>96_SynSet()
    Defined: /opt/homebrew/Cellar/neovim/0.10.1/share/nvim/runtime/syntax/synload.vim:27
Called 4 times
Total time:   0.008650
 Self time:   0.008650

count  total (s)   self (s)
                              " clear syntax for :set syntax=OFF  and any syntax name that doesn't exist
    4              0.000006   syn clear
    4              0.000005   if exists("b:current_syntax")
                                unlet b:current_syntax
    4              0.000001   endif
                            
    4              0.000007   0verbose let s = expand("<amatch>")
    4              0.000003   if s == "ON"
                                " :set syntax=ON
                                if &filetype == ""
                                  echohl ErrorMsg
                                  echo "filetype unknown"
                                  echohl None
                                endif
                                let s = &filetype
    4              0.000003   elseif s == "OFF"
                                let s = ""
    4              0.000001   endif
                            
    4              0.000002   if s != ""
                                " Load the syntax file(s).  When there are several, separated by dots,
                                " load each in sequence.  Skip empty entries.
    8              0.000012     for name in split(s, '\.')
    4              0.000004       if !empty(name)
                                    " XXX: "[.]" in the first pattern makes it a wildcard on Windows
    4              0.008556         exe $'runtime! syntax/{name}[.]{{vim,lua}} syntax/{name}/*.{{vim,lua}}'
    4              0.000003       endif
    8              0.000004     endfor
    4              0.000001   endif

FUNCTION  <SNR>49_clear()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/cache.vim:23
Called 4 times
Total time:   0.000006
 Self time:   0.000006

count  total (s)   self (s)
    4              0.000006   let self['_cache'] = {}

FUNCTION  wilder#cmdline#prepare_getcompletion()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/cmdline.vim:20
Called 2 times
Total time:   0.000083
 Self time:   0.000049

count  total (s)   self (s)
    2              0.000003   let a:res.match_arg = a:res.arg
    2              0.000019   let a:res.expand_arg = has_key(a:res, 'subcommand_start') ? a:res.cmdline[a:res.subcommand_start :] : a:res.arg
                            
    2              0.000001   if !a:fuzzy
                                if a:res.expand ==# 'tags' && !empty(a:res.expand_arg) && a:res.expand_arg[0] !=# '/'
                                  " Search taglist for tags starting with expand_arg
                                  let a:res.expand_arg = '/^' . a:res.expand_arg
                                endif
                            
                                return a:res
    2              0.000000   endif
                            
    2   0.000047   0.000013   return s:prepare_fuzzy_completion(a:ctx, a:res, a:use_python)

FUNCTION  wilder#wait()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder.vim:55
Called 4 times
Total time:   0.000046
 Self time:   0.000027

count  total (s)   self (s)
    4              0.000003   if !a:0
                                return wilder#pipeline#wait(a:f)
    4              0.000002   elseif a:0 == 1
    4   0.000035   0.000016     return wilder#pipeline#wait(a:f, a:1)
                              else
                                return wilder#pipeline#wait(a:f, a:1, a:2)
                              endif

FUNCTION  wilder#renderer#pre_draw()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer.vim:52
Called 4 times
Total time:   0.000985
 Self time:   0.000288

count  total (s)   self (s)
    4              0.000004   let l:should_draw = 0
                            
   44              0.000029   for l:Component in a:components
   40   0.000867   0.000171     let l:should_draw += s:pre_draw(l:Component, a:ctx, a:result)
   44              0.000068   endfor
                            
    4              0.000003   return l:should_draw

FUNCTION  <SNR>58_new_buf()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer/nvim_api.vim:59
Called 2 times
Total time:   0.000558
 Self time:   0.000309

count  total (s)   self (s)
    2              0.000088   let l:buf = nvim_create_buf(v:false, v:true)
    2   0.000463   0.000214   call nvim_buf_set_name(l:buf, '[Wilder Float ' . s:index . ']')
    2              0.000004   let s:index += 1
                            
    2              0.000001   return l:buf

FUNCTION  wilder#options#get()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/options.vim:13
Called 1 time
Total time:   0.000017
 Self time:   0.000017

count  total (s)   self (s)
    1              0.000001   if !a:0
                                return s:opts
    1              0.000000   endif
                            
    1              0.000004   if a:1 ==# 'use_python_remote_plugin' && !has_key(s:opts, 'use_python_remote_plugin')
                                if !has('python3')
                                  let s:opts.use_python_remote_plugin = 0
                                elseif has('nvim')
                                  let s:opts.use_python_remote_plugin = 1
                                else
                                  let l:file = findfile('autoload/yarp.vim', &rtp)
                                  let s:opts.use_python_remote_plugin = !empty(l:file)
                                endif
    1              0.000000   endif
                            
    1              0.000001   return s:opts[a:1]

FUNCTION  <SNR>39_vm_persist()
    Defined: ~/.local/share/nvim/lazy/vim-visual-multi/plugin/visual-multi.vim:82
Called 1 time
Total time:   0.000009
 Self time:   0.000009

count  total (s)   self (s)
    1              0.000003   if exists('g:VM_PERSIST') && !g:VM_persistent_registers
                                unlet g:VM_PERSIST
    1              0.000001   elseif g:VM_persistent_registers
                                let g:VM_PERSIST = deepcopy(g:Vm.registers)
    1              0.000000   endif

FUNCTION  <SNR>55_clamp()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer/popupmenu.vim:818
Called 18 times
Total time:   0.000076
 Self time:   0.000076

count  total (s)   self (s)
   18              0.000013   if a:value < 1
    7              0.000003     return 1
   11              0.000003   endif
                            
   11              0.000017   let l:max = a:is_height ? (&lines - 1) : &columns
   11              0.000007   if a:value > l:max
                                return l:max
   11              0.000003   endif
                            
   11              0.000006   return a:value

FUNCTION  <SNR>111_wait_on_finish()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/pipeline.vim:206
Called 2 times
Total time:   0.000062
 Self time:   0.000019

count  total (s)   self (s)
    2              0.000002   if type(a:x) is v:t_func
    1              0.000001     let a:state.f = a:x
    1   0.000022   0.000004     call s:wait_call(a:state, a:ctx)
    1              0.000000     return
    1              0.000000   endif
                            
    1              0.000002   let l:ctx = copy(a:ctx)
    1              0.000001   let l:ctx.handler_id = a:state.wait_handler_id
                            
    1              0.000000   try
    1   0.000027   0.000003     call a:state.on_finish(l:ctx, a:x)
                              catch
                                call wilder#reject(l:ctx, v:exception)
    1              0.000000   endtry

FUNCTION  <SNR>59_getcompletion()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/cmdline.vim:777
Called 2 times
Total time:   0.000589
 Self time:   0.000082

count  total (s)   self (s)
                              " For python file completions, use wilder#cmdline#python_get_file_completion()
                              " For help tags, use _wilder_python_get_help_tags()
                              " Else use wilder#cmdline#getcompletion()
    2              0.000004   if a:use_python && wilder#cmdline#is_file_expansion(a:res.expand)
                                let l:Completion_func = funcref('wilder#cmdline#python_get_file_completion')
    2              0.000002   elseif a:use_python && a:res.expand ==# 'help' && a:fuzzy
                                let l:Completion_func = {-> {ctx -> _wilder_python_get_help_tags(ctx, &rtp, &helplang)}}
    2              0.000001   else
    2              0.000008     let l:Completion_func = funcref('wilder#cmdline#getcompletion')
    2              0.000001   endif
                            
                              " For tag-regexp, don't do fuzzy completion
                              " If fuzzy, wrap the completion func in wilder#cmdline#get_fuzzy_completion()
    2              0.000003   if a:res.expand ==# 'tags' && a:res.expand_arg[0] ==# '/'
                                let l:Getcompletion = l:Completion_func
    2              0.000001   elseif a:fuzzy
    2              0.000009     let l:Getcompletion = {ctx, x -> wilder#cmdline#get_fuzzy_completion( ctx, x, l:Completion_func, a:fuzzy, a:use_python)}
                              else
                                let l:Getcompletion = l:Completion_func
    2              0.000001   endif
                            
    2   0.000542   0.000035   return wilder#wait(l:Getcompletion(a:ctx, a:res), {ctx, xs -> wilder#resolve(ctx, { 'value': xs, 'pos': a:res.pos, 'data': s:convert_result_to_data(a:res), })})

FUNCTION  <SNR>51_get_cmdline_data()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer/popupmenu_palette_theme.vim:127
Called 3 times
Total time:   0.000046
 Self time:   0.000046

count  total (s)   self (s)
    3              0.000004   if a:state.cached_cmdline ==# a:cmdline
    2              0.000002     return a:state.cached_cmdline_data
    1              0.000000   endif
                            
    1              0.000006   let l:cmdline_chars = split(a:cmdline, '\zs')
    1              0.000001   let l:cmdline_data = []
                            
    1              0.000001   let l:byte_pos = 0
    1              0.000001   let l:displaywidth_pos = 0
                            
    1              0.000001   let l:i = 0
    2              0.000003   while l:i < len(l:cmdline_chars)
    1              0.000001     let l:char = l:cmdline_chars[l:i]
                            
                                " [char, byte_len, strdisplaywidth, byte_pos, displaywidth_pos]
    1              0.000001     let l:byte_len = len(l:char)
    1              0.000001     let l:displaywidth = strdisplaywidth(l:char)
    1              0.000002     let l:data = [l:char, l:byte_len, l:displaywidth, l:byte_pos, l:displaywidth_pos]
    1              0.000002     call add(l:cmdline_data, l:data)
                            
    1              0.000001     let l:byte_pos += l:byte_len
    1              0.000002     let l:displaywidth_pos += l:displaywidth
                            
    1              0.000001     let l:i += 1
    2              0.000001   endwhile
                            
    1              0.000001   let a:state.cached_cmdline = a:cmdline
    1              0.000001   let a:state.cached_cmdline_data = l:cmdline_data
                            
    1              0.000001   return a:state.cached_cmdline_data

FUNCTION  wilder#cmdline#skip_range#do()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/cmdline/skip_range.vim:3
Called 1 time
Total time:   0.000032
 Self time:   0.000032

count  total (s)   self (s)
    1              0.000006   while a:ctx.pos < len(a:ctx.cmdline) && stridx(s:chars, a:ctx.cmdline[a:ctx.pos]) != -1
                                let l:char = a:ctx.cmdline[a:ctx.pos]
                                if l:char ==# '\'
                                  if a:ctx.pos + 1 >= len(a:ctx.cmdline)
                                    return 1
                                  endif
                            
                                  let l:second_char = a:ctx.cmdline[a:ctx.pos + 1]
                            
                                  if l:second_char ==# '?' || l:second_char ==# '/' || l:second_char ==# '&'
                                    let a:ctx.pos += 2
                                  else
                                    return 1
                                  endif
                                elseif l:char ==# "'"
                                  let a:ctx.pos += 1
                                elseif l:char ==# '/' || l:char ==# '?'
                                  let l:delim = l:char
                                  let a:ctx.pos += 1
                            
                                  while a:ctx.pos < len(a:ctx.cmdline) && a:ctx.cmdline[a:ctx.pos] !=# l:delim
                                    if a:ctx.cmdline[a:ctx.pos] ==# '\' && a:ctx.pos + 1 < len (a:ctx.cmdline)
                                      let a:ctx.pos += 1
                                    endif
                            
                                    let a:ctx.pos += 1
                                  endwhile
                            
                                  if a:ctx.pos == len(a:ctx.cmdline)
                                    return
                                  endif
                                endif
                            
                                let a:ctx.pos += 1
    1              0.000001   endwhile

FUNCTION  wilder#vim_fuzzy_filt()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder.vim:416
Called 2 times
Total time:   0.000028
 Self time:   0.000014

count  total (s)   self (s)
    2   0.000027   0.000013   return call('wilder#transform#vim_fuzzy_filt', a:000)

FUNCTION  <SNR>58_set_firstline()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer/nvim_api.vim:217
Called 3 times
Total time:   0.000029
 Self time:   0.000029

count  total (s)   self (s)
    3              0.000003   if self.state.window_state ==# 'hidden'
                                return
    3              0.000001   endif
                            
    3              0.000002   if self.state.window_state ==# 'pending'
                                let self.state.firstline = a:line
                                return
    3              0.000001   endif
                            
    3              0.000014   call nvim_win_set_cursor(self.state.win, [a:line, 0])

FUNCTION  <SNR>55_render_lines_from_timer()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer/popupmenu.vim:275
Called 4 times
Total time:   0.068366
 Self time:   0.000109

count  total (s)   self (s)
                              " Multiple renders might be queued, skip if there is a newer render
    4              0.000008   if a:render_id != a:state.render_id || !a:state.active
    1              0.000000     return
    3              0.000001   endif
                            
    3   0.068351   0.000093   call s:render_lines(a:state, a:ctx, a:result)

FUNCTION  <lambda>4()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer/component/popupmenu_devicons.vim:20
Called 3 times
Total time:   0.000054
 Self time:   0.000029

count  total (s)   self (s)
                            return s:devicons(l:state, ctx, result)

FUNCTION  <lambda>5()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer/component/popupmenu_scrollbar.vim:13
Called 3 times
Total time:   0.000100
 Self time:   0.000016

count  total (s)   self (s)
                            return s:scrollbar(l:state, ctx, result)

FUNCTION  <SNR>58_move()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer/nvim_api.vim:198
Called 3 times
Total time:   0.000040
 Self time:   0.000040

count  total (s)   self (s)
    3              0.000003   if self.state.window_state ==# 'hidden'
                                return
    3              0.000001   endif
                            
    3              0.000002   if self.state.window_state ==# 'pending'
                                let self.state.dimensions = [a:row, a:col, a:height, a:width]
                                return
    3              0.000001   endif
                            
    3              0.000023   call nvim_win_set_config(self.state.win, { 'relative': 'editor', 'row': a:row, 'col': a:col, 'height': a:height, 'width': a:width, })

FUNCTION  <lambda>523()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/pipe/branch.vim:38
Called 1 time
Total time:   0.000018
 Self time:   0.000003

count  total (s)   self (s)
                            return s:on_finish(a:state, ctx, x)

FUNCTION  <lambda>525()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/cmdline.vim:793
Called 1 time
Total time:   0.000172
 Self time:   0.000028

count  total (s)   self (s)
                            return wilder#cmdline#get_fuzzy_completion( ctx, x, l:Completion_func, a:fuzzy, a:use_python)

FUNCTION  <lambda>526()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/cmdline.vim:309
Called 1 time
Total time:   0.000107
 Self time:   0.000014

count  total (s)   self (s)
                            return wilder#resolve(ctx, wilder#wait(a:getcompletion(ctx, l:lower_res), {ctx, lower_xs -> wilder#resolve(ctx, wilder#uniq_filt(0, 0, lower_xs + upper_xs))}))

FUNCTION  <lambda>527()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/pipeline.vim:171
Called 1 time
Total time:   0.000153
 Self time:   0.000003

count  total (s)   self (s)
                            return s:wait_start(l:state, ctx)

FUNCTION  <lambda>528()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/cmdline.vim:799
Called 1 time
Total time:   0.000025
 Self time:   0.000009

count  total (s)   self (s)
                            return wilder#resolve(ctx, { 'value': xs, 'pos': a:res.pos, 'data': s:convert_result_to_data(a:res), })

FUNCTION  wilder#cmdline#prepare_user_completion()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/cmdline.vim:617
Called 2 times
Total time:   0.000018
 Self time:   0.000013

count  total (s)   self (s)
    2   0.000015   0.000010   if !wilder#cmdline#is_user_command(a:res.cmd)
    2              0.000002     return [0, 0, a:res]
                              endif
                            
                              if !has('nvim')
                                return [1, v:true, a:res]
                              endif
                            
                              if a:ctx.session_id > s:cached_commands_session_id
                                let s:cached_commands_session_id = a:ctx.session_id
                                let s:cached_user_commands = extend(nvim_get_commands({}), nvim_buf_get_commands(0, {}))
                                let s:has_completion_error = {}
                              endif
                            
                              " Calling getcompletion() interferes with wildmenu command completion so
                              " we return v:true early
                              if has_key(s:has_completion_error, a:res.cmd)
                                let l:res = copy(a:res)
                                let l:res.pos = 0
                                return [1, v:true, l:res]
                              endif
                            
                              if has_key(s:cached_user_commands, a:res.cmd)
                                let l:command = a:res.cmd
                              else
                                " Command might be a partial name
                                let l:matches = getcompletion(a:res.cmd, 'command')
                            
                                " 2 or more matches indicates command is ambiguous
                                if len(l:matches) >= 2
                                  throw "Ambiguous use of user-defined command, possible matches: " . string(l:matches)
                                elseif len(l:matches) == 0
                                  return [1, [], a:res, 0]
                                endif
                            
                                let l:command = l:matches[0]
                              endif
                            
                              let l:user_command = s:cached_user_commands[l:command]
                            
                              if has_key(l:user_command, 'complete_arg') && l:user_command.complete_arg isnot v:null
                            
                                " Find last argument by looking for the last whitespace character
                                let l:pos = len(a:res.cmdline)
                                while l:pos >= a:res.pos
                                  if a:res.cmdline[l:pos] ==# ' ' || a:res.cmdline[l:pos] ==# "\t"
                                    break
                                  endif
                            
                                  let l:pos -= 1
                                endwhile
                            
                                let l:arg = a:res.cmdline[l:pos+1 :]
                            
                                try
                                  let l:function_name = l:user_command.complete_arg
                                  if l:function_name[:1] ==# 's:'
                                    let l:function_name = '<SNR>' . l:user_command.script_id . '_' . l:function_name[2:]
                                  elseif l:function_name[:4] ==? '<SID>'
                                    let l:function_name = '<SNR>' . l:user_command.script_id . '_' . l:function_name[5:]
                                  endif
                            
                                  let l:Completion_func = function(l:function_name)
                                  let l:result = l:Completion_func(l:arg, a:res.cmdline, len(a:res.cmdline))
                                catch
                                  " Add both the full command and partial command
                                  let s:has_completion_error[l:command] = 1
                                  let s:has_completion_error[a:res.cmd] = 1
                            
                                  let l:res = copy(a:res)
                                  let l:res.pos = 0
                                  return [1, v:true, l:res]
                                endtry
                            
                                let l:is_custom_list = get(l:user_command, 'complete', '') ==# 'customlist'
                                if !l:is_custom_list
                                  let l:result = split(l:result, '\n')
                                endif
                            
                                let l:res = copy(a:res)
                                let l:res.pos = l:pos
                                let l:res.match_arg = l:arg
                                if !l:is_custom_list
                                  let l:res.arg = l:arg
                                endif
                            
                                return [1, l:result, l:res, !l:is_custom_list]
                              endif
                            
                              if has_key(l:user_command, 'complete') && l:user_command['complete'] isnot v:null && l:user_command['complete'] !=# 'custom' && l:user_command['complete'] !=# 'customlist'
                                let l:res = copy(a:res)
                                let l:res['expand'] = l:user_command['complete']
                            
                                return [0, 0, l:res]
                              endif
                            
                              return [1, v:false, a:res]

FUNCTION  <SNR>55_draw_columns()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer/popupmenu.vim:543
Called 6 times
Total time:   0.007794
 Self time:   0.001131

count  total (s)   self (s)
    6              0.000006   let l:height = a:ctx.height
                            
   24              0.000016   for l:Column in a:columns
   18   0.006784   0.000120     let l:column = wilder#renderer#popupmenu#draw_column(a:ctx, a:result, l:Column)
                            
   18              0.000014     if empty(l:column)
    4              0.000002       continue
   14              0.000004     endif
                            
   14              0.000009     let l:i = 0
  276              0.000210     while l:i < len(l:column)
  262              0.000284       let a:column_chunks[l:i] += l:column[l:i]
                            
  262              0.000134       let l:i += 1
  276              0.000085     endwhile
                            
   14              0.000009     if l:i < l:height
                                  let l:width = wilder#render#chunks_displaywidth(l:column[0])
                            
                                  while l:i < l:height
                                    let a:column_chunks[l:i] += [[repeat(' ', l:width)]]
                            
                                    let l:i += 1
                                  endwhile
   14              0.000004     endif
   20              0.000011   endfor

FUNCTION  <lambda>110()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/cmdline.vim:1161
Called 2 times
Total time:   0.000096
 Self time:   0.000013

count  total (s)   self (s)
                            return wilder#cmdline#prepare_getcompletion(ctx, res, l:fuzzy, l:use_python)

FUNCTION  <lambda>111()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/cmdline.vim:1161
Called 2 times
Total time:   0.000601
 Self time:   0.000011

count  total (s)   self (s)
                            return s:getcompletion(ctx, res, l:fuzzy, l:use_python)

FUNCTION  <lambda>112()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/cmdline.vim:1161
Called 2 times
Total time:   0.000047
 Self time:   0.000008

count  total (s)   self (s)
                            return l:Filter(     ctx, xs, get(data, 'cmdline.match_arg', ''))

FUNCTION  <lambda>113()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/pipe/result.vim:2
Called 2 times
Total time:   0.000238
 Self time:   0.000014

count  total (s)   self (s)
                            return s:result_start(l:args, ctx, x)

FUNCTION  <lambda>114()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder.vim:201
Called 2 times
Total time:   0.000244
 Self time:   0.000006

count  total (s)   self (s)
                            return a:p(ctx, x)

FUNCTION  <lambda>117()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder.vim:198
Called 2 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                            return x

FUNCTION  <lambda>118()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/pipe/result.vim:2
Called 2 times
Total time:   0.000128
 Self time:   0.000010

count  total (s)   self (s)
                            return s:result_start(l:args, ctx, x)

FUNCTION  <lambda>119()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/cmdline.vim:1177
Called 2 times
Total time:   0.000002
 Self time:   0.000002

count  total (s)   self (s)
                            return res.expand ==# 'lua'

FUNCTION  <lambda>10()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer/popupmenu_border_theme.vim:96
Called 3 times
Total time:   0.000153
 Self time:   0.000020

count  total (s)   self (s)
                            return s:make_top_or_bottom_border(ctx, 1, a:border_chars)

FUNCTION  <lambda>11()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer/popupmenu_border_theme.vim:99
Called 3 times
Total time:   0.000144
 Self time:   0.000021

count  total (s)   self (s)
                            return s:make_top_or_bottom_border(ctx, 0, a:border_chars)

FUNCTION  <lambda>15()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer/popupmenu_palette_theme.vim:118
Called 3 times
Total time:   0.000562
 Self time:   0.000028

count  total (s)   self (s)
                            return s:prompt(a:state, ctx, result)

FUNCTION  <lambda>16()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer/popupmenu_palette_theme.vim:118
Called 1 time
Total time:   0.000019
 Self time:   0.000005

count  total (s)   self (s)
                            return s:prompt_pre_hook(a:state)

FUNCTION  <lambda>18()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer/popupmenu_palette_theme.vim:118
Called 4 times
Total time:   0.000031
 Self time:   0.000019

count  total (s)   self (s)
                            return s:prompt_pre_draw(a:state)

FUNCTION  <lambda>19()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer/popupmenu_border_theme.vim:116
Called 3 times
Total time:   0.000695
 Self time:   0.000029

count  total (s)   self (s)
                            return s:wrap_string_or_func_with_border(ctx, result, l:Value, a:left, a:right)

FUNCTION  <SNR>57_make_hl()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/highlight.vim:34
Called 2 times
Total time:   0.001308
 Self time:   0.000079

count  total (s)   self (s)
    2   0.000450   0.000038   let l:x = s:to_hl_list(a:x)
                            
    4              0.000003   for l:elem in a:xs
    2   0.000381   0.000008     let l:y = s:to_hl_list(l:elem)
    2   0.000098   0.000011     let l:x = s:combine_hl_list(l:x, l:y)
    4              0.000001   endfor
                            
    2   0.000369   0.000013   call s:make_hl_from_list(a:name, l:x)

FUNCTION  <SNR>51_get_middle_position()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer/popupmenu_palette_theme.vim:460
Called 3 times
Total time:   0.000027
 Self time:   0.000027

count  total (s)   self (s)
                              " Use max_height so the prompt does not move around the screen when height
                              " of the candidates changes
    3              0.000002   if a:is_top
    3              0.000005     let l:row = (&lines - 1 - a:dimensions.max_height) / 2
                              else
                                let l:row = (&lines - 1 - a:dimensions.max_height) / 2 + a:dimensions.max_height - a:dimensions.height
    3              0.000001   endif
                            
    3              0.000004   let l:col = (&columns - a:dimensions.width) / 2
                            
    3              0.000003   return [l:row, l:col]

FUNCTION  <lambda>530()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/pipeline.vim:105
Called 1 time
Total time:   0.000298
 Self time:   0.000005

count  total (s)   self (s)
                            return s:run(a:pipeline, a:on_finish, a:on_error, ctx, x, a:i)

FUNCTION  <lambda>533()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/pipeline.vim:177
Called 2 times
Total time:   0.000071
 Self time:   0.000009

count  total (s)   self (s)
                            return s:wait_on_finish(a:state, ctx, x)

FUNCTION  <lambda>538()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/cmdline.vim:309
Called 1 time
Total time:   0.000040
 Self time:   0.000008

count  total (s)   self (s)
                            return wilder#resolve(ctx, wilder#uniq_filt(0, 0, lower_xs + upper_xs))

FUNCTION  <lambda>539()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/pipeline.vim:171
Called 1 time
Total time:   0.000083
 Self time:   0.000003

count  total (s)   self (s)
                            return s:wait_start(l:state, ctx)

FUNCTION  wilder#cmdline#is_file_expansion()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/cmdline.vim:600
Called 2 times
Total time:   0.000007
 Self time:   0.000007

count  total (s)   self (s)
    2              0.000006   return a:expand ==# 'file' || a:expand ==# 'file_in_path' || a:expand ==# 'dir' || a:expand ==# 'shellcmd' || a:expand ==# 'user'

FUNCTION  <SNR>111_call()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/pipeline.vim:95
Called 10 times
Total time:   0.006318
 Self time:   0.000105

count  total (s)   self (s)
   10              0.000019   let a:ctx.handler_id = a:handler_id
                            
   10              0.000005   try
   10   0.006264   0.000051     call a:f(a:ctx)
                              catch
                                call wilder#reject(a:ctx, 'pipeline: ' . v:exception)
   10              0.000004   endtry

FUNCTION  <lambda>120()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/pipe/check.vim:1
Called 2 times
Total time:   0.000025
 Self time:   0.000009

count  total (s)   self (s)
                            return s:check(a:args, ctx, x)

FUNCTION  <lambda>129()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/pipe/branch.vim:5
Called 2 times
Total time:   0.000005
 Self time:   0.000005

count  total (s)   self (s)
                            return {ctx -> s:branch(a:args, ctx, x)}

FUNCTION  <lambda>20()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer/popupmenu_border_theme.vim:96
Called 3 times
Total time:   0.000164
 Self time:   0.000028

count  total (s)   self (s)
                            return s:make_top_or_bottom_border(ctx, 1, a:border_chars)

FUNCTION  <lambda>21()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer/popupmenu_palette_theme.vim:456
Called 3 times
Total time:   0.000045
 Self time:   0.000018

count  total (s)   self (s)
                            return s:get_middle_position(ctx, dimensions, a:is_top)

FUNCTION  <SNR>51_prompt_post_hook()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer/popupmenu_palette_theme.vim:419
Called 1 time
Total time:   0.000003
 Self time:   0.000003

count  total (s)   self (s)
    1              0.000002   call timer_stop(a:state.timer)

FUNCTION  <SNR>59_convert_result_to_data()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/cmdline.vim:753
Called 2 times
Total time:   0.000027
 Self time:   0.000027

count  total (s)   self (s)
    2              0.000006   let l:data = { 'pos': a:res.pos, 'cmdline.command': a:res.cmd, 'cmdline.expand': a:res.expand, 'cmdline.arg': a:res.arg, }
                            
    2              0.000002   if has_key(a:res, 'path_prefix')
                                let l:data['cmdline.path_prefix'] = a:res.path_prefix
    2              0.000001   endif
                            
    2              0.000002   if has_key(a:res, 'match_arg')
    2              0.000003     let l:data['cmdline.match_arg'] = a:res.match_arg
    2              0.000001   endif
                            
    2              0.000002   if has_key(a:res, 'has_wildcard')
                                let l:data['cmdline.has_wildcard'] = a:res.has_wildcard
    2              0.000000   endif
                            
    2              0.000001   return l:data

FUNCTION  <SNR>58_hide()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer/nvim_api.vim:165
Called 1 time
Total time:   0.000048
 Self time:   0.000048

count  total (s)   self (s)
    1              0.000002   if self.state.win == -1 || self.state.window_state ==# 'hidden'
                                return
    1              0.000000   endif
                            
    1              0.000001   if self.state.window_state ==# 'pending'
                                let self.state.win = -1
                                let self.state.window_state = 'hidden'
                                return
    1              0.000000   endif
                            
    1              0.000002   if getcmdwintype() ==# ''
    1              0.000001     try
    1              0.000021       call nvim_win_close(self.state.win, 1)
                                catch
                                  let l:win = self.state.win
                                  call timer_start(0, {-> nvim_win_close(l:win, 1)})
    1              0.000001     endtry
                              else
                                " cannot call nvim_win_close() while cmdline-window is open
                                " make the window as small as possible and hide it with winblend = 100
                                let l:win = self.state.win
                                call self.delete_all_lines()
                                call self.move(&lines, &columns, 1, 1)
                                call self.set_option('winblend', 100)
                                execute 'autocmd CmdWinLeave * ++once call timer_start(0, {-> nvim_win_close(' . l:win . ', 0)})'
    1              0.000000   endif
                            
    1              0.000001   let self.state.win = -1
    1              0.000001   let self.state.window_state = 'hidden'

FUNCTION  <SNR>53_wrap_string_or_func_with_border()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer/popupmenu_border_theme.vim:121
Called 3 times
Total time:   0.000666
 Self time:   0.000104

count  total (s)   self (s)
    3              0.000003   let l:width = a:ctx.width
    3              0.000005   let l:width -= strdisplaywidth(a:left)
    3              0.000004   let l:width -= strdisplaywidth(a:right)
    3              0.000003   if l:width < 0
                                let l:width = 0
    3              0.000001   endif
                            
    3              0.000003   if type(a:line) is v:t_func
    3              0.000007     let l:ctx = copy(a:ctx)
    3              0.000003     let l:ctx.width = l:width
    3   0.000586   0.000025     let l:result = a:line(l:ctx, a:result)
                            
    3              0.000003     if empty(l:result)
                                  return l:result
    3              0.000001     endif
                            
    3              0.000003     if type(l:result) is v:t_string
                                  let l:chunks = [[wilder#render#truncate_and_pad(l:width, l:result)]]
    3              0.000001     else
    3              0.000002       let l:chunks = l:result
    3              0.000001     endif
                              else
                                if empty(a:line)
                                  return a:line
                                endif
                            
                                let l:chunks = [[wilder#render#truncate_and_pad(l:width, a:line)]]
    3              0.000001   endif
                            
    3              0.000004   let l:border_hl = a:ctx.highlights.border
    3              0.000009   return [[a:left, l:border_hl]] + l:chunks + [[a:right, l:border_hl]]

FUNCTION  <lambda>132()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder.vim:198
Called 2 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                            return x

FUNCTION  <lambda>135()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder.vim:198
Called 2 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                            return x

FUNCTION  <lambda>136()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/cmdline.vim:1367
Called 2 times
Total time:   0.000002
 Self time:   0.000002

count  total (s)   self (s)
                            return getcmdtype() ==# ':'

FUNCTION  <lambda>137()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/pipe/check.vim:1
Called 2 times
Total time:   0.000033
 Self time:   0.000008

count  total (s)   self (s)
                            return s:check(a:args, ctx, x)

FUNCTION  <lambda>138()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/cmdline.vim:1367
Called 2 times
Total time:   0.002848
 Self time:   0.000023

count  total (s)   self (s)
                            return wilder#cmdline#parse(x)

FUNCTION  <SNR>51_prompt_pre_draw()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer/popupmenu_palette_theme.vim:160
Called 4 times
Total time:   0.000012
 Self time:   0.000012

count  total (s)   self (s)
    4              0.000011   return a:state.cached_cmdline !=# getcmdline() || a:state.cmdpos != getcmdpos()

FUNCTION  wilder#main#get_candidate()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/main.vim:599
Called 53 times
Total time:   0.000071
 Self time:   0.000071

count  total (s)   self (s)
   53              0.000060   return a:result.value[a:index]

FUNCTION  copilot#OnBufUnload()
    Defined: ~/.local/share/nvim/lazy/copilot.vim/autoload/copilot.vim:484
Called 9 times
Total time:   0.000001
 Self time:   0.000001

count  total (s)   self (s)

FUNCTION  wilder#cmdline#main#do()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/cmdline/main.vim:36
Called 2 times
Total time:   0.001398
 Self time:   0.000380

count  total (s)   self (s)
                              " default
    2              0.000002   let a:ctx.expand = 'command'
    2              0.000002   let a:ctx.force = 0
                            
    2              0.000004   if empty(a:ctx.cmdline[a:ctx.pos :])
    1              0.000000     return
    1              0.000000   endif
                            
    1   0.000023   0.000006   if !wilder#cmdline#main#skip_whitespace(a:ctx)
                                return
    1              0.000000   endif
                            
                              " check if comment
    1              0.000001   if a:ctx.cmdline[a:ctx.pos] ==# '"'
                                let a:ctx.pos = len(a:ctx.cmdline)
                                let a:ctx.expand = 'nothing'
                                return
    1              0.000000   endif
                            
                              " skip range
    1   0.001222   0.000240   call wilder#cmdline#skip_range#do(a:ctx)
                            
    1   0.000024   0.000005   if !wilder#cmdline#main#skip_whitespace(a:ctx)
                                return
    1              0.000000   endif
                            
    1              0.000001   if a:ctx.cmdline[a:ctx.pos] ==# '"'
                                let a:ctx.pos = len(a:ctx.cmdline)
                                let a:ctx.expand = 'nothing'
                                return
    1              0.000000   endif
                            
                              " check if starts with | or :
                              " treat as a new command
    1              0.000002   if a:ctx.cmdline[a:ctx.pos] ==# '|' || a:ctx.cmdline[a:ctx.pos] ==# ':'
                                let a:ctx.pos += 1
                                let a:ctx.cmd = ''
                            
                                call wilder#cmdline#main#do(a:ctx)
                            
                                return
    1              0.000000   endif
                            
    1              0.000001   let l:is_user_cmd = 0
                            
    1              0.000002   if a:ctx.cmdline[a:ctx.pos] ==# 'k' && a:ctx.cmdline[a:ctx.pos + 1] !=# 'e'
                                let a:ctx.cmd = 'k'
                                let a:ctx.pos += 1
                            
                                return
    1              0.000000   else
    1              0.000001     let l:cmd_start = a:ctx.pos
                            
    1              0.000001     let l:char = a:ctx.cmdline[a:ctx.pos]
                            
    1              0.000001     if l:char >=# 'A' && l:char <=# 'Z'
                                  " user-defined command can contain digits
                                  while l:char >=# 'a' && l:char <=# 'z' || l:char >=# 'A' && l:char <=# 'Z' || l:char >=# '0' && l:char <=# '9'
                                    let a:ctx.pos += 1
                                    let l:char = a:ctx.cmdline[a:ctx.pos]
                                  endwhile
                            
                                  let a:ctx.cmd = a:ctx.cmdline[l:cmd_start : a:ctx.pos - 1]
                                  let l:is_user_cmd = 1
    1              0.000000     else
                                  " non-alphabet command
    1              0.000001       if stridx('@*!=><&~#', l:char) != -1
                                    let a:ctx.pos += 1
                                    let l:char = a:ctx.cmdline[a:ctx.pos]
    1              0.000000       else
                                    " py3, python3, py3file and py3do are the only commands with numbers
                                    " all other commands are alphabet only
    1              0.000002         if a:ctx.cmdline[a:ctx.pos] ==# 'p' && a:ctx.cmdline[a:ctx.pos + 1] ==# 'y' && a:ctx.cmdline[a:ctx.pos + 2] ==# '3'
                                      let a:ctx.pos += 3
                                      let l:char = a:ctx.cmdline[a:ctx.pos]
    1              0.000000         endif
                            
                                    " this should check for [a-zA-Z] only, but the Vim implementation
                                    " skips over wildcards. This matters for commands which accept
                                    " non-alphanumeric arugments e.g. 'e*' would be parsed as an 'edit'
                                    " command with a '*' argument otherwise. These commands typically
                                    " don't need a space between the command and argument e.g. 'e++opt'
                                    " is a valid command.
    2              0.000004         while l:char >=# 'a' && l:char <=# 'z' || l:char >=# 'A' && l:char <=# 'Z' || l:char ==# '*'
    1              0.000001           let a:ctx.pos += 1
    1              0.000001           let l:char = a:ctx.cmdline[a:ctx.pos]
    2              0.000026         endwhile
    1              0.000000       endif
                            
    1              0.000001       if a:ctx.pos == l:cmd_start
                                    let a:ctx.expand = 'unsuccessful'
                                    return
    1              0.000000       endif
                            
                                  " find the command
    1              0.000001       if a:ctx.pos > l:cmd_start
    1              0.000002         let l:cmd = a:ctx.cmdline[l:cmd_start : a:ctx.pos - 1]
    1              0.000001         let l:len = a:ctx.pos - l:cmd_start
                            
    1              0.000001         let l:char = l:cmd[0]
    1              0.000001         if l:char < 'a' || l:char > 'z'
                                      let l:char = 'z'
    1              0.000000         endif
                            
    1              0.000002         let l:next_char = nr2char(char2nr(l:char) + 1)
                            
    1              0.000002         let l:i = s:command_char_pos[l:char]
    1              0.000003         let l:end = get(s:command_char_pos, 'l:next_char', len(s:commands))
                            
    1              0.000001         while l:i < l:end
    1              0.000003           let l:command = s:commands[l:i]
    1              0.000002           if l:cmd ==# l:command[: l:len - 1]
    1              0.000001             let a:ctx.cmd = l:command
    1              0.000001             break
                                      endif
                            
                                      let l:i += 1
    1              0.000001         endwhile
    1              0.000000       endif
    1              0.000000     endif
    1              0.000000   endif
                            
                              " cursor is touching command and ends in alpha-numeric character
                              " complete the command name
    1              0.000001   if a:ctx.pos == len(a:ctx.cmdline)
    1              0.000001     let l:char = a:ctx.cmdline[a:ctx.pos - 1]
                            
    1              0.000002     if l:char >=# 'a' && l:char <=# 'z' || l:char >=# 'A' && l:char <=# 'Z' || l:char >=# '0' && l:char <=# '9'
    1              0.000001       let a:ctx.pos = l:cmd_start
    1              0.000001       let a:ctx.cmd = ''
                                  " expand commands
    1              0.000000       return
                                endif
                              endif
                            
                              " no matching command found, treat as no arguments
                              if empty(a:ctx.cmd)
                                " 2 or 3-letter substitute command, takes no arguments
                                if a:ctx.cmdline[l:cmd_start] ==# 's' && stridx('cgriI', a:ctx.cmdline[l:cmd_start + 1]) != -1
                                  let a:ctx.cmd = 's'
                                endif
                            
                                let a:ctx.pos = len(a:ctx.cmdline)
                                let a:ctx.expand = 'nothing'
                                return
                              endif
                            
                              let a:ctx.expand = 'nothing'
                            
                              " handle !
                              if a:ctx.cmdline[a:ctx.pos] ==# '!'
                                let a:ctx.pos += 1
                                let a:ctx.force = 1
                              endif
                            
                              if has_key(s:command_modifiers, a:ctx.cmd)
                                let a:ctx.cmd = ''
                                let a:ctx.expand = ''
                            
                                call wilder#cmdline#main#do(a:ctx)
                            
                                return
                              endif
                            
                              call wilder#cmdline#main#skip_whitespace(a:ctx)
                            
                              let l:flags = get(s:command_flags, a:ctx.cmd, 0)
                            
                              let l:use_filter = 0
                            
                              if a:ctx.cmd ==# 'write' || a:ctx.cmd ==# 'update'
                                if a:ctx.cmdline[a:ctx.pos] ==# '>'
                                  if a:ctx.cmdline[a:ctx.pos + 1] ==# '>'
                                    let a:ctx.pos += 2
                                  endif
                            
                                  call wilder#cmdline#main#skip_whitespace(a:ctx)
                                endif
                            
                                if a:ctx.cmd ==# 'write' && a:ctx.cmdline[a:ctx.pos] ==# '!'
                                  let a:ctx.pos += 1
                                  let l:use_filter = 1
                                endif
                              elseif a:ctx.cmd ==# 'read'
                                if a:ctx.cmdline[a:ctx.pos] ==# '!'
                                  let a:ctx.pos += 1
                                  let l:use_filter = 1
                                else
                                  let l:use_filter = a:ctx.force
                                endif
                              elseif a:ctx.cmd ==# '<' || a:ctx.cmd ==# '>'
                                while a:ctx.cmdline[a:ctx.pos] ==# a:ctx.cmd
                                  let a:ctx.pos += 1
                                endwhile
                            
                                call wilder#cmdline#main#skip_whitespace(a:ctx)
                              endif
                            
                              " Handle +cmd or ++opt
                              if a:ctx.cmdline[a:ctx.pos] ==# '+' && ((and(l:flags, s:EDITCMD) && !l:use_filter) || and(l:flags, s:ARGOPT))
                                let l:allow_opt = 1
                                let l:allow_cmd = and(l:flags, s:EDITCMD) && !l:use_filter
                            
                                while a:ctx.cmdline[a:ctx.pos] ==# '+' && a:ctx.pos < len(a:ctx.cmdline)
                                  let a:ctx.pos += 1
                            
                                  if a:ctx.cmdline[a:ctx.pos] ==# '+'
                                    if l:allow_opt
                                      let a:ctx.pos += 1
                                      let l:expand = 'file_opt'
                                    else
                                      let l:expand = 'nothing'
                                    endif
                                  elseif l:allow_cmd
                                    let l:expand = 'command'
                                    " ++opt must be before +cmd
                                    let l:allow_opt = 0
                                    " only 1 +cmd allowed
                                    let l:allow_cmd = 0
                                  else
                                    let l:expand = 'nothing'
                                  endif
                            
                                  let l:arg_start = a:ctx.pos
                            
                                  " skip to next arg
                                  while a:ctx.pos < len(a:ctx.cmdline) && !wilder#cmdline#main#is_whitespace(a:ctx.cmdline[a:ctx.pos])
                                    if a:ctx.cmdline[a:ctx.pos] ==# '\' && a:ctx.pos + 1 < len(a:ctx.cmdline)
                                      let a:ctx.pos += 1
                                    endif
                            
                                    " TODO: multibyte
                                    let a:ctx.pos += 1
                                  endwhile
                            
                                  " still in command or option
                                  if empty(a:ctx.cmdline[a:ctx.pos])
                                    let a:ctx.pos = l:arg_start
                                    let a:ctx.expand = l:expand
                                    return
                                  endif
                            
                                  call wilder#cmdline#main#skip_whitespace(a:ctx)
                                endwhile
                            
                                if a:ctx.cmd ==# 'write' && a:ctx.cmdline[a:ctx.pos] ==# '!'
                                  let a:ctx.pos += 1
                                  let l:use_filter = 1
                                elseif a:ctx.cmd ==# 'read'
                                  if a:ctx.cmdline[a:ctx.pos] ==# '!'
                                    let a:ctx.pos += 1
                                    let l:use_filter = 1
                                  else
                                    let l:use_filter = a:ctx.force
                                  endif
                                endif
                              endif
                            
                              " look for | for new command and " for comment
                              if and(l:flags, s:TRLBAR) && !l:use_filter
                                if a:ctx.cmd ==# 'redir' && a:ctx.cmdline[a:ctx.pos] ==# '@' && a:ctx.cmdline[a:ctx.pos + 1] ==# '"'
                                  let a:ctx.pos += 2
                                endif
                            
                                let l:lookahead = a:ctx.pos
                                while l:lookahead < len(a:ctx.cmdline)
                                  if a:ctx.cmdline[l:lookahead] ==# "\<C-V>" || a:ctx.cmdline[l:lookahead] ==# '\'
                                    let l:lookahead += 1
                            
                                    if l:lookahead + 1 < len(a:ctx.cmdline)
                                      let l:lookahead += 1
                                    else
                                      break
                                    endif
                                  endif
                            
                                  " Check if " indicates a comment or start of string
                                  if a:ctx.cmdline[l:lookahead] ==# '"'
                                    let l:lookahead += 1
                            
                                    let l:end_quote_reached = 0
                                    " Consume until next char is " or end of cmdline is reached
                                    while l:lookahead < len(a:ctx.cmdline)
                                      if a:ctx.cmdline[l:lookahead] ==# '\'
                                        let l:lookahead += 1
                                      elseif a:ctx.cmdline[l:lookahead] ==# '"'
                                        let l:end_quote_reached = 1
                                        let l:lookahead += 1
                                        break
                                      endif
                            
                                      let l:lookahead += 1
                                    endwhile
                            
                                    " remaining part of cmdline is comment, treat as no arguments
                                    if !l:end_quote_reached
                                      let a:ctx.pos = len(a:ctx.cmdline)
                                      return
                                    endif
                            
                                  " start of new command
                                  elseif a:ctx.cmdline[l:lookahead] ==# '|'
                                    let a:ctx.pos = l:lookahead + 1
                                    let a:ctx.cmd = ''
                                    let a:ctx.expand = ''
                            
                                    call wilder#cmdline#main#do(a:ctx)
                            
                                    return
                                  endif
                            
                                  " TODO: multibyte
                                  let l:lookahead += 1
                                endwhile
                              endif
                            
                              " command does not take extra arguments
                              if !and(l:flags, s:EXTRA) && !l:is_user_cmd
                                " consume whitespace
                                call wilder#cmdline#main#skip_whitespace(a:ctx)
                            
                                " and check for | or "
                                if a:ctx.cmdline[a:ctx.pos] ==# '|'
                                  let a:ctx.pos += 1
                                  let a:ctx.cmd = ''
                                  let a:ctx.expand = ''
                            
                                  call wilder#cmdline#main#do(a:ctx)
                                  return
                                else
                                  " remaining part is either comment or invalid arguments
                                  " either way, treat as no arguments
                                  let a:ctx.pos = len(a:ctx.cmdline)
                                  let a:ctx.expand = 'nothing'
                                  return
                                endif
                              endif
                            
                            
                              if l:use_filter || a:ctx.cmd ==# '!' || a:ctx.cmd ==# 'terminal'
                                let l:before_args = a:ctx.pos
                            
                                if !wilder#cmdline#main#skip_nonwhitespace(a:ctx)
                                  let a:ctx.pos = l:before_args
                                  let a:ctx.expand = 'shellcmd'
                                  return
                                endif
                            
                                " Reset pos back to before_args
                                let a:ctx.pos = l:before_args
                              endif
                            
                              if and(l:flags, s:XFILE)
                                " TODO: handle backticks :h backtick-expansion
                            
                                let l:arg_start = a:ctx.pos
                            
                                " Check if completing $ENV
                                if a:ctx.cmdline[a:ctx.pos] ==# '$'
                                  let l:arg_start = a:ctx.pos
                                  let a:ctx.pos += 1
                            
                                  while a:ctx.pos < len(a:ctx.cmdline)
                                    let l:char = a:ctx.cmdline[a:ctx.pos]
                                    if !s:is_idc(l:char)
                                      break
                                    endif
                            
                                    let a:ctx.pos += 1
                                  endwhile
                            
                                  if a:ctx.pos == len(a:ctx.cmdline)
                                    let a:ctx.expand = 'environment'
                                    let a:ctx.pos = l:arg_start + 1
                                    return
                                  endif
                                endif
                            
                                " Check if completing ~user
                                if a:ctx.cmdline[a:ctx.pos] ==# '~'
                                  let l:allow_backslash = has('win32') || has('win64')
                            
                                  while a:ctx.pos < len(a:ctx.cmdline)
                                    let l:char = a:ctx.cmdline[a:ctx.pos]
                                    if l:char ==# '/' || l:allow_backslash && l:char ==# '\' || !s:is_filec(l:char)
                                      break
                                    endif
                            
                                    let a:ctx.pos += 1
                                  endwhile
                            
                                  " + 1 since we want to expand ~ to $HOME
                                  if a:ctx.pos == len(a:ctx.cmdline) && a:ctx.pos > l:arg_start + 1
                                    let a:ctx.expand = 'user'
                                    let a:ctx.pos = l:arg_start + 1
                                    return
                                  endif
                                endif
                            
                                let a:ctx.pos = l:arg_start
                                let a:ctx.expand = 'file'
                            
                                " vim assumes for XFILE, we can ignore arguments other than the last one but
                                " this is not necessarily true, we should not do this for NOSPC
                                if !and(l:flags, s:NOSPC)
                                  call s:move_pos_to_last_arg(a:ctx)
                                endif
                              endif
                            
                              if a:ctx.cmd ==# 'find' || a:ctx.cmd ==# 'sfind' || a:ctx.cmd ==# 'tabfind'
                                if a:ctx.expand ==# 'file'
                                  let a:ctx.expand = 'file_in_path'
                                endif
                                return
                              elseif a:ctx.cmd ==# 'cd' || a:ctx.cmd ==# 'chdir' || a:ctx.cmd ==# 'lcd' || a:ctx.cmd ==# 'lchdir' || a:ctx.cmd ==# 'tcd' || a:ctx.cmd ==# 'tchdir'
                                if a:ctx.expand ==# 'file'
                                  let a:ctx.expand = 'dir'
                                endif
                                return
                              elseif a:ctx.cmd ==# 'help'
                                let a:ctx.expand = 'help'
                                return
                              " command modifiers
                              elseif has_key(s:command_modifiers, a:ctx.cmd)
                                let a:ctx.cmd = ''
                                let a:ctx.expand = ''
                            
                                call wilder#cmdline#main#do(a:ctx)
                            
                                return
                              elseif a:ctx.cmd ==# 'filter'
                                call wilder#cmdline#filter#do(a:ctx)
                                return
                              elseif a:ctx.cmd ==# 'match'
                                call wilder#cmdline#match#do(a:ctx)
                                return
                              elseif a:ctx.cmd ==# 'command'
                                call wilder#cmdline#command#do(a:ctx)
                                return
                              elseif a:ctx.cmd ==# 'delcommand'
                                let a:ctx.expand = 'user_commands'
                                return
                              elseif a:ctx.cmd ==# 'global' || a:ctx.cmd ==# 'vglobal'
                                call wilder#cmdline#global#do(a:ctx)
                                return
                              elseif a:ctx.cmd ==# '&' || a:ctx.cmd ==# 'substitute'
                                call wilder#cmdline#substitute#do(a:ctx)
                                return
                              elseif a:ctx.cmd ==# 'isearch' || a:ctx.cmd ==# 'dsearch' || a:ctx.cmd ==# 'ilist' || a:ctx.cmd ==# 'dlist' || a:ctx.cmd ==# 'ijump' || a:ctx.cmd ==# 'psearch' || a:ctx.cmd ==# 'djump' || a:ctx.cmd ==# 'isplit' || a:ctx.cmd ==# 'dsplit'
                                call wilder#cmdline#isearch#do(a:ctx)
                                return
                              elseif a:ctx.cmd ==# 'autocmd'
                                call wilder#cmdline#autocmd#do(a:ctx, 0)
                                return
                              elseif a:ctx.cmd ==# 'doautocmd' || a:ctx.cmd ==# 'doautoall'
                                call wilder#cmdline#autocmd#do(a:ctx, 1)
                              elseif a:ctx.cmd ==# 'set' || a:ctx.cmd ==# 'setglobal' || a:ctx.cmd ==# 'setlocal'
                                call wilder#cmdline#set#do(a:ctx)
                                return
                              elseif a:ctx.cmd ==# 'tag' || a:ctx.cmd ==# 'stag' || a:ctx.cmd ==# 'ptag' || a:ctx.cmd ==# 'ltag' || a:ctx.cmd ==# 'tselect' || a:ctx.cmd ==# 'stselect' || a:ctx.cmd ==# 'tjump' || a:ctx.cmd ==# 'stjump' || a:ctx.cmd ==# 'ptselect' || a:ctx.cmd ==# 'ptjump'
                                let a:ctx.expand = 'tags'
                                return
                              elseif a:ctx.cmd ==# 'augroup'
                                let a:ctx.expand = 'augroup'
                              elseif a:ctx.cmd ==# 'syntax'
                                call wilder#cmdline#syntax#do(a:ctx)
                                return
                              elseif a:ctx.cmd ==# 'let' || a:ctx.cmd ==# 'if' || a:ctx.cmd ==# 'elseif' || a:ctx.cmd ==# 'while' || a:ctx.cmd ==# 'for' || a:ctx.cmd ==# 'echo' || a:ctx.cmd ==# 'echon' || a:ctx.cmd ==# 'execute' || a:ctx.cmd ==# 'echomsg' || a:ctx.cmd ==# 'echoerr' || a:ctx.cmd ==# 'call' || a:ctx.cmd ==# 'return' || a:ctx.cmd ==# 'cexpr' || a:ctx.cmd ==# 'caddexpr' || a:ctx.cmd ==# 'cgetexpr' || a:ctx.cmd ==# 'lexpr' || a:ctx.cmd ==# 'laddexpr' || a:ctx.cmd ==# 'lgetexpr'
                                "TODO call has extra arugments
                                call wilder#cmdline#let#do(a:ctx)
                                return
                              elseif a:ctx.cmd ==# 'unlet'
                                call wilder#cmdline#unlet#do(a:ctx)
                                return
                              elseif a:ctx.cmd ==# 'function'
                                let a:ctx.expand = 'function'
                                return
                              elseif a:ctx.cmd ==# 'delfunction'
                                let a:ctx.expand = 'user_func'
                                return
                              elseif a:ctx.cmd ==# 'echohl'
                                let a:ctx.expand = 'highlight'
                                " TODO: include None
                                return
                              elseif a:ctx.cmd ==# 'highlight'
                                call wilder#cmdline#highlight#do(a:ctx)
                                return
                              elseif a:ctx.cmd ==# 'cscope' || a:ctx.cmd ==# 'lcscope' || a:ctx.cmd ==# 'scscope'
                                call wilder#cmdline#cscope#do(a:ctx)
                                return
                              elseif a:ctx.cmd ==# 'sign'
                                call wilder#cmdline#sign#do(a:ctx)
                                return
                              elseif a:ctx.cmd ==# 'bdelete' || a:ctx.cmd ==# 'bwipeout' || a:ctx.cmd ==# 'bunload'
                                let a:ctx.expand = 'buffer'
                                return
                              elseif a:ctx.cmd ==# 'buffer' || a:ctx.cmd ==# 'sbuffer' || a:ctx.cmd ==# 'checktime'
                                let a:ctx.expand = 'buffer'
                                return
                              elseif a:ctx.cmd ==# 'abbreviate' || a:ctx.cmd ==# 'unabbreviate' || a:ctx.cmd[-3 :] ==# 'map' || a:ctx.cmd[-6 :] ==# 'abbrev'
                                call wilder#cmdline#map#do(a:ctx)
                                return
                              elseif a:ctx.cmd[-8 :] ==# 'mapclear'
                                let a:ctx.expand = 'mapclear'
                                return
                              elseif a:ctx.cmd[-4 :] ==# 'menu'
                                call wilder#cmdline#menu#do(a:ctx)
                                return
                              elseif a:ctx.cmd ==# 'colorscheme'
                                let a:ctx.expand = 'color'
                                return
                              elseif a:ctx.cmd ==# 'compiler'
                                let a:ctx.expand = 'compiler'
                                return
                              elseif a:ctx.cmd ==# 'ownsyntax'
                                let a:ctx.expand = 'ownsyntax'
                                return
                              elseif a:ctx.cmd ==# 'packadd'
                                let a:ctx.expand = 'packadd'
                                return
                              elseif a:ctx.cmd ==# 'language'
                                let l:arg_start = a:ctx.pos
                                call wilder#cmdline#main#skip_nonwhitespace(a:ctx)
                            
                                if a:ctx.pos == len(a:ctx.cmdline)
                                  let a:ctx.expand = 'language'
                                  let a:ctx.pos = l:arg_start
                                else
                                  let l:subcommand = a:ctx.cmdline[l:arg_start : a:ctx.pos - 1]
                                  if l:subcommand ==# 'messages' || l:subcommand ==# 'ctype' || l:subcommand ==# 'time'
                                    let a:ctx.expand = 'locales'
                                    call wilder#cmdline#main#skip_whitespace(a:ctx)
                                  endif
                                endif
                              elseif a:ctx.cmd ==# 'profile'
                                call wilder#cmdline#profile#do(a:ctx)
                                return
                              elseif a:ctx.cmd ==# 'checkhealth'
                                let a:ctx.expand = 'checkhealth'
                                call s:move_pos_to_last_arg(a:ctx)
                                return
                              elseif a:ctx.cmd ==# 'behave'
                                let a:ctx.expand = 'behave'
                                return
                              elseif a:ctx.cmd ==# 'messages'
                                let a:ctx.expand = 'messages'
                                return
                              elseif a:ctx.cmd ==# 'history'
                                let a:ctx.expand = 'history'
                                return
                              elseif a:ctx.cmd ==# 'syntime'
                                let a:ctx.expand = 'syntime'
                                return
                              elseif a:ctx.cmd ==# 'argdelete'
                                let a:ctx.expand = 'arglist'
                                return
                              elseif a:ctx.cmd ==# 'lua'
                                let a:ctx.expand = 'lua'
                                return
                              endif

FUNCTION  <lambda>140()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder.vim:198
Called 2 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                            return x

FUNCTION  <lambda>141()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder.vim:198
Called 2 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                            return x

FUNCTION  <lambda>142()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/cmdline.vim:1367
Called 2 times
Total time:   0.000030
 Self time:   0.000012

count  total (s)   self (s)
                            return wilder#cmdline#prepare_user_completion(ctx, res)

FUNCTION  <lambda>143()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/pipe/branch.vim:5
Called 2 times
Total time:   0.000005
 Self time:   0.000005

count  total (s)   self (s)
                            return {ctx -> s:branch(a:args, ctx, x)}

FUNCTION  <lambda>144()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/cmdline.vim:1367
Called 2 times
Total time:   0.000019
 Self time:   0.000013

count  total (s)   self (s)
                            return l:sort_buffers_lastused ? s:sort_buffers_lastused(ctx, xs, data) : xs

FUNCTION  <lambda>145()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/cmdline.vim:1367
Called 2 times
Total time:   0.000027
 Self time:   0.000008

count  total (s)   self (s)
                            return s:set_query(data)

FUNCTION  <lambda>146()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/pipe/result.vim:2
Called 2 times
Total time:   0.000228
 Self time:   0.000010

count  total (s)   self (s)
                            return s:result_start(l:args, ctx, x)

FUNCTION  <SNR>51_prompt_pre_hook()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer/popupmenu_palette_theme.vim:409
Called 1 time
Total time:   0.000014
 Self time:   0.000014

count  total (s)   self (s)
    1              0.000002   call timer_stop(a:state.timer)
                            
    1              0.000001   let a:state.cmdpos = -1
    1              0.000001   let a:state.previous_start = -1
    1              0.000001   let a:state.previous_end = -1
                            
    1              0.000007   let a:state.timer = timer_start(a:state.cursor_check_interval, {-> s:prompt_update_cursor(a:state)}, {'repeat': -1})

FUNCTION  <SNR>64_branch()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/pipe/branch.vim:9
Called 6 times
Total time:   0.005786
 Self time:   0.000117

count  total (s)   self (s)
    6              0.000030   let l:state = { 'index': 0, 'pipelines': a:pipelines, 'original_ctx': copy(a:ctx), 'original_x': copy(a:x), }
                            
    6   0.005751   0.000082   call wilder#pipeline#run( l:state.pipelines[0], {ctx, x -> s:on_finish(l:state, ctx, x)}, {ctx, x -> s:on_error(l:state, ctx, x)}, copy(a:ctx), copy(a:x), )

FUNCTION  <SNR>110_redraw()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer.vim:9
Called 3 times
Total time:   0.007774
 Self time:   0.007774

count  total (s)   self (s)
    3              0.000007   if a:apply_incsearch_fix && &incsearch && (getcmdtype() ==# '/' || getcmdtype() ==# '?')
                                call feedkeys("\<C-R>\<BS>", 'n')
                                return
    3              0.000001   endif
                            
    3              0.000002   if a:is_redrawstatus
                                redrawstatus
    3              0.000001   else
    3              0.007747     redraw
    3              0.000003   endif

FUNCTION  <lambda>367()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/pipe/branch.vim:5
Called 1 time
Total time:   0.002175
 Self time:   0.000004

count  total (s)   self (s)
                            return s:branch(a:args, ctx, x)

FUNCTION  <lambda>369()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/pipeline.vim:105
Called 1 time
Total time:   0.000425
 Self time:   0.000005

count  total (s)   self (s)
                            return s:run(a:pipeline, a:on_finish, a:on_error, ctx, x, a:i)

FUNCTION  wilder#cmdline#main#skip_whitespace()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/cmdline/main.vim:683
Called 2 times
Total time:   0.000036
 Self time:   0.000029

count  total (s)   self (s)
    2              0.000003   if empty(a:ctx.cmdline[a:ctx.pos])
                                return 0
    2              0.000001   endif
                            
    2   0.000021   0.000013   while wilder#cmdline#main#is_whitespace(a:ctx.cmdline[a:ctx.pos])
                                let a:ctx.pos += 1
                            
                                if empty(a:ctx.cmdline[a:ctx.pos])
                                  return 0
                                endif
    2              0.000001   endwhile
                            
    2              0.000001   return 1

FUNCTION  <SNR>59_sort_buffers_lastused()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/cmdline.vim:1398
Called 2 times
Total time:   0.000006
 Self time:   0.000006

count  total (s)   self (s)
    2              0.000004   if get(a:data, 'cmdline.expand', '') !=# 'buffer'
    2              0.000001     return a:xs
                              endif
                            
                              let l:bufinfos = getbufinfo()
                              let l:bufnr_to_x = {}
                            
                              for l:x in a:xs
                                let l:bufname = fnamemodify(l:x, ':~')
                                let l:bufnr = bufnr('^' . l:x . '$')
                            
                                let l:bufnr_to_x[l:bufnr] = l:x
                              endfor
                            
                              let l:x_to_info = {}
                              let l:seen = {}
                            
                              for l:info in l:bufinfos
                                let l:bufnr = l:info.bufnr
                            
                                if !has_key(l:bufnr_to_x, l:bufnr)
                                  continue
                                endif
                            
                                let l:x = l:bufnr_to_x[l:bufnr]
                                let l:x_to_info[l:x] = l:info
                                let l:seen[l:bufnr] = 1
                              endfor
                            
                              let l:xs = copy(a:xs)
                              let l:match_arg = get(a:data, 'cmdline.match_arg', '')
                            
                              " add matching bufnr
                              if l:match_arg =~# '\d\+'
                                for l:info in l:bufinfos
                                  let l:bufnr = l:info.bufnr
                                  let l:bufname = l:info.name
                            
                                  if !l:info.listed || empty(l:bufname) || has_key(l:seen, l:bufnr)
                                    continue
                                  endif
                            
                                  if stridx(l:bufnr, l:match_arg) == 0
                                    let l:bufname = fnamemodify(l:bufname, ':~:.')
                                    let l:x_to_info[l:bufname] = l:info
                                    call add(l:xs, l:bufname)
                                  endif
                                endfor
                              endif
                            
                              let l:current_bufnr = bufnr('%')
                            
                              return sort(l:xs, {x1, x2 -> s:sort_buffers_lastused_func(x1, x2, l:x_to_info, l:current_bufnr)})

FUNCTION  wilder#cmdline#is_user_command()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/cmdline.vim:608
Called 2 times
Total time:   0.000005
 Self time:   0.000005

count  total (s)   self (s)
    2              0.000004   return !empty(a:cmd) && a:cmd[0] >=# 'A' && a:cmd[0] <=# 'Z'

FUNCTION  <SNR>76_Remove_Matches()
    Defined: /opt/homebrew/Cellar/neovim/0.10.1/share/nvim/runtime/plugin/matchparen.vim:206
Called 4 times
Total time:   0.000038
 Self time:   0.000038

count  total (s)   self (s)
    4              0.000009   if exists('w:paren_hl_on') && w:paren_hl_on
                                while !empty(w:matchparen_ids)
                                  silent! call remove(w:matchparen_ids, 0)->matchdelete()
                                endwhile
                                let w:paren_hl_on = 0
    4              0.000001   endif

FUNCTION  <lambda>373()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/pipe/branch.vim:16
Called 1 time
Total time:   0.000019
 Self time:   0.000005

count  total (s)   self (s)
                            return s:on_finish(l:state, ctx, x)

FUNCTION  <SNR>51_prompt_update_cursor()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer/popupmenu_palette_theme.vim:423
Called 14 times
Total time:   0.000686
 Self time:   0.000125

count  total (s)   self (s)
   14              0.000057   let l:cmdpos = getcmdpos()
                            
   14              0.000024   if a:state.cmdpos != l:cmdpos
    1   0.000565   0.000003     call wilder#main#draw()
   14              0.000007   endif

FUNCTION  <lambda>74()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer/popupmenu.vim:843
Called 5 times
Total time:   0.000061
 Self time:   0.000028

count  total (s)   self (s)
                            return s:clamp(float2nr(l:percent * (&lines - 1)), a:is_height)

FUNCTION  <lambda>172()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/pipe/branch.vim:5
Called 2 times
Total time:   0.000007
 Self time:   0.000007

count  total (s)   self (s)
                            return {ctx -> s:branch(a:args, ctx, x)}

FUNCTION  wilder#main#draw()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/main.vim:412
Called 1 time
Total time:   0.000561
 Self time:   0.000007

count  total (s)   self (s)
    1              0.000001   if !s:active || !s:enabled
                                return 0
    1              0.000000   endif
                            
    1   0.000558   0.000004   call s:draw()
    1              0.000000   return 1

FUNCTION  <SNR>111_handle()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/pipeline.vim:27
Called 10 times
Total time:   0.011856
 Self time:   0.000393

count  total (s)   self (s)
   10              0.000021   let l:handler_id = get(a:ctx, 'handler_id', 0)
                            
   10              0.000016   if !has_key(s:handler_registry, l:handler_id)
                                " only show error if handler has not been cleared
                                if l:handler_id > s:last_cleared_id
                                  let l:message = 'wilder#' . a:key . '()'
                                  let l:message .= ' handler not found - id: ' . l:handler_id
                                  let l:message .= ': ' . string(a:x)
                            
                                  call s:echoerr(l:message)
                                endif
                            
                                return
   10              0.000003   endif
                            
   10              0.000007   let l:X = a:x
   10              0.000016   let l:handler = s:handler_registry[l:handler_id]
                            
   10              0.000011   if get(a:ctx, 'partial', 0)
                                if type(l:X) isnot v:t_list
                                  call l:handler.on_error(a:ctx, 'pipeline: ' . s:partial_error_message(a:key, l:X))
                                  return
                                endif
                            
                                if !has_key(s:partial_results, l:handler_id)
                                  let s:partial_results[l:handler_id] = l:X
                                else
                                  let s:partial_results[l:handler_id] += l:X
                                endif
                            
                                return
   10              0.000003   endif
                            
   10              0.000013   unlet s:handler_registry[l:handler_id]
                            
   10              0.000012   if has_key(s:partial_results, l:handler_id)
                                if type(l:X) isnot v:t_list
                                  call l:handler.on_error(a:ctx, 'pipeline: ' . s:partial_error_message(a:key, l:X))
                                  return
                                endif
                            
                                let l:X = s:partial_results[l:handler_id] + l:X
                                unlet s:partial_results[l:handler_id]
   10              0.000003   endif
                            
   10              0.000008   if a:key ==# 'reject'
                                call l:handler.on_error(a:ctx, l:X)
                                return
   10              0.000002   endif
                            
   10              0.000004   try
   10   0.011494   0.000031     call l:handler.on_finish(a:ctx, l:X)
                              catch
                                call l:handler.on_error(a:ctx, 'pipeline: ' . v:exception)
   10              0.000004   endtry

FUNCTION  <lambda>75()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer/popupmenu.vim:832
Called 7 times
Total time:   0.000035
 Self time:   0.000024

count  total (s)   self (s)
                            return s:clamp(a:opt, a:is_height)

FUNCTION  <lambda>76()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer/popupmenu.vim:845
Called 3 times
Total time:   0.000041
 Self time:   0.000023

count  total (s)   self (s)
                            return s:clamp(float2nr(l:percent * &columns), a:is_height)

FUNCTION  <lambda>77()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer/popupmenu.vim:845
Called 3 times
Total time:   0.000026
 Self time:   0.000011

count  total (s)   self (s)
                            return s:clamp(float2nr(l:percent * &columns), a:is_height)

FUNCTIONS SORTED ON TOTAL TIME
count  total (s)   self (s)  function
    4   0.068366   0.000109  <SNR>55_render_lines_from_timer()
    3   0.068258   0.007535  <SNR>55_render_lines()
 2272   0.036299   0.031809  wilder#lua#wrap()
   60   0.031994   0.000783  wilder#lua#call_wrapped_function()
    3   0.031286   0.000019  <SNR>58_show()
    1   0.031266   0.000133  <SNR>58__open_win()
   22   0.019174   0.001737  <SNR>111_run()
    3   0.015686   0.003388  <SNR>55_make_lines()
   10   0.011903   0.000047  wilder#pipeline#resolve()
   10   0.011856   0.000393  <SNR>111_handle()
    4   0.011086             <SNR>1_LoadFTPlugin()
    1   0.008881   0.000004  <lambda>204()
    4   0.008650             <SNR>96_SynSet()
   14   0.007922   0.000059  wilder#pipeline#run()
    6   0.007794   0.001131  <SNR>55_draw_columns()
    3   0.007791   0.000017  wilder#renderer#redraw()
    3   0.007774             <SNR>110_redraw()
   18   0.006663   0.001042  wilder#renderer#popupmenu#draw_column()
   10   0.006318   0.000105  <SNR>111_call()
    6   0.005786   0.000117  <SNR>64_branch()

FUNCTIONS SORTED ON SELF TIME
count  total (s)   self (s)  function
 2272   0.036299   0.031809  wilder#lua#wrap()
    4              0.011086  <SNR>1_LoadFTPlugin()
    4              0.008650  <SNR>96_SynSet()
    3              0.007774  <SNR>110_redraw()
    3   0.068258   0.007535  <SNR>55_render_lines()
    3   0.015686   0.003388  <SNR>55_make_lines()
    4              0.003105  <SNR>2_LoadIndent()
  159              0.001941  wilder#render#chunks_displaywidth()
   12   0.004589   0.001863  <SNR>55_draw_top_or_bottom_line()
   22   0.019174   0.001737  <SNR>111_run()
    6   0.007794   0.001131  <SNR>55_draw_columns()
   18   0.006663   0.001042  wilder#renderer#popupmenu#draw_column()
   53   0.001297   0.000916  wilder#render#draw_candidate()
   60   0.031994   0.000783  wilder#lua#call_wrapped_function()
   65              0.000763  <SNR>58_set_line()
   53   0.001953   0.000656  <SNR>55_draw_candidate()
    5   0.002305   0.000642  <SNR>109_draw()
   12              0.000632  <SNR>57_get_attrs_as_list()
   40   0.000696   0.000616  <SNR>110_pre_draw()
   53   0.002487   0.000534  <SNR>55_draw_candidates_chunks()

