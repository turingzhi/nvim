SCRIPT  /Users/kaizhi/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer.vim
Sourced 1 time
Total time:   0.001071
 Self time:   0.001071

count  total (s)   self (s)
    1              0.000005 function! wilder#renderer#redraw(apply_incsearch_fix) abort
                              call s:redraw(a:apply_incsearch_fix, 0)
                            endfunction
                            
    1              0.000002 function! wilder#renderer#redrawstatus(apply_incsearch_fix) abort
                              call s:redraw(a:apply_incsearch_fix, 1)
                            endfunction
                            
    1              0.000002 function! s:redraw(apply_incsearch_fix, is_redrawstatus) abort
                              if a:apply_incsearch_fix &&
                                    \ &incsearch &&
                                    \ (getcmdtype() ==# '/' || getcmdtype() ==# '?')
                                call feedkeys("\<C-R>\<BS>", 'n')
                                return
                              endif
                            
                              if a:is_redrawstatus
                                redrawstatus
                              else
                                redraw
                              endif
                            endfunction
                            
    1              0.000001 function! wilder#renderer#get_cmdheight() abort
                              if !has('nvim')
                                " For Vim, if cmdline exceeds cmdheight, the screen lines are pushed up
                                " similar to :mess, so we draw the popupmenu just above the cmdline.
                                " Lines exceeding cmdheight do not count into target line number.
                                return &cmdheight
                              endif
                            
                              let l:cmdline = getcmdline()
                            
                              " include the cmdline character
                              let l:display_width = strdisplaywidth(l:cmdline) + 1
                              let l:cmdheight = l:display_width / &columns + 1
                            
                              if l:cmdheight < &cmdheight
                                let l:cmdheight = &cmdheight
                              elseif l:cmdheight > 1
                                " Show the pum above the msgsep.
                                let l:has_msgsep = stridx(&display, 'msgsep') >= 0
                            
                                if l:has_msgsep
                                  let l:cmdheight += 1
                                endif
                              endif
                            
                              return l:cmdheight
                            endfunction
                            
    1              0.000002 function! wilder#renderer#pre_draw(components, ctx, result) abort
                              let l:should_draw = 0
                            
                              for l:Component in a:components
                                let l:should_draw += s:pre_draw(l:Component, a:ctx, a:result)
                              endfor
                            
                              return l:should_draw
                            endfunction
                            
    1              0.000001 function! s:pre_draw(component, ctx, result) abort
                              if type(a:component) isnot v:t_dict
                                return a:ctx.done
                              endif
                            
                              if has_key(a:component, 'pre_draw')
                                return a:component.pre_draw(a:ctx, a:result)
                              endif
                            
                              return a:ctx.done || get(a:component, 'dynamic', 0)
                            endfunction
                            
    1              0.000001 function! wilder#renderer#call_component_pre_hook(ctx, component) abort
                              if type(a:component) is v:t_dict &&
                                    \ has_key(a:component, 'pre_hook')
                                call a:component['pre_hook'](a:ctx)
                              endif
                            endfunction
                            
    1              0.000001 function! wilder#renderer#call_component_post_hook(ctx, component) abort
                              if type(a:component) is v:t_dict &&
                                    \ has_key(a:component, 'post_hook')
                                call a:component['post_hook'](a:ctx)
                              endif
                            endfunction

SCRIPT  /Users/kaizhi/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/pipeline.vim
Sourced 1 time
Total time:   0.000353
 Self time:   0.000353

count  total (s)   self (s)
    1              0.000004 let s:handler_registry = {}
    1              0.000001 let s:partial_results = {}
    1              0.000001 let s:id_index = 0
    1              0.000001 let s:last_cleared_id = -1
                            
    1              0.000001 function! wilder#pipeline#clear_handlers() abort
                              let s:last_cleared_id = s:id_index
                              let s:handler_registry = {}
                              let s:partial_results = {}
                            endfunction
                            
    1              0.000001 function! wilder#pipeline#resolve(ctx, x) abort
                              call s:handle(a:ctx, a:x, 'resolve')
                            endfunction
                            
    1              0.000001 function! wilder#pipeline#reject(ctx, x) abort
                              call s:handle(a:ctx, a:x, 'reject')
                            endfunction
                            
    1              0.000001 function! s:partial_error_message(key, x)
                              let l:message = 'wilder#' . a:key . '()'
                              let l:message .= ' ''partial'' only supported for lists: ' . string(a:x)
                            
                              return l:message
                            endfunction
                            
    1              0.000001 function! s:handle(ctx, x, key) abort
                              let l:handler_id = get(a:ctx, 'handler_id', 0)
                            
                              if !has_key(s:handler_registry, l:handler_id)
                                " only show error if handler has not been cleared
                                if l:handler_id > s:last_cleared_id
                                  let l:message = 'wilder#' . a:key . '()'
                                  let l:message .= ' handler not found - id: ' . l:handler_id
                                  let l:message .= ': ' . string(a:x)
                            
                                  call s:echoerr(l:message)
                                endif
                            
                                return
                              endif
                            
                              let l:X = a:x
                              let l:handler = s:handler_registry[l:handler_id]
                            
                              if get(a:ctx, 'partial', 0)
                                if type(l:X) isnot v:t_list
                                  call l:handler.on_error(a:ctx,
                                        \ 'pipeline: ' . s:partial_error_message(a:key, l:X))
                                  return
                                endif
                            
                                if !has_key(s:partial_results, l:handler_id)
                                  let s:partial_results[l:handler_id] = l:X
                                else
                                  let s:partial_results[l:handler_id] += l:X
                                endif
                            
                                return
                              endif
                            
                              unlet s:handler_registry[l:handler_id]
                            
                              if has_key(s:partial_results, l:handler_id)
                                if type(l:X) isnot v:t_list
                                  call l:handler.on_error(a:ctx,
                                        \ 'pipeline: ' . s:partial_error_message(a:key, l:X))
                                  return
                                endif
                            
                                let l:X = s:partial_results[l:handler_id] + l:X
                                unlet s:partial_results[l:handler_id]
                              endif
                            
                              if a:key ==# 'reject'
                                call l:handler.on_error(a:ctx, l:X)
                                return
                              endif
                            
                              try
                                call l:handler.on_finish(a:ctx, l:X)
                              catch
                                call l:handler.on_error(a:ctx, 'pipeline: ' . v:exception)
                              endtry
                            endfunction
                            
    1              0.000002 function! wilder#pipeline#run(pipeline, on_finish, on_error, ctx, x) abort
                              let l:pipeline = type(a:pipeline) isnot v:t_list
                                    \ ? [a:pipeline]
                                    \ : a:pipeline
                            
                              return s:run(l:pipeline, a:on_finish, a:on_error, a:ctx, a:x, 0)
                            endfunction
                            
    1              0.000001 function! s:call(f, ctx, handler_id) abort
                              let a:ctx.handler_id = a:handler_id
                            
                              try
                                call a:f(a:ctx)
                              catch
                                call wilder#reject(a:ctx, 'pipeline: ' . v:exception)
                              endtry
                            endfunction
                            
    1              0.000001 function! s:prepare_call(f, pipeline, on_finish, on_error, ctx, i)
                              let l:handler = {
                                    \ 'on_finish': {ctx, x -> s:run(a:pipeline, a:on_finish, a:on_error, ctx, x, a:i)},
                                    \ 'on_error': {ctx, x -> a:on_error(ctx, x)},
                                    \ }
                            
                              let s:id_index += 1
                              let l:handler_id = s:id_index
                              let s:handler_registry[s:id_index] = l:handler
                            
                              call timer_start(0, {_ -> s:call(a:f, a:ctx, l:handler_id)})
                            endfunction
                            
    1              0.000001 function! s:run(pipeline, on_finish, on_error, ctx, x, i) abort
                              if a:x is v:false || a:x is v:true
                                call a:on_finish(a:ctx, a:x)
                                return
                              endif
                            
                              if type(a:x) is v:t_func
                                let l:ctx = copy(a:ctx)
                                call s:prepare_call(a:x, a:pipeline, a:on_finish, a:on_error, l:ctx, a:i)
                                return
                              endif
                            
                              let l:x = a:x
                              let l:i = a:i
                            
                              while l:i < len(a:pipeline)
                                let l:F = a:pipeline[l:i]
                            
                                if type(l:F) isnot v:t_func
                                  call a:on_error(a:ctx, 'pipeline: expected function but got: ' . string(l:F))
                                  return
                                endif
                            
                                try
                                  let l:Result = l:F(a:ctx, l:x)
                                catch
                                  call a:on_error(a:ctx, 'pipeline: ' . v:exception)
                                  return
                                endtry
                            
                                if l:Result is v:false || l:Result is v:true
                                  call a:on_finish(a:ctx, l:Result)
                                  return
                                endif
                            
                                if type(l:Result) is v:t_func
                                  let l:ctx = copy(a:ctx)
                                  call s:prepare_call(l:Result, a:pipeline, a:on_finish, a:on_error, l:ctx, l:i+1)
                                  return
                                endif
                            
                                let l:x = l:Result
                                let l:i += 1
                              endwhile
                            
                              call a:on_finish(a:ctx, l:x)
                            endfunction
                            
    1              0.000001 function! wilder#pipeline#wait(f, on_finish) abort
                              let l:state = {
                                    \ 'f': a:f,
                                    \ 'on_finish': a:on_finish,
                                    \ }
                            
                              return {ctx -> s:wait_start(l:state, ctx)}
                            endfunction
                            
    1              0.000001 function! s:wait_start(state, ctx)
                              let a:state.wait_handler_id = a:ctx.handler_id
                            
                              let a:state.handler = {
                                    \ 'on_finish': {ctx, x -> s:wait_on_finish(a:state, ctx, x)},
                                    \ 'on_error': {ctx, x -> s:wait_on_error(a:state, ctx, x)},
                                    \ }
                            
                              call s:wait_call(a:state, a:ctx)
                            endfunction
                            
    1              0.000001 function! s:wait_call(state, ctx)
                              try
                                if type(a:state.f) is v:t_func
                                  let l:ctx = copy(a:ctx)
                            
                                  let s:id_index += 1
                                  let l:id_index = s:id_index
                                  let s:handler_registry[s:id_index] = a:state.handler
                            
                                  call timer_start(0, {_ -> s:call(a:state.f, l:ctx, l:id_index)})
                                else
                                  let a:ctx.handler_id = a:state.wait_handler_id
                                  call a:state.on_finish(a:ctx, a:state.f)
                                endif
                              catch
                                let a:ctx.handler_id = a:state.wait_handler_id
                                call s:wait_on_error(a:state, a:ctx, v:exception)
                              endtry
                            endfunction
                            
    1              0.000001 function! s:wait_on_finish(state, ctx, x)
                              if type(a:x) is v:t_func
                                let a:state.f = a:x
                                call s:wait_call(a:state, a:ctx)
                                return
                              endif
                            
                              let l:ctx = copy(a:ctx)
                              let l:ctx.handler_id = a:state.wait_handler_id
                            
                              try
                                call a:state.on_finish(l:ctx, a:x)
                              catch
                                call wilder#reject(l:ctx, v:exception)
                              endtry
                            endfunction
                            
    1              0.000001 function! s:wait_on_error(state, ctx, x)
                              let l:ctx = copy(a:ctx)
                              let l:ctx.handler_id = a:state.wait_handler_id
                            
                              call wilder#reject(l:ctx, a:x)
                            endfunction
                            
    1              0.000001 function! s:echoerr(message)
                              " avoid echoerr since this in a try-catch block
                              " see try-echoerr
                              echohl ErrorMsg
                              echomsg a:message
                              echohl Normal
                            endfunction

SCRIPT  /Users/kaizhi/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/cmdline/main.vim
Sourced 1 time
Total time:   0.001263
 Self time:   0.001263

count  total (s)   self (s)
    1              0.000020 let s:command_modifiers = {
                                  \ 'aboveleft': 1,
                                  \ 'argdo': 1,
                                  \ 'belowright': 1,
                                  \ 'botright': 1,
                                  \ 'browse': 1,
                                  \ 'bufdo': 1,
                                  \ 'cdo': 1,
                                  \ 'cfdo': 1,
                                  \ 'confirm': 1,
                                  \ 'debug': 1,
                                  \ 'folddoclosed': 1,
                                  \ 'folddoopen': 1,
                                  \ 'hide': 1,
                                  \ 'keepalt': 1,
                                  \ 'keepjumps': 1,
                                  \ 'keepmarks': 1,
                                  \ 'keeppatterns': 1,
                                  \ 'ldo': 1,
                                  \ 'leftabove': 1,
                                  \ 'lfdo': 1,
                                  \ 'lockmarks': 1,
                                  \ 'noautocmd': 1,
                                  \ 'noswapfile': 1,
                                  \ 'rightbelow': 1,
                                  \ 'sandbox': 1,
                                  \ 'silent': 1,
                                  \ 'tab': 1,
                                  \ 'tabdo': 1,
                                  \ 'topleft': 1,
                                  \ 'verbose': 1,
                                  \ 'vertical': 1,
                                  \ 'windo': 1,
                                  \ }
                            
    1              0.000001 function! wilder#cmdline#main#do(ctx) abort
                              " default
                              let a:ctx.expand = 'command'
                              let a:ctx.force = 0
                            
                              if empty(a:ctx.cmdline[a:ctx.pos :])
                                return
                              endif
                            
                              if !wilder#cmdline#main#skip_whitespace(a:ctx)
                                return
                              endif
                            
                              " check if comment
                              if a:ctx.cmdline[a:ctx.pos] ==# '"'
                                let a:ctx.pos = len(a:ctx.cmdline)
                                let a:ctx.expand = 'nothing'
                                return
                              endif
                            
                              " skip range
                              call wilder#cmdline#skip_range#do(a:ctx)
                            
                              if !wilder#cmdline#main#skip_whitespace(a:ctx)
                                return
                              endif
                            
                              if a:ctx.cmdline[a:ctx.pos] ==# '"'
                                let a:ctx.pos = len(a:ctx.cmdline)
                                let a:ctx.expand = 'nothing'
                                return
                              endif
                            
                              " check if starts with | or :
                              " treat as a new command
                              if a:ctx.cmdline[a:ctx.pos] ==# '|' || a:ctx.cmdline[a:ctx.pos] ==# ':'
                                let a:ctx.pos += 1
                                let a:ctx.cmd = ''
                            
                                call wilder#cmdline#main#do(a:ctx)
                            
                                return
                              endif
                            
                              let l:is_user_cmd = 0
                            
                              if a:ctx.cmdline[a:ctx.pos] ==# 'k' && a:ctx.cmdline[a:ctx.pos + 1] !=# 'e'
                                let a:ctx.cmd = 'k'
                                let a:ctx.pos += 1
                            
                                return
                              else
                                let l:cmd_start = a:ctx.pos
                            
                                let l:char = a:ctx.cmdline[a:ctx.pos]
                            
                                if l:char >=# 'A' && l:char <=# 'Z'
                                  " user-defined command can contain digits
                                  while l:char >=# 'a' && l:char <=# 'z' ||
                                        \ l:char >=# 'A' && l:char <=# 'Z' ||
                                        \ l:char >=# '0' && l:char <=# '9'
                                    let a:ctx.pos += 1
                                    let l:char = a:ctx.cmdline[a:ctx.pos]
                                  endwhile
                            
                                  let a:ctx.cmd = a:ctx.cmdline[l:cmd_start : a:ctx.pos - 1]
                                  let l:is_user_cmd = 1
                                else
                                  " non-alphabet command
                                  if stridx('@*!=><&~#', l:char) != -1
                                    let a:ctx.pos += 1
                                    let l:char = a:ctx.cmdline[a:ctx.pos]
                                  else
                                    " py3, python3, py3file and py3do are the only commands with numbers
                                    " all other commands are alphabet only
                                    if a:ctx.cmdline[a:ctx.pos] ==# 'p' &&
                                          \ a:ctx.cmdline[a:ctx.pos + 1] ==# 'y' &&
                                          \ a:ctx.cmdline[a:ctx.pos + 2] ==# '3'
                                      let a:ctx.pos += 3
                                      let l:char = a:ctx.cmdline[a:ctx.pos]
                                    endif
                            
                                    " this should check for [a-zA-Z] only, but the Vim implementation
                                    " skips over wildcards. This matters for commands which accept
                                    " non-alphanumeric arugments e.g. 'e*' would be parsed as an 'edit'
                                    " command with a '*' argument otherwise. These commands typically
                                    " don't need a space between the command and argument e.g. 'e++opt'
                                    " is a valid command.
                                    while l:char >=# 'a' && l:char <=# 'z' ||
                                          \ l:char >=# 'A' && l:char <=# 'Z' ||
                                          \ l:char ==# '*'
                                      let a:ctx.pos += 1
                                      let l:char = a:ctx.cmdline[a:ctx.pos]
                                    endwhile
                                  endif
                            
                                  if a:ctx.pos == l:cmd_start
                                    let a:ctx.expand = 'unsuccessful'
                                    return
                                  endif
                            
                                  " find the command
                                  if a:ctx.pos > l:cmd_start
                                    let l:cmd = a:ctx.cmdline[l:cmd_start : a:ctx.pos - 1]
                                    let l:len = a:ctx.pos - l:cmd_start
                            
                                    let l:char = l:cmd[0]
                                    if l:char < 'a' || l:char > 'z'
                                      let l:char = 'z'
                                    endif
                            
                                    let l:next_char = nr2char(char2nr(l:char) + 1)
                            
                                    let l:i = s:command_char_pos[l:char]
                                    let l:end = get(s:command_char_pos, 'l:next_char', len(s:commands))
                            
                                    while l:i < l:end
                                      let l:command = s:commands[l:i]
                                      if l:cmd ==# l:command[: l:len - 1]
                                        let a:ctx.cmd = l:command
                                        break
                                      endif
                            
                                      let l:i += 1
                                    endwhile
                                  endif
                                endif
                              endif
                            
                              " cursor is touching command and ends in alpha-numeric character
                              " complete the command name
                              if a:ctx.pos == len(a:ctx.cmdline)
                                let l:char = a:ctx.cmdline[a:ctx.pos - 1]
                            
                                if l:char >=# 'a' && l:char <=# 'z' ||
                                      \ l:char >=# 'A' && l:char <=# 'Z' ||
                                      \ l:char >=# '0' && l:char <=# '9'
                                  let a:ctx.pos = l:cmd_start
                                  let a:ctx.cmd = ''
                                  " expand commands
                                  return
                                endif
                              endif
                            
                              " no matching command found, treat as no arguments
                              if empty(a:ctx.cmd)
                                " 2 or 3-letter substitute command, takes no arguments
                                if a:ctx.cmdline[l:cmd_start] ==# 's' &&
                                      \ stridx('cgriI', a:ctx.cmdline[l:cmd_start + 1]) != -1
                                  let a:ctx.cmd = 's'
                                endif
                            
                                let a:ctx.pos = len(a:ctx.cmdline)
                                let a:ctx.expand = 'nothing'
                                return
                              endif
                            
                              let a:ctx.expand = 'nothing'
                            
                              " handle !
                              if a:ctx.cmdline[a:ctx.pos] ==# '!'
                                let a:ctx.pos += 1
                                let a:ctx.force = 1
                              endif
                            
                              if has_key(s:command_modifiers, a:ctx.cmd)
                                let a:ctx.cmd = ''
                                let a:ctx.expand = ''
                            
                                call wilder#cmdline#main#do(a:ctx)
                            
                                return
                              endif
                            
                              call wilder#cmdline#main#skip_whitespace(a:ctx)
                            
                              let l:flags = get(s:command_flags, a:ctx.cmd, 0)
                            
                              let l:use_filter = 0
                            
                              if a:ctx.cmd ==# 'write' || a:ctx.cmd ==# 'update'
                                if a:ctx.cmdline[a:ctx.pos] ==# '>'
                                  if a:ctx.cmdline[a:ctx.pos + 1] ==# '>'
                                    let a:ctx.pos += 2
                                  endif
                            
                                  call wilder#cmdline#main#skip_whitespace(a:ctx)
                                endif
                            
                                if a:ctx.cmd ==# 'write' && a:ctx.cmdline[a:ctx.pos] ==# '!'
                                  let a:ctx.pos += 1
                                  let l:use_filter = 1
                                endif
                              elseif a:ctx.cmd ==# 'read'
                                if a:ctx.cmdline[a:ctx.pos] ==# '!'
                                  let a:ctx.pos += 1
                                  let l:use_filter = 1
                                else
                                  let l:use_filter = a:ctx.force
                                endif
                              elseif a:ctx.cmd ==# '<' || a:ctx.cmd ==# '>'
                                while a:ctx.cmdline[a:ctx.pos] ==# a:ctx.cmd
                                  let a:ctx.pos += 1
                                endwhile
                            
                                call wilder#cmdline#main#skip_whitespace(a:ctx)
                              endif
                            
                              " Handle +cmd or ++opt
                              if a:ctx.cmdline[a:ctx.pos] ==# '+' &&
                                    \ ((and(l:flags, s:EDITCMD) && !l:use_filter) ||
                                    \ and(l:flags, s:ARGOPT))
                                let l:allow_opt = 1
                                let l:allow_cmd = and(l:flags, s:EDITCMD) && !l:use_filter
                            
                                while a:ctx.cmdline[a:ctx.pos] ==# '+' &&
                                      \ a:ctx.pos < len(a:ctx.cmdline)
                                  let a:ctx.pos += 1
                            
                                  if a:ctx.cmdline[a:ctx.pos] ==# '+'
                                    if l:allow_opt
                                      let a:ctx.pos += 1
                                      let l:expand = 'file_opt'
                                    else
                                      let l:expand = 'nothing'
                                    endif
                                  elseif l:allow_cmd
                                    let l:expand = 'command'
                                    " ++opt must be before +cmd
                                    let l:allow_opt = 0
                                    " only 1 +cmd allowed
                                    let l:allow_cmd = 0
                                  else
                                    let l:expand = 'nothing'
                                  endif
                            
                                  let l:arg_start = a:ctx.pos
                            
                                  " skip to next arg
                                  while a:ctx.pos < len(a:ctx.cmdline)
                                        \ && !wilder#cmdline#main#is_whitespace(a:ctx.cmdline[a:ctx.pos])
                                    if a:ctx.cmdline[a:ctx.pos] ==# '\' &&
                                          \ a:ctx.pos + 1 < len(a:ctx.cmdline)
                                      let a:ctx.pos += 1
                                    endif
                            
                                    " TODO: multibyte
                                    let a:ctx.pos += 1
                                  endwhile
                            
                                  " still in command or option
                                  if empty(a:ctx.cmdline[a:ctx.pos])
                                    let a:ctx.pos = l:arg_start
                                    let a:ctx.expand = l:expand
                                    return
                                  endif
                            
                                  call wilder#cmdline#main#skip_whitespace(a:ctx)
                                endwhile
                            
                                if a:ctx.cmd ==# 'write' && a:ctx.cmdline[a:ctx.pos] ==# '!'
                                  let a:ctx.pos += 1
                                  let l:use_filter = 1
                                elseif a:ctx.cmd ==# 'read'
                                  if a:ctx.cmdline[a:ctx.pos] ==# '!'
                                    let a:ctx.pos += 1
                                    let l:use_filter = 1
                                  else
                                    let l:use_filter = a:ctx.force
                                  endif
                                endif
                              endif
                            
                              " look for | for new command and " for comment
                              if and(l:flags, s:TRLBAR) && !l:use_filter
                                if a:ctx.cmd ==# 'redir' &&
                                      \ a:ctx.cmdline[a:ctx.pos] ==# '@' &&
                                      \ a:ctx.cmdline[a:ctx.pos + 1] ==# '"'
                                  let a:ctx.pos += 2
                                endif
                            
                                let l:lookahead = a:ctx.pos
                                while l:lookahead < len(a:ctx.cmdline)
                                  if a:ctx.cmdline[l:lookahead] ==# "\<C-V>" || a:ctx.cmdline[l:lookahead] ==# '\'
                                    let l:lookahead += 1
                            
                                    if l:lookahead + 1 < len(a:ctx.cmdline)
                                      let l:lookahead += 1
                                    else
                                      break
                                    endif
                                  endif
                            
                                  " Check if " indicates a comment or start of string
                                  if a:ctx.cmdline[l:lookahead] ==# '"'
                                    let l:lookahead += 1
                            
                                    let l:end_quote_reached = 0
                                    " Consume until next char is " or end of cmdline is reached
                                    while l:lookahead < len(a:ctx.cmdline)
                                      if a:ctx.cmdline[l:lookahead] ==# '\'
                                        let l:lookahead += 1
                                      elseif a:ctx.cmdline[l:lookahead] ==# '"'
                                        let l:end_quote_reached = 1
                                        let l:lookahead += 1
                                        break
                                      endif
                            
                                      let l:lookahead += 1
                                    endwhile
                            
                                    " remaining part of cmdline is comment, treat as no arguments
                                    if !l:end_quote_reached
                                      let a:ctx.pos = len(a:ctx.cmdline)
                                      return
                                    endif
                            
                                  " start of new command
                                  elseif a:ctx.cmdline[l:lookahead] ==# '|'
                                    let a:ctx.pos = l:lookahead + 1
                                    let a:ctx.cmd = ''
                                    let a:ctx.expand = ''
                            
                                    call wilder#cmdline#main#do(a:ctx)
                            
                                    return
                                  endif
                            
                                  " TODO: multibyte
                                  let l:lookahead += 1
                                endwhile
                              endif
                            
                              " command does not take extra arguments
                              if !and(l:flags, s:EXTRA) && !l:is_user_cmd
                                " consume whitespace
                                call wilder#cmdline#main#skip_whitespace(a:ctx)
                            
                                " and check for | or "
                                if a:ctx.cmdline[a:ctx.pos] ==# '|'
                                  let a:ctx.pos += 1
                                  let a:ctx.cmd = ''
                                  let a:ctx.expand = ''
                            
                                  call wilder#cmdline#main#do(a:ctx)
                                  return
                                else
                                  " remaining part is either comment or invalid arguments
                                  " either way, treat as no arguments
                                  let a:ctx.pos = len(a:ctx.cmdline)
                                  let a:ctx.expand = 'nothing'
                                  return
                                endif
                              endif
                            
                            
                              if l:use_filter || a:ctx.cmd ==# '!' || a:ctx.cmd ==# 'terminal'
                                let l:before_args = a:ctx.pos
                            
                                if !wilder#cmdline#main#skip_nonwhitespace(a:ctx)
                                  let a:ctx.pos = l:before_args
                                  let a:ctx.expand = 'shellcmd'
                                  return
                                endif
                            
                                " Reset pos back to before_args
                                let a:ctx.pos = l:before_args
                              endif
                            
                              if and(l:flags, s:XFILE)
                                " TODO: handle backticks :h backtick-expansion
                            
                                let l:arg_start = a:ctx.pos
                            
                                " Check if completing $ENV
                                if a:ctx.cmdline[a:ctx.pos] ==# '$'
                                  let l:arg_start = a:ctx.pos
                                  let a:ctx.pos += 1
                            
                                  while a:ctx.pos < len(a:ctx.cmdline)
                                    let l:char = a:ctx.cmdline[a:ctx.pos]
                                    if !s:is_idc(l:char)
                                      break
                                    endif
                            
                                    let a:ctx.pos += 1
                                  endwhile
                            
                                  if a:ctx.pos == len(a:ctx.cmdline)
                                    let a:ctx.expand = 'environment'
                                    let a:ctx.pos = l:arg_start + 1
                                    return
                                  endif
                                endif
                            
                                " Check if completing ~user
                                if a:ctx.cmdline[a:ctx.pos] ==# '~'
                                  let l:allow_backslash = has('win32') || has('win64')
                            
                                  while a:ctx.pos < len(a:ctx.cmdline)
                                    let l:char = a:ctx.cmdline[a:ctx.pos]
                                    if l:char ==# '/' ||
                                          \ l:allow_backslash && l:char ==# '\' ||
                                          \ !s:is_filec(l:char)
                                      break
                                    endif
                            
                                    let a:ctx.pos += 1
                                  endwhile
                            
                                  " + 1 since we want to expand ~ to $HOME
                                  if a:ctx.pos == len(a:ctx.cmdline) &&
                                        \ a:ctx.pos > l:arg_start + 1
                                    let a:ctx.expand = 'user'
                                    let a:ctx.pos = l:arg_start + 1
                                    return
                                  endif
                                endif
                            
                                let a:ctx.pos = l:arg_start
                                let a:ctx.expand = 'file'
                            
                                " vim assumes for XFILE, we can ignore arguments other than the last one but
                                " this is not necessarily true, we should not do this for NOSPC
                                if !and(l:flags, s:NOSPC)
                                  call s:move_pos_to_last_arg(a:ctx)
                                endif
                              endif
                            
                              if a:ctx.cmd ==# 'find' ||
                                    \ a:ctx.cmd ==# 'sfind' ||
                                    \ a:ctx.cmd ==# 'tabfind'
                                if a:ctx.expand ==# 'file'
                                  let a:ctx.expand = 'file_in_path'
                                endif
                                return
                              elseif a:ctx.cmd ==# 'cd' ||
                                    \ a:ctx.cmd ==# 'chdir' ||
                                    \ a:ctx.cmd ==# 'lcd' ||
                                    \ a:ctx.cmd ==# 'lchdir' ||
                                    \ a:ctx.cmd ==# 'tcd' ||
                                    \ a:ctx.cmd ==# 'tchdir'
                                if a:ctx.expand ==# 'file'
                                  let a:ctx.expand = 'dir'
                                endif
                                return
                              elseif a:ctx.cmd ==# 'help'
                                let a:ctx.expand = 'help'
                                return
                              " command modifiers
                              elseif has_key(s:command_modifiers, a:ctx.cmd)
                                let a:ctx.cmd = ''
                                let a:ctx.expand = ''
                            
                                call wilder#cmdline#main#do(a:ctx)
                            
                                return
                              elseif a:ctx.cmd ==# 'filter'
                                call wilder#cmdline#filter#do(a:ctx)
                                return
                              elseif a:ctx.cmd ==# 'match'
                                call wilder#cmdline#match#do(a:ctx)
                                return
                              elseif a:ctx.cmd ==# 'command'
                                call wilder#cmdline#command#do(a:ctx)
                                return
                              elseif a:ctx.cmd ==# 'delcommand'
                                let a:ctx.expand = 'user_commands'
                                return
                              elseif a:ctx.cmd ==# 'global' || a:ctx.cmd ==# 'vglobal'
                                call wilder#cmdline#global#do(a:ctx)
                                return
                              elseif a:ctx.cmd ==# '&' || a:ctx.cmd ==# 'substitute'
                                call wilder#cmdline#substitute#do(a:ctx)
                                return
                              elseif a:ctx.cmd ==# 'isearch' ||
                                    \ a:ctx.cmd ==# 'dsearch' ||
                                    \ a:ctx.cmd ==# 'ilist' ||
                                    \ a:ctx.cmd ==# 'dlist' ||
                                    \ a:ctx.cmd ==# 'ijump' ||
                                    \ a:ctx.cmd ==# 'psearch' ||
                                    \ a:ctx.cmd ==# 'djump' ||
                                    \ a:ctx.cmd ==# 'isplit' ||
                                    \ a:ctx.cmd ==# 'dsplit'
                                call wilder#cmdline#isearch#do(a:ctx)
                                return
                              elseif a:ctx.cmd ==# 'autocmd'
                                call wilder#cmdline#autocmd#do(a:ctx, 0)
                                return
                              elseif a:ctx.cmd ==# 'doautocmd' ||
                                    \ a:ctx.cmd ==# 'doautoall'
                                call wilder#cmdline#autocmd#do(a:ctx, 1)
                              elseif a:ctx.cmd ==# 'set' ||
                                    \ a:ctx.cmd ==# 'setglobal' ||
                                    \ a:ctx.cmd ==# 'setlocal'
                                call wilder#cmdline#set#do(a:ctx)
                                return
                              elseif a:ctx.cmd ==# 'tag' ||
                                    \ a:ctx.cmd ==# 'stag' ||
                                    \ a:ctx.cmd ==# 'ptag' ||
                                    \ a:ctx.cmd ==# 'ltag' ||
                                    \ a:ctx.cmd ==# 'tselect' ||
                                    \ a:ctx.cmd ==# 'stselect' ||
                                    \ a:ctx.cmd ==# 'tjump' ||
                                    \ a:ctx.cmd ==# 'stjump' ||
                                    \ a:ctx.cmd ==# 'ptselect' ||
                                    \ a:ctx.cmd ==# 'ptjump'
                                let a:ctx.expand = 'tags'
                                return
                              elseif a:ctx.cmd ==# 'augroup'
                                let a:ctx.expand = 'augroup'
                              elseif a:ctx.cmd ==# 'syntax'
                                call wilder#cmdline#syntax#do(a:ctx)
                                return
                              elseif a:ctx.cmd ==# 'let' ||
                                    \ a:ctx.cmd ==# 'if' ||
                                    \ a:ctx.cmd ==# 'elseif' ||
                                    \ a:ctx.cmd ==# 'while' ||
                                    \ a:ctx.cmd ==# 'for' ||
                                    \ a:ctx.cmd ==# 'echo' ||
                                    \ a:ctx.cmd ==# 'echon' ||
                                    \ a:ctx.cmd ==# 'execute' ||
                                    \ a:ctx.cmd ==# 'echomsg' ||
                                    \ a:ctx.cmd ==# 'echoerr' ||
                                    \ a:ctx.cmd ==# 'call' ||
                                    \ a:ctx.cmd ==# 'return' ||
                                    \ a:ctx.cmd ==# 'cexpr' ||
                                    \ a:ctx.cmd ==# 'caddexpr' ||
                                    \ a:ctx.cmd ==# 'cgetexpr' ||
                                    \ a:ctx.cmd ==# 'lexpr' ||
                                    \ a:ctx.cmd ==# 'laddexpr' ||
                                    \ a:ctx.cmd ==# 'lgetexpr'
                                "TODO call has extra arugments
                                call wilder#cmdline#let#do(a:ctx)
                                return
                              elseif a:ctx.cmd ==# 'unlet'
                                call wilder#cmdline#unlet#do(a:ctx)
                                return
                              elseif a:ctx.cmd ==# 'function'
                                let a:ctx.expand = 'function'
                                return
                              elseif a:ctx.cmd ==# 'delfunction'
                                let a:ctx.expand = 'user_func'
                                return
                              elseif a:ctx.cmd ==# 'echohl'
                                let a:ctx.expand = 'highlight'
                                " TODO: include None
                                return
                              elseif a:ctx.cmd ==# 'highlight'
                                call wilder#cmdline#highlight#do(a:ctx)
                                return
                              elseif a:ctx.cmd ==# 'cscope' ||
                                    \ a:ctx.cmd ==# 'lcscope' ||
                                    \ a:ctx.cmd ==# 'scscope'
                                call wilder#cmdline#cscope#do(a:ctx)
                                return
                              elseif a:ctx.cmd ==# 'sign'
                                call wilder#cmdline#sign#do(a:ctx)
                                return
                              elseif a:ctx.cmd ==# 'bdelete' ||
                                    \ a:ctx.cmd ==# 'bwipeout' ||
                                    \ a:ctx.cmd ==# 'bunload'
                                let a:ctx.expand = 'buffer'
                                return
                              elseif a:ctx.cmd ==# 'buffer' ||
                                    \ a:ctx.cmd ==# 'sbuffer' ||
                                    \ a:ctx.cmd ==# 'checktime'
                                let a:ctx.expand = 'buffer'
                                return
                              elseif a:ctx.cmd ==# 'abbreviate' ||
                                    \ a:ctx.cmd ==# 'unabbreviate' ||
                                    \ a:ctx.cmd[-3 :] ==# 'map' ||
                                    \ a:ctx.cmd[-6 :] ==# 'abbrev'
                                call wilder#cmdline#map#do(a:ctx)
                                return
                              elseif a:ctx.cmd[-8 :] ==# 'mapclear'
                                let a:ctx.expand = 'mapclear'
                                return
                              elseif a:ctx.cmd[-4 :] ==# 'menu'
                                call wilder#cmdline#menu#do(a:ctx)
                                return
                              elseif a:ctx.cmd ==# 'colorscheme'
                                let a:ctx.expand = 'color'
                                return
                              elseif a:ctx.cmd ==# 'compiler'
                                let a:ctx.expand = 'compiler'
                                return
                              elseif a:ctx.cmd ==# 'ownsyntax'
                                let a:ctx.expand = 'ownsyntax'
                                return
                              elseif a:ctx.cmd ==# 'packadd'
                                let a:ctx.expand = 'packadd'
                                return
                              elseif a:ctx.cmd ==# 'language'
                                let l:arg_start = a:ctx.pos
                                call wilder#cmdline#main#skip_nonwhitespace(a:ctx)
                            
                                if a:ctx.pos == len(a:ctx.cmdline)
                                  let a:ctx.expand = 'language'
                                  let a:ctx.pos = l:arg_start
                                else
                                  let l:subcommand = a:ctx.cmdline[l:arg_start : a:ctx.pos - 1]
                                  if l:subcommand ==# 'messages' ||
                                        \ l:subcommand ==# 'ctype' ||
                                        \ l:subcommand ==# 'time'
                                    let a:ctx.expand = 'locales'
                                    call wilder#cmdline#main#skip_whitespace(a:ctx)
                                  endif
                                endif
                              elseif a:ctx.cmd ==# 'profile'
                                call wilder#cmdline#profile#do(a:ctx)
                                return
                              elseif a:ctx.cmd ==# 'checkhealth'
                                let a:ctx.expand = 'checkhealth'
                                call s:move_pos_to_last_arg(a:ctx)
                                return
                              elseif a:ctx.cmd ==# 'behave'
                                let a:ctx.expand = 'behave'
                                return
                              elseif a:ctx.cmd ==# 'messages'
                                let a:ctx.expand = 'messages'
                                return
                              elseif a:ctx.cmd ==# 'history'
                                let a:ctx.expand = 'history'
                                return
                              elseif a:ctx.cmd ==# 'syntime'
                                let a:ctx.expand = 'syntime'
                                return
                              elseif a:ctx.cmd ==# 'argdelete'
                                let a:ctx.expand = 'arglist'
                                return
                              elseif a:ctx.cmd ==# 'lua'
                                let a:ctx.expand = 'lua'
                                return
                              endif
                            endfunction
                            
    1              0.000002 function! wilder#cmdline#main#has_file_args(cmd) abort
                              let l:flags = get(s:command_flags, a:cmd, 0)
                              return and(l:flags, s:XFILE)
                            endfunction
                            
    1              0.000001 function! wilder#cmdline#main#is_whitespace(char) abort
                              let l:nr = char2nr(a:char)
                              return a:char ==# ' ' || l:nr >= 9 && l:nr <= 13
                            endfunction
                            
    1              0.000001 function! wilder#cmdline#main#skip_whitespace(ctx) abort
                              if empty(a:ctx.cmdline[a:ctx.pos])
                                return 0
                              endif
                            
                              while wilder#cmdline#main#is_whitespace(a:ctx.cmdline[a:ctx.pos])
                                let a:ctx.pos += 1
                            
                                if empty(a:ctx.cmdline[a:ctx.pos])
                                  return 0
                                endif
                              endwhile
                            
                              return 1
                            endfunction
                            
    1              0.000001 function! wilder#cmdline#main#skip_nonwhitespace(ctx) abort
                              if empty(a:ctx.cmdline[a:ctx.pos])
                                return 0
                              endif
                            
                              while !wilder#cmdline#main#is_whitespace(a:ctx.cmdline[a:ctx.pos])
                                let a:ctx.pos += 1
                            
                                if empty(a:ctx.cmdline[a:ctx.pos])
                                  return 0
                                endif
                              endwhile
                            
                              return 1
                            endfunction
                            
    1              0.000001 function! wilder#cmdline#main#find_last_whitespace(ctx) abort
                              let l:arg_start = a:ctx.pos
                              let a:ctx.pos = len(a:ctx.cmdline) - 1
                              while a:ctx.pos >= l:arg_start
                                if wilder#cmdline#main#is_whitespace(a:ctx.cmdline[a:ctx.pos])
                                  let l:arg_start = a:ctx.pos + 1
                            
                                  break
                                endif
                                let a:ctx.pos -= 1
                              endwhile
                            endfunction
                            
    1              0.000001 function! s:move_pos_to_last_arg(ctx) abort
                              let l:last_arg = a:ctx.pos
                            
                              " find start of last argument
                              while a:ctx.pos < len(a:ctx.cmdline)
                                let l:char = a:ctx.cmdline[a:ctx.pos]
                            
                                if l:char ==# ' ' || l:char ==# "\t"
                                  let a:ctx.pos += 1
                                  let l:last_arg = a:ctx.pos
                                else
                                  if l:char ==# '\' && a:ctx.pos + 1 < len(a:ctx.cmdline)
                                    let a:ctx.pos += 1
                                  endif
                                  let a:ctx.pos += 1
                                endif
                              endwhile
                            
                              let a:ctx.pos = l:last_arg
                            endfunction
                            
    1              0.000001 function! s:is_filec(c) abort
                              return match(a:c, '\f') != -1
                            endfunction
                            
    1              0.000001 function! s:path_has_wildcard(c) abort
                              if has('win32') || has('win64')
                                let l:wildcards = '?*$[`'
                              else
                                let l:wildcards = "*?[{`'$"
                              endif
                            
                              return stridx(l:wildcards, a:c) != -1
                            endfunction
                            
    1              0.000001 function! s:isfilec_or_wc(c) abort
                              return s:is_filec(a:c) || a:c ==# ']' || s:path_has_wildcard(a:c)
                            endfunction
                            
    1              0.000001 function! s:is_idc(c) abort
                              return match(a:c, '\i') != -1
                            endfunction
                            
    1              0.000001 function! s:or(...) abort
                              let l:result = 0
                            
                              for l:arg in a:000
                                let l:result = or(l:result, l:arg)
                              endfor
                            
                              return l:result
                            endfunc
                            
    1              0.000002 let s:EXTRA      =    0x004
    1              0.000001 let s:XFILE      =    0x008
    1              0.000001 let s:NOSPC      =    0x010
    1              0.000001 let s:TRLBAR     =    0x100
    1              0.000001 let s:EDITCMD    =   0x8000
    1              0.000001 let s:ARGOPT     =  0x40000
                            
    1              0.000010 let s:command_char_pos = {
                                  \ 'a': 0,
                                  \ 'b': 19,
                                  \ 'c': 42,
                                  \ 'd': 104,
                                  \ 'e': 126,
                                  \ 'f': 146,
                                  \ 'g': 161,
                                  \ 'h': 167,
                                  \ 'i': 175,
                                  \ 'j': 193,
                                  \ 'k': 195,
                                  \ 'l': 200,
                                  \ 'm': 258,
                                  \ 'n': 276,
                                  \ 'o': 296,
                                  \ 'p': 307,
                                  \ 'q': 342,
                                  \ 'r': 345,
                                  \ 's': 365,
                                  \ 't': 430,
                                  \ 'u': 471,
                                  \ 'v': 482,
                                  \ 'w': 500,
                                  \ 'x': 516,
                                  \ 'y': 525,
                                  \ 'z': 526,
                                  \ '{': 527,
                                  \ }
                            
    1              0.000176 let s:commands = [
                                  \ 'append',
                                  \ 'abbreviate',
                                  \ 'abclear',
                                  \ 'aboveleft',
                                  \ 'all',
                                  \ 'amenu',
                                  \ 'anoremenu',
                                  \ 'args',
                                  \ 'argadd',
                                  \ 'argdelete',
                                  \ 'argdo',
                                  \ 'argedit',
                                  \ 'argglobal',
                                  \ 'arglocal',
                                  \ 'argument',
                                  \ 'ascii',
                                  \ 'autocmd',
                                  \ 'augroup',
                                  \ 'aunmenu',
                                  \ 'buffer',
                                  \ 'bNext',
                                  \ 'ball',
                                  \ 'badd',
                                  \ 'bdelete',
                                  \ 'behave',
                                  \ 'belowright',
                                  \ 'bfirst',
                                  \ 'blast',
                                  \ 'bmodified',
                                  \ 'bnext',
                                  \ 'botright',
                                  \ 'bprevious',
                                  \ 'brewind',
                                  \ 'break',
                                  \ 'breakadd',
                                  \ 'breakdel',
                                  \ 'breaklist',
                                  \ 'browse',
                                  \ 'buffers',
                                  \ 'bufdo',
                                  \ 'bunload',
                                  \ 'bwipeout',
                                  \ 'change',
                                  \ 'cNext',
                                  \ 'cNfile',
                                  \ 'cabbrev',
                                  \ 'cabclear',
                                  \ 'caddbuffer',
                                  \ 'caddexpr',
                                  \ 'caddfile',
                                  \ 'call',
                                  \ 'catch',
                                  \ 'cbuffer',
                                  \ 'cbottom',
                                  \ 'cc',
                                  \ 'cclose',
                                  \ 'cd',
                                  \ 'cdo',
                                  \ 'center',
                                  \ 'cexpr',
                                  \ 'cfile',
                                  \ 'cfdo',
                                  \ 'cfirst',
                                  \ 'cgetfile',
                                  \ 'cgetbuffer',
                                  \ 'cgetexpr',
                                  \ 'chdir',
                                  \ 'changes',
                                  \ 'checkhealth',
                                  \ 'checkpath',
                                  \ 'checktime',
                                  \ 'chistory',
                                  \ 'clist',
                                  \ 'clast',
                                  \ 'close',
                                  \ 'clearjumps',
                                  \ 'cmap',
                                  \ 'cmapclear',
                                  \ 'cmenu',
                                  \ 'cnext',
                                  \ 'cnewer',
                                  \ 'cnfile',
                                  \ 'cnoremap',
                                  \ 'cnoreabbrev',
                                  \ 'cnoremenu',
                                  \ 'copy',
                                  \ 'colder',
                                  \ 'colorscheme',
                                  \ 'command',
                                  \ 'comclear',
                                  \ 'compiler',
                                  \ 'continue',
                                  \ 'confirm',
                                  \ 'copen',
                                  \ 'cprevious',
                                  \ 'cpfile',
                                  \ 'cquit',
                                  \ 'crewind',
                                  \ 'cscope',
                                  \ 'cstag',
                                  \ 'cunmap',
                                  \ 'cunabbrev',
                                  \ 'cunmenu',
                                  \ 'cwindow',
                                  \ 'delete',
                                  \ 'delmarks',
                                  \ 'debug',
                                  \ 'debuggreedy',
                                  \ 'delcommand',
                                  \ 'delfunction',
                                  \ 'display',
                                  \ 'diffupdate',
                                  \ 'diffget',
                                  \ 'diffoff',
                                  \ 'diffpatch',
                                  \ 'diffput',
                                  \ 'diffsplit',
                                  \ 'diffthis',
                                  \ 'digraphs',
                                  \ 'djump',
                                  \ 'dlist',
                                  \ 'doautocmd',
                                  \ 'doautoall',
                                  \ 'drop',
                                  \ 'dsearch',
                                  \ 'dsplit',
                                  \ 'edit',
                                  \ 'earlier',
                                  \ 'echo',
                                  \ 'echoerr',
                                  \ 'echohl',
                                  \ 'echomsg',
                                  \ 'echon',
                                  \ 'else',
                                  \ 'elseif',
                                  \ 'emenu',
                                  \ 'endif',
                                  \ 'endfunction',
                                  \ 'endfor',
                                  \ 'endtry',
                                  \ 'endwhile',
                                  \ 'enew',
                                  \ 'ex',
                                  \ 'execute',
                                  \ 'exit',
                                  \ 'exusage',
                                  \ 'file',
                                  \ 'files',
                                  \ 'filetype',
                                  \ 'filter',
                                  \ 'find',
                                  \ 'finally',
                                  \ 'finish',
                                  \ 'first',
                                  \ 'fold',
                                  \ 'foldclose',
                                  \ 'folddoopen',
                                  \ 'folddoclosed',
                                  \ 'foldopen',
                                  \ 'for',
                                  \ 'function',
                                  \ 'global',
                                  \ 'goto',
                                  \ 'grep',
                                  \ 'grepadd',
                                  \ 'gui',
                                  \ 'gvim',
                                  \ 'help',
                                  \ 'helpclose',
                                  \ 'helpgrep',
                                  \ 'helptags',
                                  \ 'hardcopy',
                                  \ 'highlight',
                                  \ 'hide',
                                  \ 'history',
                                  \ 'insert',
                                  \ 'iabbrev',
                                  \ 'iabclear',
                                  \ 'if',
                                  \ 'ijump',
                                  \ 'ilist',
                                  \ 'imap',
                                  \ 'imapclear',
                                  \ 'imenu',
                                  \ 'inoremap',
                                  \ 'inoreabbrev',
                                  \ 'inoremenu',
                                  \ 'intro',
                                  \ 'isearch',
                                  \ 'isplit',
                                  \ 'iunmap',
                                  \ 'iunabbrev',
                                  \ 'iunmenu',
                                  \ 'join',
                                  \ 'jumps',
                                  \ 'k',
                                  \ 'keepmarks',
                                  \ 'keepjumps',
                                  \ 'keeppatterns',
                                  \ 'keepalt',
                                  \ 'list',
                                  \ 'lNext',
                                  \ 'lNfile',
                                  \ 'last',
                                  \ 'language',
                                  \ 'laddexpr',
                                  \ 'laddbuffer',
                                  \ 'laddfile',
                                  \ 'later',
                                  \ 'lbuffer',
                                  \ 'lbottom',
                                  \ 'lcd',
                                  \ 'lchdir',
                                  \ 'lclose',
                                  \ 'lcscope',
                                  \ 'ldo',
                                  \ 'left',
                                  \ 'leftabove',
                                  \ 'let',
                                  \ 'lexpr',
                                  \ 'lfile',
                                  \ 'lfdo',
                                  \ 'lfirst',
                                  \ 'lgetfile',
                                  \ 'lgetbuffer',
                                  \ 'lgetexpr',
                                  \ 'lgrep',
                                  \ 'lgrepadd',
                                  \ 'lhelpgrep',
                                  \ 'lhistory',
                                  \ 'll',
                                  \ 'llast',
                                  \ 'llist',
                                  \ 'lmap',
                                  \ 'lmapclear',
                                  \ 'lmake',
                                  \ 'lnoremap',
                                  \ 'lnext',
                                  \ 'lnewer',
                                  \ 'lnfile',
                                  \ 'loadview',
                                  \ 'loadkeymap',
                                  \ 'lockmarks',
                                  \ 'lockvar',
                                  \ 'lolder',
                                  \ 'lopen',
                                  \ 'lprevious',
                                  \ 'lpfile',
                                  \ 'lrewind',
                                  \ 'ltag',
                                  \ 'lunmap',
                                  \ 'lua',
                                  \ 'luado',
                                  \ 'luafile',
                                  \ 'lvimgrep',
                                  \ 'lvimgrepadd',
                                  \ 'lwindow',
                                  \ 'ls',
                                  \ 'move',
                                  \ 'mark',
                                  \ 'make',
                                  \ 'map',
                                  \ 'mapclear',
                                  \ 'marks',
                                  \ 'match',
                                  \ 'menu',
                                  \ 'menutranslate',
                                  \ 'messages',
                                  \ 'mkexrc',
                                  \ 'mksession',
                                  \ 'mkspell',
                                  \ 'mkvimrc',
                                  \ 'mkview',
                                  \ 'mode',
                                  \ 'mzscheme',
                                  \ 'mzfile',
                                  \ 'next',
                                  \ 'nbkey',
                                  \ 'nbclose',
                                  \ 'nbstart',
                                  \ 'new',
                                  \ 'nmap',
                                  \ 'nmapclear',
                                  \ 'nmenu',
                                  \ 'nnoremap',
                                  \ 'nnoremenu',
                                  \ 'noremap',
                                  \ 'noautocmd',
                                  \ 'nohlsearch',
                                  \ 'noreabbrev',
                                  \ 'noremenu',
                                  \ 'noswapfile',
                                  \ 'normal',
                                  \ 'number',
                                  \ 'nunmap',
                                  \ 'nunmenu',
                                  \ 'oldfiles',
                                  \ 'omap',
                                  \ 'omapclear',
                                  \ 'omenu',
                                  \ 'only',
                                  \ 'onoremap',
                                  \ 'onoremenu',
                                  \ 'options',
                                  \ 'ounmap',
                                  \ 'ounmenu',
                                  \ 'ownsyntax',
                                  \ 'print',
                                  \ 'packadd',
                                  \ 'packloadall',
                                  \ 'pclose',
                                  \ 'perl',
                                  \ 'perldo',
                                  \ 'pedit',
                                  \ 'pop',
                                  \ 'popup',
                                  \ 'ppop',
                                  \ 'preserve',
                                  \ 'previous',
                                  \ 'promptfind',
                                  \ 'promptrepl',
                                  \ 'profile',
                                  \ 'profdel',
                                  \ 'psearch',
                                  \ 'ptag',
                                  \ 'ptNext',
                                  \ 'ptfirst',
                                  \ 'ptjump',
                                  \ 'ptlast',
                                  \ 'ptnext',
                                  \ 'ptprevious',
                                  \ 'ptrewind',
                                  \ 'ptselect',
                                  \ 'put',
                                  \ 'pwd',
                                  \ 'python',
                                  \ 'pydo',
                                  \ 'pyfile',
                                  \ 'py3',
                                  \ 'py3do',
                                  \ 'python3',
                                  \ 'py3file',
                                  \ 'quit',
                                  \ 'quitall',
                                  \ 'qall',
                                  \ 'read',
                                  \ 'recover',
                                  \ 'redo',
                                  \ 'redir',
                                  \ 'redraw',
                                  \ 'redrawstatus',
                                  \ 'registers',
                                  \ 'resize',
                                  \ 'retab',
                                  \ 'return',
                                  \ 'rewind',
                                  \ 'right',
                                  \ 'rightbelow',
                                  \ 'rshada',
                                  \ 'runtime',
                                  \ 'rundo',
                                  \ 'ruby',
                                  \ 'rubydo',
                                  \ 'rubyfile',
                                  \ 'rviminfo',
                                  \ 'substitute',
                                  \ 'sNext',
                                  \ 'sargument',
                                  \ 'sall',
                                  \ 'sandbox',
                                  \ 'saveas',
                                  \ 'sbuffer',
                                  \ 'sbNext',
                                  \ 'sball',
                                  \ 'sbfirst',
                                  \ 'sblast',
                                  \ 'sbmodified',
                                  \ 'sbnext',
                                  \ 'sbprevious',
                                  \ 'sbrewind',
                                  \ 'scriptnames',
                                  \ 'scriptencoding',
                                  \ 'scscope',
                                  \ 'set',
                                  \ 'setfiletype',
                                  \ 'setglobal',
                                  \ 'setlocal',
                                  \ 'sfind',
                                  \ 'sfirst',
                                  \ 'simalt',
                                  \ 'sign',
                                  \ 'silent',
                                  \ 'sleep',
                                  \ 'slast',
                                  \ 'smagic',
                                  \ 'smap',
                                  \ 'smapclear',
                                  \ 'smenu',
                                  \ 'snext',
                                  \ 'snomagic',
                                  \ 'snoremap',
                                  \ 'snoremenu',
                                  \ 'source',
                                  \ 'sort',
                                  \ 'split',
                                  \ 'spellgood',
                                  \ 'spelldump',
                                  \ 'spellinfo',
                                  \ 'spellrepall',
                                  \ 'spellundo',
                                  \ 'spellwrong',
                                  \ 'sprevious',
                                  \ 'srewind',
                                  \ 'stop',
                                  \ 'stag',
                                  \ 'startinsert',
                                  \ 'startgreplace',
                                  \ 'startreplace',
                                  \ 'stopinsert',
                                  \ 'stjump',
                                  \ 'stselect',
                                  \ 'sunhide',
                                  \ 'sunmap',
                                  \ 'sunmenu',
                                  \ 'suspend',
                                  \ 'sview',
                                  \ 'swapname',
                                  \ 'syntax',
                                  \ 'syntime',
                                  \ 'syncbind',
                                  \ 't',
                                  \ 'tcd',
                                  \ 'tchdir',
                                  \ 'tNext',
                                  \ 'tag',
                                  \ 'tags',
                                  \ 'tab',
                                  \ 'tabclose',
                                  \ 'tabdo',
                                  \ 'tabedit',
                                  \ 'tabfind',
                                  \ 'tabfirst',
                                  \ 'tabmove',
                                  \ 'tablast',
                                  \ 'tabnext',
                                  \ 'tabnew',
                                  \ 'tabonly',
                                  \ 'tabprevious',
                                  \ 'tabNext',
                                  \ 'tabrewind',
                                  \ 'tabs',
                                  \ 'tcl',
                                  \ 'tcldo',
                                  \ 'tclfile',
                                  \ 'terminal',
                                  \ 'tfirst',
                                  \ 'throw',
                                  \ 'tjump',
                                  \ 'tlast',
                                  \ 'tmap',
                                  \ 'tmapclear',
                                  \ 'tmenu',
                                  \ 'tnext',
                                  \ 'tnoremap',
                                  \ 'topleft',
                                  \ 'tprevious',
                                  \ 'trewind',
                                  \ 'try',
                                  \ 'tselect',
                                  \ 'tunmap',
                                  \ 'tunmenu',
                                  \ 'undo',
                                  \ 'undojoin',
                                  \ 'undolist',
                                  \ 'unabbreviate',
                                  \ 'unhide',
                                  \ 'unlet',
                                  \ 'unlockvar',
                                  \ 'unmap',
                                  \ 'unmenu',
                                  \ 'unsilent',
                                  \ 'update',
                                  \ 'vglobal',
                                  \ 'version',
                                  \ 'verbose',
                                  \ 'vertical',
                                  \ 'visual',
                                  \ 'view',
                                  \ 'vimgrep',
                                  \ 'vimgrepadd',
                                  \ 'viusage',
                                  \ 'vmap',
                                  \ 'vmapclear',
                                  \ 'vmenu',
                                  \ 'vnoremap',
                                  \ 'vnew',
                                  \ 'vnoremenu',
                                  \ 'vsplit',
                                  \ 'vunmap',
                                  \ 'vunmenu',
                                  \ 'write',
                                  \ 'wNext',
                                  \ 'wall',
                                  \ 'while',
                                  \ 'winsize',
                                  \ 'wincmd',
                                  \ 'windo',
                                  \ 'winpos',
                                  \ 'wnext',
                                  \ 'wprevious',
                                  \ 'wq',
                                  \ 'wqall',
                                  \ 'wsverb',
                                  \ 'wshada',
                                  \ 'wundo',
                                  \ 'wviminfo',
                                  \ 'xit',
                                  \ 'xall',
                                  \ 'xmap',
                                  \ 'xmapclear',
                                  \ 'xmenu',
                                  \ 'xnoremap',
                                  \ 'xnoremenu',
                                  \ 'xunmap',
                                  \ 'xunmenu',
                                  \ 'yank',
                                  \ 'z',
                                  \ '!',
                                  \ '#',
                                  \ '&',
                                  \ '<',
                                  \ ':',
                                  \ '>',
                                  \ '@',
                                  \ 'Next',
                                  \ '~',
                                  \ ]
                            
    1              0.000248 let s:command_flags = {
                                  \ 'append': 3150083,
                                  \ 'abbreviate': 1059076,
                                  \ 'abclear': 1048836,
                                  \ 'aboveleft': 2180,
                                  \ 'all': 17667,
                                  \ 'amenu': 1079557,
                                  \ 'anoremenu': 1079557,
                                  \ 'args': 295182,
                                  \ 'argadd': 20751,
                                  \ 'argdelete': 16655,
                                  \ 'argdo': 18599,
                                  \ 'argedit': 315791,
                                  \ 'argglobal': 295182,
                                  \ 'arglocal': 295182,
                                  \ 'argument': 312583,
                                  \ 'ascii': 1573120,
                                  \ 'autocmd': 1058822,
                                  \ 'augroup': 1048854,
                                  \ 'aunmenu': 1059076,
                                  \ 'buffer': 247047,
                                  \ 'bNext': 50435,
                                  \ 'ball': 17665,
                                  \ 'badd': 1081756,
                                  \ 'bdelete': 83207,
                                  \ 'behave': 1048980,
                                  \ 'belowright': 2180,
                                  \ 'bfirst': 49411,
                                  \ 'blast': 49411,
                                  \ 'bmodified': 50435,
                                  \ 'bnext': 50435,
                                  \ 'botright': 2180,
                                  \ 'bprevious': 50435,
                                  \ 'brewind': 49411,
                                  \ 'break': 1573120,
                                  \ 'breakadd': 1048836,
                                  \ 'breakdel': 1048836,
                                  \ 'breaklist': 1048836,
                                  \ 'browse': 1050756,
                                  \ 'buffers': 1048838,
                                  \ 'bufdo': 18599,
                                  \ 'bunload': 83207,
                                  \ 'bwipeout': 214279,
                                  \ 'change': 3147075,
                                  \ 'cNext': 17667,
                                  \ 'cNfile': 17667,
                                  \ 'cabbrev': 1059076,
                                  \ 'cabclear': 1048836,
                                  \ 'caddbuffer': 16661,
                                  \ 'caddexpr': 2452,
                                  \ 'caddfile': 284,
                                  \ 'call': 1575045,
                                  \ 'catch': 1572868,
                                  \ 'cbuffer': 16663,
                                  \ 'cbottom': 256,
                                  \ 'cc': 17667,
                                  \ 'cclose': 17665,
                                  \ 'cd': 1048862,
                                  \ 'cdo': 18599,
                                  \ 'center': 3146053,
                                  \ 'cexpr': 2454,
                                  \ 'cfile': 286,
                                  \ 'cfdo': 18599,
                                  \ 'cfirst': 17667,
                                  \ 'cgetfile': 284,
                                  \ 'cgetbuffer': 16661,
                                  \ 'cgetexpr': 2452,
                                  \ 'chdir': 1048862,
                                  \ 'changes': 1048832,
                                  \ 'checkhealth': 260,
                                  \ 'checkpath': 1048834,
                                  \ 'checktime': 83205,
                                  \ 'chistory': 256,
                                  \ 'clist': 1048838,
                                  \ 'clast': 17667,
                                  \ 'close': 1066243,
                                  \ 'clearjumps': 1048832,
                                  \ 'cmap': 1059076,
                                  \ 'cmapclear': 1048836,
                                  \ 'cmenu': 1079557,
                                  \ 'cnext': 17667,
                                  \ 'cnewer': 17665,
                                  \ 'cnfile': 17667,
                                  \ 'cnoremap': 1059076,
                                  \ 'cnoreabbrev': 1059076,
                                  \ 'cnoremenu': 1079557,
                                  \ 'copy': 3146053,
                                  \ 'colder': 17665,
                                  \ 'colorscheme': 1048852,
                                  \ 'command': 1058822,
                                  \ 'comclear': 1048832,
                                  \ 'compiler': 1048854,
                                  \ 'continue': 1573120,
                                  \ 'confirm': 1050756,
                                  \ 'copen': 17665,
                                  \ 'cprevious': 17667,
                                  \ 'cpfile': 17667,
                                  \ 'cquit': 21763,
                                  \ 'crewind': 17667,
                                  \ 'cscope': 2060,
                                  \ 'cstag': 278,
                                  \ 'cunmap': 1059076,
                                  \ 'cunabbrev': 1059076,
                                  \ 'cunmenu': 1059076,
                                  \ 'cwindow': 17665,
                                  \ 'delete': 3147585,
                                  \ 'delmarks': 1048838,
                                  \ 'debug': 1575044,
                                  \ 'debuggreedy': 1069313,
                                  \ 'delcommand': 1048982,
                                  \ 'delfunction': 1048726,
                                  \ 'display': 1575172,
                                  \ 'diffupdate': 258,
                                  \ 'diffget': 2097413,
                                  \ 'diffoff': 258,
                                  \ 'diffpatch': 2097436,
                                  \ 'diffput': 261,
                                  \ 'diffsplit': 284,
                                  \ 'diffthis': 256,
                                  \ 'digraphs': 1048836,
                                  \ 'djump': 103,
                                  \ 'dlist': 1048679,
                                  \ 'doautocmd': 1048836,
                                  \ 'doautoall': 1048836,
                                  \ 'drop': 295308,
                                  \ 'dsearch': 1048679,
                                  \ 'dsplit': 103,
                                  \ 'edit': 295198,
                                  \ 'earlier': 1048852,
                                  \ 'echo': 1574916,
                                  \ 'echoerr': 1574916,
                                  \ 'echohl': 1573124,
                                  \ 'echomsg': 1574916,
                                  \ 'echon': 1574916,
                                  \ 'else': 1573120,
                                  \ 'elseif': 1574916,
                                  \ 'emenu': 1067397,
                                  \ 'endif': 1573120,
                                  \ 'endfunction': 1048832,
                                  \ 'endfor': 1573120,
                                  \ 'endtry': 1573120,
                                  \ 'endwhile': 1573120,
                                  \ 'enew': 258,
                                  \ 'ex': 295198,
                                  \ 'execute': 1574916,
                                  \ 'exit': 1311103,
                                  \ 'exusage': 256,
                                  \ 'file': 20767,
                                  \ 'files': 1048838,
                                  \ 'filetype': 1048836,
                                  \ 'filter': 2182,
                                  \ 'find': 311583,
                                  \ 'finally': 1573120,
                                  \ 'finish': 1573120,
                                  \ 'first': 295174,
                                  \ 'fold': 1573185,
                                  \ 'foldclose': 1573187,
                                  \ 'folddoopen': 2213,
                                  \ 'folddoclosed': 2213,
                                  \ 'foldopen': 1573187,
                                  \ 'for': 1574916,
                                  \ 'function': 1048582,
                                  \ 'global': 1572967,
                                  \ 'goto': 1590529,
                                  \ 'grep': 18831,
                                  \ 'grepadd': 18831,
                                  \ 'gui': 1343758,
                                  \ 'gvim': 1343758,
                                  \ 'help': 2054,
                                  \ 'helpclose': 17665,
                                  \ 'helpgrep': 2180,
                                  \ 'helptags': 1048972,
                                  \ 'hardcopy': 1319,
                                  \ 'highlight': 1573126,
                                  \ 'hide': 17671,
                                  \ 'history': 1048836,
                                  \ 'insert': 3145987,
                                  \ 'iabbrev': 1059076,
                                  \ 'iabclear': 1048836,
                                  \ 'if': 1574916,
                                  \ 'ijump': 103,
                                  \ 'ilist': 1048679,
                                  \ 'imap': 1059076,
                                  \ 'imapclear': 1048836,
                                  \ 'imenu': 1079557,
                                  \ 'inoremap': 1059076,
                                  \ 'inoreabbrev': 1059076,
                                  \ 'inoremenu': 1079557,
                                  \ 'intro': 1048832,
                                  \ 'isearch': 1048679,
                                  \ 'isplit': 103,
                                  \ 'iunmap': 1059076,
                                  \ 'iunabbrev': 1059076,
                                  \ 'iunmenu': 1059076,
                                  \ 'join': 7341379,
                                  \ 'jumps': 1048832,
                                  \ 'k': 1573141,
                                  \ 'keepmarks': 2180,
                                  \ 'keepjumps': 2180,
                                  \ 'keeppatterns': 2180,
                                  \ 'keepalt': 2180,
                                  \ 'list': 5244225,
                                  \ 'lNext': 17667,
                                  \ 'lNfile': 17667,
                                  \ 'last': 295174,
                                  \ 'language': 1048836,
                                  \ 'laddexpr': 2452,
                                  \ 'laddbuffer': 16661,
                                  \ 'laddfile': 284,
                                  \ 'later': 1048852,
                                  \ 'lbuffer': 16663,
                                  \ 'lbottom': 256,
                                  \ 'lcd': 1048862,
                                  \ 'lchdir': 1048862,
                                  \ 'lclose': 17665,
                                  \ 'lcscope': 2060,
                                  \ 'ldo': 18599,
                                  \ 'left': 3146053,
                                  \ 'leftabove': 2180,
                                  \ 'let': 1574916,
                                  \ 'lexpr': 2454,
                                  \ 'lfile': 286,
                                  \ 'lfdo': 18599,
                                  \ 'lfirst': 17667,
                                  \ 'lgetfile': 284,
                                  \ 'lgetbuffer': 16661,
                                  \ 'lgetexpr': 2452,
                                  \ 'lgrep': 18831,
                                  \ 'lgrepadd': 18831,
                                  \ 'lhelpgrep': 2180,
                                  \ 'lhistory': 256,
                                  \ 'll': 17667,
                                  \ 'llast': 17667,
                                  \ 'llist': 1048838,
                                  \ 'lmap': 1059076,
                                  \ 'lmapclear': 1048836,
                                  \ 'lmake': 2318,
                                  \ 'lnoremap': 1059076,
                                  \ 'lnext': 17667,
                                  \ 'lnewer': 17665,
                                  \ 'lnfile': 17667,
                                  \ 'loadview': 284,
                                  \ 'loadkeymap': 1048576,
                                  \ 'lockmarks': 2180,
                                  \ 'lockvar': 1572998,
                                  \ 'lolder': 17665,
                                  \ 'lopen': 17665,
                                  \ 'lprevious': 17667,
                                  \ 'lpfile': 17667,
                                  \ 'lrewind': 17667,
                                  \ 'ltag': 16662,
                                  \ 'lunmap': 1059076,
                                  \ 'lua': 1048709,
                                  \ 'luado': 1048741,
                                  \ 'luafile': 1048733,
                                  \ 'lvimgrep': 18831,
                                  \ 'lvimgrepadd': 18831,
                                  \ 'lwindow': 17665,
                                  \ 'ls': 1048838,
                                  \ 'move': 3146053,
                                  \ 'mark': 1573141,
                                  \ 'make': 2318,
                                  \ 'map': 1059078,
                                  \ 'mapclear': 1048838,
                                  \ 'marks': 1048836,
                                  \ 'match': 1064965,
                                  \ 'menu': 1079559,
                                  \ 'menutranslate': 1059076,
                                  \ 'messages': 1048837,
                                  \ 'mkexrc': 1048862,
                                  \ 'mksession': 286,
                                  \ 'mkspell': 2446,
                                  \ 'mkvimrc': 1048862,
                                  \ 'mkview': 286,
                                  \ 'mode': 1048852,
                                  \ 'mzscheme': 1573029,
                                  \ 'mzfile': 1048733,
                                  \ 'next': 311567,
                                  \ 'nbkey': 16516,
                                  \ 'nbclose': 1048832,
                                  \ 'nbstart': 1048852,
                                  \ 'new': 311583,
                                  \ 'nmap': 1059076,
                                  \ 'nmapclear': 1048836,
                                  \ 'nmenu': 1079557,
                                  \ 'nnoremap': 1059076,
                                  \ 'nnoremenu': 1079557,
                                  \ 'noremap': 1059078,
                                  \ 'noautocmd': 2180,
                                  \ 'nohlsearch': 1573120,
                                  \ 'noreabbrev': 1059076,
                                  \ 'noremenu': 1079559,
                                  \ 'noswapfile': 2180,
                                  \ 'normal': 1583239,
                                  \ 'number': 5244225,
                                  \ 'nunmap': 1059076,
                                  \ 'nunmenu': 1059076,
                                  \ 'oldfiles': 1573122,
                                  \ 'omap': 1059076,
                                  \ 'omapclear': 1048836,
                                  \ 'omenu': 1079557,
                                  \ 'only': 17667,
                                  \ 'onoremap': 1059076,
                                  \ 'onoremenu': 1079557,
                                  \ 'options': 256,
                                  \ 'ounmap': 1059076,
                                  \ 'ounmenu': 1059076,
                                  \ 'ownsyntax': 1574916,
                                  \ 'print': 5768513,
                                  \ 'packadd': 1573278,
                                  \ 'packloadall': 1573122,
                                  \ 'pclose': 258,
                                  \ 'perl': 1573029,
                                  \ 'perldo': 1048741,
                                  \ 'pedit': 295198,
                                  \ 'pop': 21763,
                                  \ 'popup': 1051014,
                                  \ 'ppop': 21763,
                                  \ 'preserve': 256,
                                  \ 'previous': 312583,
                                  \ 'promptfind': 1050628,
                                  \ 'promptrepl': 1050628,
                                  \ 'profile': 1048838,
                                  \ 'profdel': 1048836,
                                  \ 'psearch': 103,
                                  \ 'ptag': 20759,
                                  \ 'ptNext': 20739,
                                  \ 'ptfirst': 20739,
                                  \ 'ptjump': 278,
                                  \ 'ptlast': 258,
                                  \ 'ptnext': 20739,
                                  \ 'ptprevious': 20739,
                                  \ 'ptrewind': 20739,
                                  \ 'ptselect': 278,
                                  \ 'put': 3150659,
                                  \ 'pwd': 1048832,
                                  \ 'python': 1048709,
                                  \ 'pydo': 1048741,
                                  \ 'pyfile': 1048733,
                                  \ 'py3': 1048709,
                                  \ 'py3do': 1048741,
                                  \ 'python3': 1048709,
                                  \ 'py3file': 1048733,
                                  \ 'quit': 1066243,
                                  \ 'quitall': 258,
                                  \ 'qall': 1048834,
                                  \ 'read': 3412319,
                                  \ 'recover': 286,
                                  \ 'redo': 1048832,
                                  \ 'redir': 1048846,
                                  \ 'redraw': 1048834,
                                  \ 'redrawstatus': 1048834,
                                  \ 'registers': 1050884,
                                  \ 'resize': 1065237,
                                  \ 'retab': 3146103,
                                  \ 'return': 1574916,
                                  \ 'rewind': 295174,
                                  \ 'right': 3146053,
                                  \ 'rightbelow': 2180,
                                  \ 'rshada': 1048862,
                                  \ 'runtime': 1573262,
                                  \ 'rundo': 156,
                                  \ 'ruby': 1048709,
                                  \ 'rubydo': 1048741,
                                  \ 'rubyfile': 1048733,
                                  \ 'rviminfo': 1048862,
                                  \ 'substitute': 1048645,
                                  \ 'sNext': 312583,
                                  \ 'sargument': 312583,
                                  \ 'sall': 17667,
                                  \ 'sandbox': 2180,
                                  \ 'saveas': 1311038,
                                  \ 'sbuffer': 247047,
                                  \ 'sbNext': 50433,
                                  \ 'sball': 50433,
                                  \ 'sbfirst': 33024,
                                  \ 'sblast': 33024,
                                  \ 'sbmodified': 50433,
                                  \ 'sbnext': 50433,
                                  \ 'sbprevious': 50433,
                                  \ 'sbrewind': 33024,
                                  \ 'scriptnames': 1048832,
                                  \ 'scriptencoding': 1048852,
                                  \ 'scscope': 2052,
                                  \ 'set': 1573124,
                                  \ 'setfiletype': 1048964,
                                  \ 'setglobal': 1573124,
                                  \ 'setlocal': 1573124,
                                  \ 'sfind': 311583,
                                  \ 'sfirst': 295174,
                                  \ 'simalt': 1048980,
                                  \ 'sign': 1065093,
                                  \ 'silent': 1575046,
                                  \ 'sleep': 1066245,
                                  \ 'slast': 295174,
                                  \ 'smagic': 1048645,
                                  \ 'smap': 1059076,
                                  \ 'smapclear': 1048836,
                                  \ 'smenu': 1079557,
                                  \ 'snext': 311567,
                                  \ 'snomagic': 1048645,
                                  \ 'snoremap': 1059076,
                                  \ 'snoremenu': 1079557,
                                  \ 'source': 1573150,
                                  \ 'sort': 2099303,
                                  \ 'split': 311583,
                                  \ 'spellgood': 16775,
                                  \ 'spelldump': 258,
                                  \ 'spellinfo': 256,
                                  \ 'spellrepall': 256,
                                  \ 'spellundo': 16775,
                                  \ 'spellwrong': 16775,
                                  \ 'sprevious': 312583,
                                  \ 'srewind': 295174,
                                  \ 'stop': 1048834,
                                  \ 'stag': 20759,
                                  \ 'startinsert': 1048834,
                                  \ 'startgreplace': 1048834,
                                  \ 'startreplace': 1048834,
                                  \ 'stopinsert': 1048834,
                                  \ 'stjump': 278,
                                  \ 'stselect': 278,
                                  \ 'sunhide': 17665,
                                  \ 'sunmap': 1059076,
                                  \ 'sunmenu': 1059076,
                                  \ 'suspend': 1048834,
                                  \ 'sview': 311583,
                                  \ 'swapname': 1048832,
                                  \ 'syntax': 1050628,
                                  \ 'syntime': 1048980,
                                  \ 'syncbind': 256,
                                  \ 't': 3146053,
                                  \ 'tcd': 1048862,
                                  \ 'tchdir': 1048862,
                                  \ 'tNext': 20739,
                                  \ 'tag': 20759,
                                  \ 'tags': 1048832,
                                  \ 'tab': 2180,
                                  \ 'tabclose': 1069335,
                                  \ 'tabdo': 18597,
                                  \ 'tabedit': 315679,
                                  \ 'tabfind': 315807,
                                  \ 'tabfirst': 256,
                                  \ 'tabmove': 20757,
                                  \ 'tablast': 256,
                                  \ 'tabnext': 20757,
                                  \ 'tabnew': 315679,
                                  \ 'tabonly': 1069335,
                                  \ 'tabprevious': 20757,
                                  \ 'tabNext': 20757,
                                  \ 'tabrewind': 256,
                                  \ 'tabs': 1048832,
                                  \ 'tcl': 1048709,
                                  \ 'tcldo': 1048741,
                                  \ 'tclfile': 1048733,
                                  \ 'terminal': 1048590,
                                  \ 'tfirst': 20739,
                                  \ 'throw': 1572996,
                                  \ 'tjump': 278,
                                  \ 'tlast': 258,
                                  \ 'tmap': 1059076,
                                  \ 'tmapclear': 1048836,
                                  \ 'tmenu': 1079557,
                                  \ 'tnext': 20739,
                                  \ 'tnoremap': 1059076,
                                  \ 'topleft': 2180,
                                  \ 'tprevious': 20739,
                                  \ 'trewind': 20739,
                                  \ 'try': 1573120,
                                  \ 'tselect': 278,
                                  \ 'tunmap': 1059076,
                                  \ 'tunmenu': 1059076,
                                  \ 'undo': 1070337,
                                  \ 'undojoin': 1048832,
                                  \ 'undolist': 1048832,
                                  \ 'unabbreviate': 1059076,
                                  \ 'unhide': 17665,
                                  \ 'unlet': 1572998,
                                  \ 'unlockvar': 1572998,
                                  \ 'unmap': 1059078,
                                  \ 'unmenu': 1059078,
                                  \ 'unsilent': 1575044,
                                  \ 'update': 262527,
                                  \ 'vglobal': 1048677,
                                  \ 'version': 1048836,
                                  \ 'verbose': 1591429,
                                  \ 'vertical': 2180,
                                  \ 'visual': 295198,
                                  \ 'view': 295198,
                                  \ 'vimgrep': 18831,
                                  \ 'vimgrepadd': 18831,
                                  \ 'viusage': 256,
                                  \ 'vmap': 1059076,
                                  \ 'vmapclear': 1048836,
                                  \ 'vmenu': 1079557,
                                  \ 'vnoremap': 1059076,
                                  \ 'vnew': 311583,
                                  \ 'vnoremenu': 1079557,
                                  \ 'vsplit': 311583,
                                  \ 'vunmap': 1059076,
                                  \ 'vunmenu': 1059076,
                                  \ 'write': 1311103,
                                  \ 'wNext': 278879,
                                  \ 'wall': 1048834,
                                  \ 'while': 1574916,
                                  \ 'winsize': 388,
                                  \ 'wincmd': 1065109,
                                  \ 'windo': 18597,
                                  \ 'winpos': 1048836,
                                  \ 'wnext': 278815,
                                  \ 'wprevious': 278815,
                                  \ 'wq': 262527,
                                  \ 'wqall': 262462,
                                  \ 'wsverb': 16516,
                                  \ 'wshada': 1048862,
                                  \ 'wundo': 158,
                                  \ 'wviminfo': 1048862,
                                  \ 'xit': 1311103,
                                  \ 'xall': 258,
                                  \ 'xmap': 1059076,
                                  \ 'xmapclear': 1048836,
                                  \ 'xmenu': 1079557,
                                  \ 'xnoremap': 1059076,
                                  \ 'xnoremenu': 1079557,
                                  \ 'xunmap': 1059076,
                                  \ 'xunmenu': 1059076,
                                  \ 'yank': 1050433,
                                  \ 'z': 5243205,
                                  \ '!': 1048655,
                                  \ '#': 5244225,
                                  \ '&': 3145797,
                                  \ '<': 7341377,
                                  \ ':': 5243169,
                                  \ '>': 7341377,
                                  \ '@': 1048901,
                                  \ 'Next': 312583,
                                  \ '~': 3145797,
                                  \ }

SCRIPT  /Users/kaizhi/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/cmdline/skip_range.vim
Sourced 1 time
Total time:   0.000993
 Self time:   0.000993

count  total (s)   self (s)
    1              0.000004 let s:chars = " \t0123456789.$%'/?-+,;\\"
                            
    1              0.000003 function! wilder#cmdline#skip_range#do(ctx) abort
                              while a:ctx.pos < len(a:ctx.cmdline) &&
                                    \ stridx(s:chars, a:ctx.cmdline[a:ctx.pos]) != -1
                                let l:char = a:ctx.cmdline[a:ctx.pos]
                                if l:char ==# '\'
                                  if a:ctx.pos + 1 >= len(a:ctx.cmdline)
                                    return 1
                                  endif
                            
                                  let l:second_char = a:ctx.cmdline[a:ctx.pos + 1]
                            
                                  if l:second_char ==# '?' ||
                                        \ l:second_char ==# '/' ||
                                        \ l:second_char ==# '&'
                                    let a:ctx.pos += 2
                                  else
                                    return 1
                                  endif
                                elseif l:char ==# "'"
                                  let a:ctx.pos += 1
                                elseif l:char ==# '/' || l:char ==# '?'
                                  let l:delim = l:char
                                  let a:ctx.pos += 1
                            
                                  while a:ctx.pos < len(a:ctx.cmdline) && a:ctx.cmdline[a:ctx.pos] !=# l:delim
                                    if a:ctx.cmdline[a:ctx.pos] ==# '\' &&
                                          \ a:ctx.pos + 1 < len (a:ctx.cmdline)
                                      let a:ctx.pos += 1
                                    endif
                            
                                    let a:ctx.pos += 1
                                  endwhile
                            
                                  if a:ctx.pos == len(a:ctx.cmdline)
                                    return
                                  endif
                                endif
                            
                                let a:ctx.pos += 1
                              endwhile
                            endfunc

SCRIPT  /Users/kaizhi/.local/share/nvim/lazy/any-jump.vim/autoload/lang_map.vim
Sourced 1 time
Total time:   0.004175
 Self time:   0.003254

count  total (s)   self (s)
                            " NOTES:
                            " - all language regexps ported from https://github.com/jacktasia/dumb-jump/blob/master/dumb-jump.el
                            
    1              0.000004 let s:definitions = {}
                            
                            " map any-language to concrete internal s:definitions[language]
    1              0.000005 let s:filetypes_proxy = {
                              \"javascriptreact": "javascript",
                              \"c": "cpp",
                              \}
                            
    1              0.000004 fu! s:add_definition(lang, definition) abort
                              if !has_key(s:definitions, a:lang)
                                let s:definitions[a:lang] = []
                              endif
                            
                              call add(s:definitions[a:lang], a:definition)
                            endfu
                            
    1              0.000002 fu! lang_map#find_definitions(language) abort
                              if !lang_map#lang_exists(a:language)
                                return
                              endif
                            
                              return s:definitions[a:language]
                            endfu
                            
    1              0.000001 fu! lang_map#definitions() abort
                              return s:definitions
                            endfu
                            
    1              0.000001 fu! lang_map#lang_exists(language) abort
                              return has_key(s:definitions, a:language)
                            endfu
                            
    1              0.000001 fu! lang_map#get_language_from_filetype(ft) abort
                              if has_key(s:filetypes_proxy, a:ft)
                                let maybe_lan = s:filetypes_proxy[a:ft]
                              else
                                let maybe_lan = a:ft
                              endif
                            
                              if lang_map#lang_exists(maybe_lan)
                                return maybe_lan
                              else
                                return 0
                              endif
                            endfu
                            
    1   0.000029   0.000018 call s:add_definition('elisp', {
                            	\"type": 'function',
                            	\"pcre2_regexp": '\((defun|cl-defun)\s+KEYWORD($|[^a-zA-Z0-9\?\*-])',
                            	\"emacs_regexp": '\((defun|cl-defun)\s+JJJ\j',
                            	\"supports": ["ag", "grep", "rg", "git-grep"],
                            	\"spec_success": ["(defun test (blah)","(defun test\n","(cl-defun test (blah)","(cl-defun test\n"],
                            	\"spec_failed": ["(defun test-asdf (blah)","(defun test-blah\n","(cl-defun test-asdf (blah)","(cl-defun test-blah\n","(defun tester (blah)","(defun test? (blah)","(defun test- (blah)"],
                            	\})
                            
    1   0.000020   0.000015 call s:add_definition('elisp', {
                            	\"type": 'function',
                            	\"pcre2_regexp": '\(defmacro\s+KEYWORD($|[^a-zA-Z0-9\?\*-])',
                            	\"emacs_regexp": '\(defmacro\s+JJJ\j',
                            	\"supports": ["ag", "grep", "rg", "git-grep"],
                            	\"spec_success": ["(defmacro test (blah)","(defmacro test\n"],
                            	\"spec_failed": ["(defmacro test-asdf (blah)","(defmacro test-blah\n","(defmacro tester (blah)","(defmacro test? (blah)","(defmacro test- (blah)"],
                            	\})
                            
    1   0.000016   0.000011 call s:add_definition('elisp', {
                            	\"type": 'variable',
                            	\"pcre2_regexp": '\(defvar\b\s*KEYWORD($|[^a-zA-Z0-9\?\*-])',
                            	\"emacs_regexp": '\(defvar\b\s*JJJ\j',
                            	\"supports": ["ag", "grep", "rg", "git-grep"],
                            	\"spec_success": ["(defvar test ","(defvar test\n"],
                            	\"spec_failed": ["(defvar tester","(defvar test?","(defvar test-"],
                            	\})
                            
    1   0.000015   0.000011 call s:add_definition('elisp', {
                            	\"type": 'variable',
                            	\"pcre2_regexp": '\(defcustom\b\s*KEYWORD($|[^a-zA-Z0-9\?\*-])',
                            	\"emacs_regexp": '\(defcustom\b\s*JJJ\j',
                            	\"supports": ["ag", "grep", "rg", "git-grep"],
                            	\"spec_success": ["(defcustom test ","(defcustom test\n"],
                            	\"spec_failed": ["(defcustom tester","(defcustom test?","(defcustom test-"],
                            	\})
                            
    1   0.000015   0.000010 call s:add_definition('elisp', {
                            	\"type": 'variable',
                            	\"pcre2_regexp": '\(setq\b\s*KEYWORD($|[^a-zA-Z0-9\?\*-])',
                            	\"emacs_regexp": '\(setq\b\s*JJJ\j',
                            	\"supports": ["ag", "grep", "rg", "git-grep"],
                            	\"spec_success": ["(setq test 123)"],
                            	\"spec_failed": ["setq test-blah 123)","(setq tester","(setq test?","(setq test-"],
                            	\})
                            
    1   0.000013   0.000009 call s:add_definition('elisp', {
                            	\"type": 'variable',
                            	\"pcre2_regexp": '\(KEYWORD\s+',
                            	\"emacs_regexp": '\(JJJ\s+',
                            	\"supports": ["ag", "grep", "rg", "git-grep"],
                            	\"spec_success": ["(let ((test 123)))"],
                            	\"spec_failed": ["(let ((test-2 123)))"],
                            	\})
                            
    1   0.000015   0.000011 call s:add_definition('elisp', {
                            	\"type": 'variable',
                            	\"pcre2_regexp": '\((defun|cl-defun)\s*.+\(?\s*KEYWORD($|[^a-zA-Z0-9\?\*-])\s*\)?',
                            	\"emacs_regexp": '\((defun|cl-defun)\s*.+\(?\s*JJJ\j\s*\)?',
                            	\"supports": ["ag", "rg", "git-grep"],
                            	\"spec_success": ["(defun blah (test)","(defun blah (test blah)","(defun (blah test)"],
                            	\"spec_failed": ["(defun blah (test-1)","(defun blah (test-2 blah)","(defun (blah test-3)"],
                            	\})
                            
    1   0.000015   0.000010 call s:add_definition('commonlisp', {
                            	\"type": 'function',
                            	\"pcre2_regexp": '\(defun\s+KEYWORD($|[^a-zA-Z0-9\?\*-])',
                            	\"emacs_regexp": '\(defun\s+JJJ\j',
                            	\"supports": ["ag", "grep", "rg", "git-grep"],
                            	\"spec_success": ["(defun test (blah)","(defun test\n"],
                            	\"spec_failed": ["(defun test-asdf (blah)","(defun test-blah\n","(defun tester (blah)","(defun test? (blah)","(defun test- (blah)"],
                            	\})
                            
    1   0.000014   0.000010 call s:add_definition('commonlisp', {
                            	\"type": 'variable',
                            	\"pcre2_regexp": '\(defparameter\b\s*KEYWORD($|[^a-zA-Z0-9\?\*-])',
                            	\"emacs_regexp": '\(defparameter\b\s*JJJ\j',
                            	\"supports": ["ag", "grep", "rg", "git-grep"],
                            	\"spec_success": ["(defparameter test ","(defparameter test\n"],
                            	\"spec_failed": ["(defparameter tester","(defparameter test?","(defparameter test-"],
                            	\})
                            
    1   0.000014   0.000010 call s:add_definition('racket', {
                            	\"type": 'function',
                            	\"pcre2_regexp": '\(define\s+\(\s*KEYWORD($|[^a-zA-Z0-9\?\*-])',
                            	\"emacs_regexp": '\(define\s+\(\s*JJJ\j',
                            	\"supports": ["ag", "grep", "rg", "git-grep"],
                            	\"spec_success": ["(define (test blah)","(define (test\n"],
                            	\"spec_failed": ["(define test blah","(define (test-asdf blah)","(define test (lambda (blah"],
                            	\})
                            
    1   0.000018   0.000014 call s:add_definition('racket', {
                            	\"type": 'function',
                            	\"pcre2_regexp": '\(define\s+KEYWORD\s*\(\s*lambda',
                            	\"emacs_regexp": '\(define\s+JJJ\s*\(\s*lambda',
                            	\"supports": ["ag", "grep", "rg", "git-grep"],
                            	\"spec_success": ["(define test (lambda (blah","(define test (lambda\n"],
                            	\"spec_failed": ["(define test blah","(define test-asdf (lambda (blah)","(define (test)","(define (test blah) (lambda (foo"],
                            	\})
                            
    1   0.000013   0.000009 call s:add_definition('racket', {
                            	\"type": 'function',
                            	\"pcre2_regexp": '\(let\s+KEYWORD\s*(\(|\[)*',
                            	\"emacs_regexp": '\(let\s+JJJ\s*(\(|\[)*',
                            	\"supports": ["ag", "grep", "rg", "git-grep"],
                            	\"spec_success": ["(let test ((blah foo) (bar bas))","(let test\n","(let test [(foo"],
                            	\"spec_failed": ["(let ((test blah"],
                            	\})
                            
    1   0.000012   0.000009 call s:add_definition('racket', {
                            	\"type": 'variable',
                            	\"pcre2_regexp": '\(define\s+KEYWORD($|[^a-zA-Z0-9\?\*-])',
                            	\"emacs_regexp": '\(define\s+JJJ\j',
                            	\"supports": ["ag", "grep", "rg", "git-grep"],
                            	\"spec_success": ["(define test ","(define test\n"],
                            	\"spec_failed": ["(define (test"],
                            	\})
                            
    1   0.000013   0.000009 call s:add_definition('racket', {
                            	\"type": 'variable',
                            	\"pcre2_regexp": '(\(|\[)\s*KEYWORD\s+',
                            	\"emacs_regexp": '(\(|\[)\s*JJJ\s+',
                            	\"supports": ["ag", "grep", "rg", "git-grep"],
                            	\"spec_success": ["(let ((test 'foo","(let [(test 'foo","(let [(test 'foo","(let [[test 'foo","(let ((blah 'foo) (test 'bar)"],
                            	\"spec_failed": ["{test foo"],
                            	\})
                            
    1   0.000014   0.000010 call s:add_definition('racket', {
                            	\"type": 'variable',
                            	\"pcre2_regexp": '\(lambda\s+\(?[^()]*\s*KEYWORD($|[^a-zA-Z0-9\?\*-])\s*\)?',
                            	\"emacs_regexp": '\(lambda\s+\(?[^()]*\s*JJJ\j\s*\)?',
                            	\"supports": ["ag", "grep", "rg", "git-grep"],
                            	\"spec_success": ["(lambda (test)","(lambda (foo test)","(lambda test (foo)"],
                            	\"spec_failed": ["(lambda () test"],
                            	\})
                            
    1   0.000013   0.000010 call s:add_definition('racket', {
                            	\"type": 'variable',
                            	\"pcre2_regexp": '\(define\s+\([^()]+\s*KEYWORD($|[^a-zA-Z0-9\?\*-])\s*\)?',
                            	\"emacs_regexp": '\(define\s+\([^()]+\s*JJJ\j\s*\)?',
                            	\"supports": ["ag", "grep", "rg", "git-grep"],
                            	\"spec_success": ["(define (foo test)","(define (foo test bar)"],
                            	\"spec_failed": ["(define foo test","(define (test foo","(define (test)"],
                            	\})
                            
    1   0.000019   0.000008 call s:add_definition('racket', {
                            	\"type": 'type',
                            	\"pcre2_regexp": '\(struct\s+KEYWORD($|[^a-zA-Z0-9\?\*-])',
                            	\"emacs_regexp": '\(struct\s+JJJ\j',
                            	\"supports": ["ag", "grep", "rg", "git-grep"],
                            	\"spec_success": ["(struct test (a b)"],
                            	\"spec_failed": [],
                            	\})
                            
    1   0.000014   0.000010 call s:add_definition('scheme', {
                            	\"type": 'function',
                            	\"pcre2_regexp": '\(define\s+\(\s*KEYWORD($|[^a-zA-Z0-9\?\*-])',
                            	\"emacs_regexp": '\(define\s+\(\s*JJJ\j',
                            	\"supports": ["ag", "grep", "rg", "git-grep"],
                            	\"spec_success": ["(define (test blah)","(define (test\n"],
                            	\"spec_failed": ["(define test blah","(define (test-asdf blah)","(define test (lambda (blah"],
                            	\})
                            
    1   0.000014   0.000010 call s:add_definition('scheme', {
                            	\"type": 'function',
                            	\"pcre2_regexp": '\(define\s+KEYWORD\s*\(\s*lambda',
                            	\"emacs_regexp": '\(define\s+JJJ\s*\(\s*lambda',
                            	\"supports": ["ag", "grep", "rg", "git-grep"],
                            	\"spec_success": ["(define test (lambda (blah","(define test (lambda\n"],
                            	\"spec_failed": ["(define test blah","(define test-asdf (lambda (blah)","(define (test)","(define (test blah) (lambda (foo"],
                            	\})
                            
    1   0.000014   0.000011 call s:add_definition('scheme', {
                            	\"type": 'function',
                            	\"pcre2_regexp": '\(let\s+KEYWORD\s*(\(|\[)*',
                            	\"emacs_regexp": '\(let\s+JJJ\s*(\(|\[)*',
                            	\"supports": ["ag", "grep", "rg", "git-grep"],
                            	\"spec_success": ["(let test ((blah foo) (bar bas))","(let test\n","(let test [(foo"],
                            	\"spec_failed": ["(let ((test blah"],
                            	\})
                            
    1   0.000012   0.000008 call s:add_definition('scheme', {
                            	\"type": 'variable',
                            	\"pcre2_regexp": '\(define\s+KEYWORD($|[^a-zA-Z0-9\?\*-])',
                            	\"emacs_regexp": '\(define\s+JJJ\j',
                            	\"supports": ["ag", "grep", "rg", "git-grep"],
                            	\"spec_success": ["(define test ","(define test\n"],
                            	\"spec_failed": ["(define (test"],
                            	\})
                            
    1   0.000013   0.000009 call s:add_definition('scheme', {
                            	\"type": 'variable',
                            	\"pcre2_regexp": '(\(|\[)\s*KEYWORD\s+',
                            	\"emacs_regexp": '(\(|\[)\s*JJJ\s+',
                            	\"supports": ["ag", "grep", "rg", "git-grep"],
                            	\"spec_success": ["(let ((test 'foo","(let [(test 'foo","(let [(test 'foo","(let [[test 'foo","(let ((blah 'foo) (test 'bar)"],
                            	\"spec_failed": ["{test foo"],
                            	\})
                            
    1   0.000013   0.000009 call s:add_definition('scheme', {
                            	\"type": 'variable',
                            	\"pcre2_regexp": '\(lambda\s+\(?[^()]*\s*KEYWORD($|[^a-zA-Z0-9\?\*-])\s*\)?',
                            	\"emacs_regexp": '\(lambda\s+\(?[^()]*\s*JJJ\j\s*\)?',
                            	\"supports": ["ag", "grep", "rg", "git-grep"],
                            	\"spec_success": ["(lambda (test)","(lambda (foo test)","(lambda test (foo)"],
                            	\"spec_failed": ["(lambda () test"],
                            	\})
                            
    1   0.000021   0.000017 call s:add_definition('scheme', {
                            	\"type": 'variable',
                            	\"pcre2_regexp": '\(define\s+\([^()]+\s*KEYWORD($|[^a-zA-Z0-9\?\*-])\s*\)?',
                            	\"emacs_regexp": '\(define\s+\([^()]+\s*JJJ\j\s*\)?',
                            	\"supports": ["ag", "grep", "rg", "git-grep"],
                            	\"spec_success": ["(define (foo test)","(define (foo test bar)"],
                            	\"spec_failed": ["(define foo test","(define (test foo","(define (test)"],
                            	\})
                            
    1   0.000019   0.000015 call s:add_definition('cpp', {
                            	\"type": 'function',
                            	\"pcre2_regexp": '\bKEYWORD(\s|\))*\((\w|[,&*.<>:]|\s)*(\))\s*(const|->|\{|$)|typedef\s+(\w|[(*]|\s)+KEYWORD(\)|\s)*\(',
                            	\"emacs_regexp": '\bJJJ(\s|\))*\((\w|[,&*.<>:]|\s)*(\))\s*(const|->|\{|$)|typedef\s+(\w|[(*]|\s)+JJJ(\)|\s)*\(',
                            	\"supports": ["ag", "rg", "git-grep"],
                            	\"spec_success": ["int test(){","my_struct (*test)(int a, int b){","auto MyClass::test ( Builder::Builder& reference, ) -> decltype( builder.func() ) {","int test( int *random_argument) const {","test::test() {","typedef int (*test)(int);"],
                            	\"spec_failed": ["return test();)","int test(a, b);","if( test() ) {","else test();"],
                            	\})
                            
    1   0.000015   0.000011 call s:add_definition('cpp', {
                            	\"type": 'variable',
                            	\"pcre2_regexp": '(\b\w+|[,>])([*&]|\s)+KEYWORD\s*(\[([0-9]|\s)*\])*\s*([=,){;]|:\s*[0-9])|#define\s+KEYWORD\b',
                            	\"emacs_regexp": '(\b\w+|[,>])([*&]|\s)+JJJ\s*(\[([0-9]|\s)*\])*\s*([=,){;]|:\s*[0-9])|#define\s+JJJ\b',
                            	\"supports": ["grep"],
                            	\"spec_success": ["int test=2;","char *test;","int x = 1, test = 2","int test[20];","#define test","unsigned int test:2;"],
                            	\"spec_failed": [],
                            	\})
                            
    1   0.000018   0.000014 call s:add_definition('cpp', {
                            	\"type": 'variable',
                            	\"pcre2_regexp": '\b(?!(class\b|struct\b|return\b|else\b|delete\b))(\w+|[,>])([*&]|\s)+KEYWORD\s*(\[(\d|\s)*\])*\s*([=,(){;]|:\s*\d)|#define\s+KEYWORD\b',
                            	\"emacs_regexp": '\b(?!(class\b|struct\b|return\b|else\b|delete\b))(\w+|[,>])([*&]|\s)+JJJ\s*(\[(\d|\s)*\])*\s*([=,(){;]|:\s*\d)|#define\s+JJJ\b',
                            	\"supports": ["ag", "rg"],
                            	\"spec_success": ["int test=2;","char *test;","int x = 1, test = 2","int test[20];","#define test","typedef int test;","unsigned int test:2"],
                            	\"spec_failed": ["return test;","#define NOT test","else test=2;"],
                            	\})
                            
    1   0.000018   0.000014 call s:add_definition('cpp', {
                            	\"type": 'type',
                            	\"pcre2_regexp": '\b(class|struct|enum|union)\b\s*KEYWORD\b\s*(final\s*)?(:((\s*\w+\s*::)*\s*\w*\s*<?(\s*\w+\s*::)*\w+>?\s*,*)+)?((\{|$))|}\s*KEYWORD\b\s*;',
                            	\"emacs_regexp": '\b(class|struct|enum|union)\b\s*JJJ\b\s*(final\s*)?(:((\s*\w+\s*::)*\s*\w*\s*<?(\s*\w+\s*::)*\w+>?\s*,*)+)?((\{|$))|}\s*JJJ\b\s*;',
                            	\"supports": ["ag", "rg", "git-grep"],
                            	\"spec_success": ["typedef struct test {","enum test {","} test;","union test {","class test final: public Parent1, private Parent2{","class test : public std::vector<int> {"],
                            	\"spec_failed": ["union test var;","struct test function() {"],
                            	\})
                            
    1   0.000017   0.000013 call s:add_definition('clojure', {
                            	\"type": 'variable',
                            	\"pcre2_regexp": '\(def\s+KEYWORD($|[^a-zA-Z0-9\?\*-])',
                            	\"emacs_regexp": '\(def\s+JJJ\j',
                            	\"supports": ["ag", "grep", "rg", "git-grep"],
                            	\"spec_success": ["(def test (foo)"],
                            	\"spec_failed": [],
                            	\})
                            
    1   0.000015   0.000011 call s:add_definition('clojure', {
                            	\"type": 'function',
                            	\"pcre2_regexp": '\(defn-?\s+KEYWORD($|[^a-zA-Z0-9\?\*-])',
                            	\"emacs_regexp": '\(defn-?\s+JJJ\j',
                            	\"supports": ["ag", "grep", "rg", "git-grep"],
                            	\"spec_success": ["(defn test [foo]","(defn- test [foo]"],
                            	\"spec_failed": ["(defn test? [foo]","(defn- test? [foo]"],
                            	\})
                            
    1   0.000013   0.000009 call s:add_definition('clojure', {
                            	\"type": 'function',
                            	\"pcre2_regexp": '\(defmacro\s+KEYWORD($|[^a-zA-Z0-9\?\*-])',
                            	\"emacs_regexp": '\(defmacro\s+JJJ\j',
                            	\"supports": ["ag", "grep", "rg", "git-grep"],
                            	\"spec_success": ["(defmacro test [foo]"],
                            	\"spec_failed": [],
                            	\})
                            
    1   0.000014   0.000011 call s:add_definition('clojure', {
                            	\"type": 'function',
                            	\"pcre2_regexp": '\(deftask\s+KEYWORD($|[^a-zA-Z0-9\?\*-])',
                            	\"emacs_regexp": '\(deftask\s+JJJ\j',
                            	\"supports": ["ag", "grep", "rg", "git-grep"],
                            	\"spec_success": ["(deftask test [foo]"],
                            	\"spec_failed": [],
                            	\})
                            
    1   0.000012   0.000008 call s:add_definition('clojure', {
                            	\"type": 'type',
                            	\"pcre2_regexp": '\(deftype\s+KEYWORD($|[^a-zA-Z0-9\?\*-])',
                            	\"emacs_regexp": '\(deftype\s+JJJ\j',
                            	\"supports": ["ag", "grep", "rg", "git-grep"],
                            	\"spec_success": ["(deftype test [foo]"],
                            	\"spec_failed": [],
                            	\})
                            
    1   0.000011   0.000008 call s:add_definition('clojure', {
                            	\"type": 'type',
                            	\"pcre2_regexp": '\(defmulti\s+KEYWORD($|[^a-zA-Z0-9\?\*-])',
                            	\"emacs_regexp": '\(defmulti\s+JJJ\j',
                            	\"supports": ["ag", "grep", "rg", "git-grep"],
                            	\"spec_success": ["(defmulti test fn"],
                            	\"spec_failed": [],
                            	\})
                            
    1   0.000011   0.000008 call s:add_definition('clojure', {
                            	\"type": 'type',
                            	\"pcre2_regexp": '\(defmethod\s+KEYWORD($|[^a-zA-Z0-9\?\*-])',
                            	\"emacs_regexp": '\(defmethod\s+JJJ\j',
                            	\"supports": ["ag", "grep", "rg", "git-grep"],
                            	\"spec_success": ["(defmethod test type"],
                            	\"spec_failed": [],
                            	\})
                            
    1   0.000012   0.000008 call s:add_definition('clojure', {
                            	\"type": 'type',
                            	\"pcre2_regexp": '\(definterface\s+KEYWORD($|[^a-zA-Z0-9\?\*-])',
                            	\"emacs_regexp": '\(definterface\s+JJJ\j',
                            	\"supports": ["ag", "grep", "rg", "git-grep"],
                            	\"spec_success": ["(definterface test (foo)"],
                            	\"spec_failed": [],
                            	\})
                            
    1   0.000012   0.000008 call s:add_definition('clojure', {
                            	\"type": 'type',
                            	\"pcre2_regexp": '\(defprotocol\s+KEYWORD($|[^a-zA-Z0-9\?\*-])',
                            	\"emacs_regexp": '\(defprotocol\s+JJJ\j',
                            	\"supports": ["ag", "grep", "rg", "git-grep"],
                            	\"spec_success": ["(defprotocol test (foo)"],
                            	\"spec_failed": [],
                            	\})
                            
    1   0.000013   0.000009 call s:add_definition('clojure', {
                            	\"type": 'type',
                            	\"pcre2_regexp": '\(defrecord\s+KEYWORD($|[^a-zA-Z0-9\?\*-])',
                            	\"emacs_regexp": '\(defrecord\s+JJJ\j',
                            	\"supports": ["ag", "grep", "rg", "git-grep"],
                            	\"spec_success": ["(defrecord test [foo]"],
                            	\"spec_failed": [],
                            	\})
                            
    1   0.000015   0.000010 call s:add_definition('coffeescript', {
                            	\"type": 'function',
                            	\"pcre2_regexp": '^\s*KEYWORD\s*[=:].*[-=]>',
                            	\"emacs_regexp": '^\s*JJJ\s*[=:].*[-=]>',
                            	\"supports": ["ag", "grep", "rg", "git-grep"],
                            	\"spec_success": ["test = ()  =>","test= =>","test = ->","test=()->","test : ()  =>","test: =>","test : ->","test:()->"],
                            	\"spec_failed": ["# test = =>","test = 1"],
                            	\})
                            
    1   0.000013   0.000010 call s:add_definition('coffeescript', {
                            	\"type": 'variable',
                            	\"pcre2_regexp": '^\s*KEYWORD\s*[:=][^:=-][^>]+$',
                            	\"emacs_regexp": '^\s*JJJ\s*[:=][^:=-][^>]+$',
                            	\"supports": ["ag", "grep", "rg", "git-grep"],
                            	\"spec_success": ["test = $","test : [","test = {","test = a"],
                            	\"spec_failed": ["test::a","test: =>","test == 1","# test = 1"],
                            	\})
                            
    1   0.000013   0.000009 call s:add_definition('coffeescript', {
                            	\"type": 'class',
                            	\"pcre2_regexp": '^\s*\bclass\s+KEYWORD',
                            	\"emacs_regexp": '^\s*\bclass\s+JJJ',
                            	\"supports": ["ag", "grep", "rg", "git-grep"],
                            	\"spec_success": ["class test","class test extends"],
                            	\"spec_failed": ["# class"],
                            	\})
                            
    1   0.000021   0.000016 call s:add_definition('objc', {
                            	\"type": 'function',
                            	\"pcre2_regexp": '\)\s*KEYWORD(:|\b|\s)',
                            	\"emacs_regexp": '\)\s*JJJ(:|\b|\s)',
                            	\"supports": ["ag", "grep", "rg", "git-grep"],
                            	\"spec_success": ["- (void)test","- (void)test:(UIAlertView *)alertView"],
                            	\"spec_failed": ["- (void)testnot","- (void)testnot:(UIAlertView *)alertView"],
                            	\})
                            
    1   0.000279   0.000274 call s:add_definition('objc', {
                            	\"type": 'variable',
                            	\"pcre2_regexp": '\b\*?KEYWORD\s*=[^=\n]+',
                            	\"emacs_regexp": '\b\*?JJJ\s*=[^=\n]+',
                            	\"supports": ["ag", "grep", "rg", "git-grep"],
                            	\"spec_success": ["NSString *test = @\"asdf\""],
                            	\"spec_failed": ["NSString *testnot = @\"asdf\"","NSString *nottest = @\"asdf\""],
                            	\})
                            
    1   0.000013   0.000009 call s:add_definition('objc', {
                            	\"type": 'type',
                            	\"pcre2_regexp": '(@interface|@protocol|@implementation)\b\s*KEYWORD\b\s*',
                            	\"emacs_regexp": '(@interface|@protocol|@implementation)\b\s*JJJ\b\s*',
                            	\"supports": ["ag", "grep", "rg", "git-grep"],
                            	\"spec_success": ["@interface test: UIWindow"],
                            	\"spec_failed": ["@interface testnon: UIWindow"],
                            	\})
                            
    1   0.000013   0.000010 call s:add_definition('objc', {
                            	\"type": 'type',
                            	\"pcre2_regexp": 'typedef\b\s+(NS_OPTIONS|NS_ENUM)\b\([^,]+?,\s*KEYWORD\b\s*',
                            	\"emacs_regexp": 'typedef\b\s+(NS_OPTIONS|NS_ENUM)\b\([^,]+?,\s*JJJ\b\s*',
                            	\"supports": ["ag", "grep", "rg", "git-grep"],
                            	\"spec_success": ["typedef NS_ENUM(NSUInteger, test)"],
                            	\"spec_failed": ["typedef NS_ENUMD(NSUInteger, test)"],
                            	\})
                            
    1   0.000014   0.000009 call s:add_definition('swift', {
                            	\"type": 'variable',
                            	\"pcre2_regexp": '(let|var)\s*KEYWORD\s*(=|:)[^=:\n]+',
                            	\"emacs_regexp": '(let|var)\s*JJJ\s*(=|:)[^=:\n]+',
                            	\"supports": ["ag", "grep", "rg", "git-grep"],
                            	\"spec_success": ["let test = 1234","var test = 1234","private lazy var test: UITapGestureRecognizer"],
                            	\"spec_failed": ["if test == 1234:"],
                            	\})
                            
    1   0.000013   0.000009 call s:add_definition('swift', {
                            	\"type": 'function',
                            	\"pcre2_regexp": 'func\s+KEYWORD\b\s*(<[^>]*>)?\s*\(',
                            	\"emacs_regexp": 'func\s+JJJ\b\s*(<[^>]*>)?\s*\(',
                            	\"supports": ["ag", "grep", "rg", "git-grep"],
                            	\"spec_success": ["func test(asdf)","func test()","func test<Value: Protocol>()"],
                            	\"spec_failed": ["func testnot(asdf)","func testnot()"],
                            	\})
                            
    1   0.000015   0.000012 call s:add_definition('swift', {
                            	\"type": 'type',
                            	\"pcre2_regexp": '(class|struct|protocol|enum)\s+KEYWORD\b\s*?',
                            	\"emacs_regexp": '(class|struct|protocol|enum)\s+JJJ\b\s*?',
                            	\"supports": ["ag", "grep", "rg", "git-grep"],
                            	\"spec_success": ["struct test","struct test: Codable","struct test<Value: Codable>","class test:","class test: UIWindow","class test<Value: Codable>"],
                            	\"spec_failed": ["class testnot:","class testnot(object):","struct testnot(object)"],
                            	\})
                            
    1   0.000012   0.000008 call s:add_definition('swift', {
                            	\"type": 'type',
                            	\"pcre2_regexp": '(typealias)\s+KEYWORD\b\s*?=',
                            	\"emacs_regexp": '(typealias)\s+JJJ\b\s*?=',
                            	\"supports": ["ag", "grep", "rg", "git-grep"],
                            	\"spec_success": ["typealias test ="],
                            	\"spec_failed": ["typealias testnot"],
                            	\})
                            
    1   0.000015   0.000011 call s:add_definition('csharp', {
                            	\"type": 'function',
                            	\"pcre2_regexp": '^\s*(?:[\w\[\]]+\s+){1,3}KEYWORD\s*\(',
                            	\"emacs_regexp": '^\s*(?:[\w\[\]]+\s+){1,3}JJJ\s*\(',
                            	\"supports": ["ag", "rg"],
                            	\"spec_success": ["int test()","int test(param)","static int test()","static int test(param)","public static MyType test()","private virtual SomeType test(param)","static int test()"],
                            	\"spec_failed": ["test()","testnot()","blah = new test()"],
                            	\})
                            
    1   0.000012   0.000009 call s:add_definition('csharp', {
                            	\"type": 'variable',
                            	\"pcre2_regexp": '\s*\bKEYWORD\s*=[^=\n)]+',
                            	\"emacs_regexp": '\s*\bJJJ\s*=[^=\n)]+',
                            	\"supports": ["ag", "grep", "rg", "git-grep"],
                            	\"spec_success": ["int test = 1234"],
                            	\"spec_failed": ["if test == 1234:","int nottest = 44"],
                            	\})
                            
    1   0.000013   0.000009 call s:add_definition('csharp', {
                            	\"type": 'type',
                            	\"pcre2_regexp": '(class|interface)\s*KEYWORD\b',
                            	\"emacs_regexp": '(class|interface)\s*JJJ\b',
                            	\"supports": ["ag", "grep", "rg", "git-grep"],
                            	\"spec_success": ["class test:","public class test : IReadableChannel, I"],
                            	\"spec_failed": ["class testnot:","public class testnot : IReadableChannel, I"],
                            	\})
                            
    1   0.000016   0.000012 call s:add_definition('java', {
                            	\"type": 'function',
                            	\"pcre2_regexp": '^\s*(?:[\w\[\]]+\s+){1,3}KEYWORD\s*\(',
                            	\"emacs_regexp": '^\s*(?:[\w\[\]]+\s+){1,3}JJJ\s*\(',
                            	\"supports": ["ag", "rg"],
                            	\"spec_success": ["int test()","int test(param)","static int test()","static int test(param)","public static MyType test()","private virtual SomeType test(param)","static int test()","private foo[] test()"],
                            	\"spec_failed": ["test()","testnot()","blah = new test()","foo bar = test()"],
                            	\})
                            
    1   0.000015   0.000011 call s:add_definition('java', {
                            	\"type": 'variable',
                            	\"pcre2_regexp": '\s*\bKEYWORD\s*=[^=\n)]+',
                            	\"emacs_regexp": '\s*\bJJJ\s*=[^=\n)]+',
                            	\"supports": ["ag", "grep", "rg", "git-grep"],
                            	\"spec_success": ["int test = 1234"],
                            	\"spec_failed": ["if test == 1234:","int nottest = 44"],
                            	\})
                            
    1   0.000013   0.000009 call s:add_definition('java', {
                            	\"type": 'type',
                            	\"pcre2_regexp": '(class|interface)\s*KEYWORD\b',
                            	\"emacs_regexp": '(class|interface)\s*JJJ\b',
                            	\"supports": ["ag", "grep", "rg", "git-grep"],
                            	\"spec_success": ["class test:","public class test implements Something"],
                            	\"spec_failed": ["class testnot:","public class testnot implements Something"],
                            	\})
                            
    1   0.000016   0.000012 call s:add_definition('vala', {
                            	\"type": 'function',
                            	\"pcre2_regexp": '^\s*(?:[\w\[\]]+\s+){1,3}KEYWORD\s*\(',
                            	\"emacs_regexp": '^\s*(?:[\w\[\]]+\s+){1,3}JJJ\s*\(',
                            	\"supports": ["ag", "rg"],
                            	\"spec_success": ["int test()","int test(param)","static int test()","static int test(param)","public static MyType test()","private virtual SomeType test(param)","static int test()"],
                            	\"spec_failed": ["test()","testnot()","blah = new test()"],
                            	\})
                            
    1   0.000012   0.000009 call s:add_definition('vala', {
                            	\"type": 'variable',
                            	\"pcre2_regexp": '\s*\bKEYWORD\s*=[^=\n)]+',
                            	\"emacs_regexp": '\s*\bJJJ\s*=[^=\n)]+',
                            	\"supports": ["ag", "grep", "rg", "git-grep"],
                            	\"spec_success": ["int test = 1234"],
                            	\"spec_failed": ["if test == 1234:","int nottest = 44"],
                            	\})
                            
    1   0.000012   0.000009 call s:add_definition('vala', {
                            	\"type": 'type',
                            	\"pcre2_regexp": '(class|interface)\s*KEYWORD\b',
                            	\"emacs_regexp": '(class|interface)\s*JJJ\b',
                            	\"supports": ["ag", "grep", "rg", "git-grep"],
                            	\"spec_success": ["class test:","public class test : IReadableChannel, I"],
                            	\"spec_failed": ["class testnot:","public class testnot : IReadableChannel, I"],
                            	\})
                            
    1   0.000012   0.000008 call s:add_definition('coq', {
                            	\"type": 'function',
                            	\"pcre2_regexp": '\s*Variable\s+KEYWORD\b',
                            	\"emacs_regexp": '\s*Variable\s+JJJ\b',
                            	\"supports": ["ag", "rg", "git-grep"],
                            	\"spec_success": ["Variable test"],
                            	\"spec_failed": ["Variable testx"],
                            	\})
                            
    1   0.000011   0.000008 call s:add_definition('coq', {
                            	\"type": 'function',
                            	\"pcre2_regexp": '\s*Inductive\s+KEYWORD\b',
                            	\"emacs_regexp": '\s*Inductive\s+JJJ\b',
                            	\"supports": ["ag", "rg", "git-grep"],
                            	\"spec_success": ["Inductive test"],
                            	\"spec_failed": ["Inductive testx"],
                            	\})
                            
    1   0.000020   0.000016 call s:add_definition('coq', {
                            	\"type": 'function',
                            	\"pcre2_regexp": '\s*Lemma\s+KEYWORD\b',
                            	\"emacs_regexp": '\s*Lemma\s+JJJ\b',
                            	\"supports": ["ag", "rg", "git-grep"],
                            	\"spec_success": ["Lemma test"],
                            	\"spec_failed": ["Lemma testx"],
                            	\})
                            
    1   0.000011   0.000008 call s:add_definition('coq', {
                            	\"type": 'function',
                            	\"pcre2_regexp": '\s*Definition\s+KEYWORD\b',
                            	\"emacs_regexp": '\s*Definition\s+JJJ\b',
                            	\"supports": ["ag", "rg", "git-grep"],
                            	\"spec_success": ["Definition test"],
                            	\"spec_failed": ["Definition testx"],
                            	\})
                            
    1   0.000011   0.000008 call s:add_definition('coq', {
                            	\"type": 'function',
                            	\"pcre2_regexp": '\s*Hypothesis\s+KEYWORD\b',
                            	\"emacs_regexp": '\s*Hypothesis\s+JJJ\b',
                            	\"supports": ["ag", "rg", "git-grep"],
                            	\"spec_success": ["Hypothesis test"],
                            	\"spec_failed": ["Hypothesis testx"],
                            	\})
                            
    1   0.000011   0.000008 call s:add_definition('coq', {
                            	\"type": 'function',
                            	\"pcre2_regexp": '\s*Theorm\s+KEYWORD\b',
                            	\"emacs_regexp": '\s*Theorm\s+JJJ\b',
                            	\"supports": ["ag", "rg", "git-grep"],
                            	\"spec_success": ["Theorm test"],
                            	\"spec_failed": ["Theorm testx"],
                            	\})
                            
    1   0.000011   0.000008 call s:add_definition('coq', {
                            	\"type": 'function',
                            	\"pcre2_regexp": '\s*Fixpoint\s+KEYWORD\b',
                            	\"emacs_regexp": '\s*Fixpoint\s+JJJ\b',
                            	\"supports": ["ag", "rg", "git-grep"],
                            	\"spec_success": ["Fixpoint test"],
                            	\"spec_failed": ["Fixpoint testx"],
                            	\})
                            
    1   0.000011   0.000008 call s:add_definition('coq', {
                            	\"type": 'function',
                            	\"pcre2_regexp": '\s*Module\s+KEYWORD\b',
                            	\"emacs_regexp": '\s*Module\s+JJJ\b',
                            	\"supports": ["ag", "rg", "git-grep"],
                            	\"spec_success": ["Module test"],
                            	\"spec_failed": ["Module testx"],
                            	\})
                            
    1   0.000012   0.000008 call s:add_definition('coq', {
                            	\"type": 'function',
                            	\"pcre2_regexp": '\s*CoInductive\s+KEYWORD\b',
                            	\"emacs_regexp": '\s*CoInductive\s+JJJ\b',
                            	\"supports": ["ag", "rg", "git-grep"],
                            	\"spec_success": ["CoInductive test"],
                            	\"spec_failed": ["CoInductive testx"],
                            	\})
                            
    1   0.000015   0.000011 call s:add_definition('python', {
                            	\"type": 'variable',
                            	\"pcre2_regexp": '\s*\bKEYWORD\s*=[^=\n]+',
                            	\"emacs_regexp": '\s*\bJJJ\s*=[^=\n]+',
                            	\"supports": ["ag", "grep", "rg", "git-grep"],
                            	\"spec_success": ["test = 1234"],
                            	\"spec_failed": ["if test == 1234:","_test = 1234"],
                            	\})
                            
    1   0.000013   0.000009 call s:add_definition('python', {
                            	\"type": 'function',
                            	\"pcre2_regexp": 'def\s*KEYWORD\b\s*\(',
                            	\"emacs_regexp": 'def\s*JJJ\b\s*\(',
                            	\"supports": ["ag", "grep", "rg", "git-grep"],
                            	\"spec_success": ["\tdef test(asdf)","def test()"],
                            	\"spec_failed": ["\tdef testnot(asdf)","def testnot()"],
                            	\})
                            
    1   0.000013   0.000009 call s:add_definition('python', {
                            	\"type": 'type',
                            	\"pcre2_regexp": 'class\s*KEYWORD\b\s*\(?',
                            	\"emacs_regexp": 'class\s*JJJ\b\s*\(?',
                            	\"supports": ["ag", "grep", "rg", "git-grep"],
                            	\"spec_success": ["class test(object):","class test:"],
                            	\"spec_failed": ["class testnot:","class testnot(object):"],
                            	\})
                            
    1   0.000013   0.000008 call s:add_definition('matlab', {
                            	\"type": 'variable',
                            	\"pcre2_regexp": '^\s*\bKEYWORD\s*=[^=\n]+',
                            	\"emacs_regexp": '^\s*\bJJJ\s*=[^=\n]+',
                            	\"supports": ["ag", "grep", "rg", "git-grep"],
                            	\"spec_success": ["test = 1234"],
                            	\"spec_failed": ["for test = 1:2:","_test = 1234"],
                            	\})
                            
    1   0.000014   0.000010 call s:add_definition('matlab', {
                            	\"type": 'function',
                            	\"pcre2_regexp": '^\s*function\s*[^=]+\s*=\s*KEYWORD\b',
                            	\"emacs_regexp": '^\s*function\s*[^=]+\s*=\s*JJJ\b',
                            	\"supports": ["ag", "grep", "rg", "git-grep"],
                            	\"spec_success": ["\tfunction y = test(asdf)","function x = test()","function [x, losses] = test(A, y, lambda, method, qtile)"],
                            	\"spec_failed": ["\tfunction testnot(asdf)","function testnot()"],
                            	\})
                            
    1   0.000011   0.000008 call s:add_definition('matlab', {
                            	\"type": 'type',
                            	\"pcre2_regexp": '^\s*classdef\s*KEYWORD\b\s*',
                            	\"emacs_regexp": '^\s*classdef\s*JJJ\b\s*',
                            	\"supports": ["ag", "grep", "rg", "git-grep"],
                            	\"spec_success": ["classdef test"],
                            	\"spec_failed": ["classdef testnot"],
                            	\})
                            
    1   0.000014   0.000010 call s:add_definition('nim', {
                            	\"type": 'variable',
                            	\"pcre2_regexp": '(const|let|var)\s*KEYWORD\*?\s*(=|:)[^=:\n]+',
                            	\"emacs_regexp": '(const|let|var)\s*JJJ\*?\s*(=|:)[^=:\n]+',
                            	\"supports": ["ag", "grep", "rg", "git-grep"],
                            	\"spec_success": ["let test = 1234","var test = 1234","var test: Stat","const test = 1234","const test* = 1234"],
                            	\"spec_failed": ["if test == 1234:"],
                            	\})
                            
    1   0.000014   0.000010 call s:add_definition('nim', {
                            	\"type": 'function',
                            	\"pcre2_regexp": '(proc|func|macro|template)\s*\`?KEYWORD\`?\b\*?\s*\(',
                            	\"emacs_regexp": '(proc|func|macro|template)\s*\`?JJJ\`?\b\*?\s*\(',
                            	\"supports": ["ag", "grep", "rg", "git-grep"],
                            	\"spec_success": ["\tproc test(asdf)","proc test()","func test()","macro test()","template test()","proc test*()"],
                            	\"spec_failed": ["\tproc testnot(asdf)","proc testnot()"],
                            	\})
                            
    1   0.000013   0.000009 call s:add_definition('nim', {
                            	\"type": 'type',
                            	\"pcre2_regexp": 'type\s*KEYWORD\b\*?\s*(\{[^}]+\})?\s*=\s*\w+',
                            	\"emacs_regexp": 'type\s*JJJ\b\*?\s*(\{[^}]+\})?\s*=\s*\w+',
                            	\"supports": ["ag", "grep", "rg", "git-grep"],
                            	\"spec_success": ["type test = object","type test {.pure.} = enum","type test* = ref object"],
                            	\"spec_failed": ["type testnot = object"],
                            	\})
                            
    1   0.000013   0.000009 call s:add_definition('nix', {
                            	\"type": 'variable',
                            	\"pcre2_regexp": '\b\s*KEYWORD\s*=[^=;]+',
                            	\"emacs_regexp": '\b\s*JJJ\s*=[^=;]+',
                            	\"supports": ["ag", "grep", "rg", "git-grep"],
                            	\"spec_success": ["test = 1234;","test = 123;","test=123"],
                            	\"spec_failed": ["testNot = 1234;","Nottest = 1234;","AtestNot = 1234;"],
                            	\})
                            
    1   0.000013   0.000009 call s:add_definition('ruby', {
                            	\"type": 'variable',
                            	\"pcre2_regexp": '^\s*((\w+[.])*\w+,\s*)*KEYWORD(,\s*(\w+[.])*\w+)*\s*=([^=>~]|$)',
                            	\"emacs_regexp": '^\s*((\w+[.])*\w+,\s*)*JJJ(,\s*(\w+[.])*\w+)*\s*=([^=>~]|$)',
                            	\"supports": ["ag", "rg", "git-grep"],
                            	\"spec_success": ["test = 1234","self.foo, test, bar = args"],
                            	\"spec_failed": ["if test == 1234","foo_test = 1234"],
                            	\})
                            
    1   0.000029   0.000025 call s:add_definition('ruby', {
                            	\"type": 'function',
                            	\"pcre2_regexp": '(^|[^\w.])((private|public|protected)\s+)?def\s+(\w+(::|[.]))*KEYWORD($|[^\w|:])',
                            	\"emacs_regexp": '(^|[^\w.])((private|public|protected)\s+)?def\s+(\w+(::|[.]))*JJJ($|[^\w|:])',
                            	\"supports": ["ag", "rg", "git-grep"],
                            	\"spec_success": ["def test(foo)","def test()","def test foo","def test; end","def self.test()","def MODULE::test()","private def test"],
                            	\"spec_failed": ["def test_foo"],
                            	\})
                            
    1   0.000025   0.000017 call s:add_definition('ruby', {
                            	\"type": 'function',
                            	\"pcre2_regexp": '(^|\W)define(_singleton|_instance)?_method(\s|[(])\s*:KEYWORD($|[^\w|:])',
                            	\"emacs_regexp": '(^|\W)define(_singleton|_instance)?_method(\s|[(])\s*:JJJ($|[^\w|:])',
                            	\"supports": ["ag", "rg", "git-grep"],
                            	\"spec_success": ["define_method(:test, &body)","mod.define_instance_method(:test) { body }"],
                            	\"spec_failed": [],
                            	\})
                            
    1   0.000015   0.000010 call s:add_definition('ruby', {
                            	\"type": 'type',
                            	\"pcre2_regexp": '(^|[^\w.])class\s+(\w*::)*KEYWORD($|[^\w|:])',
                            	\"emacs_regexp": '(^|[^\w.])class\s+(\w*::)*JJJ($|[^\w|:])',
                            	\"supports": ["ag", "rg", "git-grep"],
                            	\"spec_success": ["class test","class Foo::test"],
                            	\"spec_failed": [],
                            	\})
                            
    1   0.000013   0.000009 call s:add_definition('ruby', {
                            	\"type": 'type',
                            	\"pcre2_regexp": '(^|[^\w.])module\s+(\w*::)*KEYWORD($|[^\w|:])',
                            	\"emacs_regexp": '(^|[^\w.])module\s+(\w*::)*JJJ($|[^\w|:])',
                            	\"supports": ["ag", "rg", "git-grep"],
                            	\"spec_success": ["module test","module Foo::test"],
                            	\"spec_failed": [],
                            	\})
                            
    1   0.000016   0.000013 call s:add_definition('ruby', {
                            	\"type": 'function',
                            	\"pcre2_regexp": '(^|\W)alias(_method)?\W+KEYWORD(\W|$)',
                            	\"emacs_regexp": '(^|\W)alias(_method)?\W+JJJ(\W|$)',
                            	\"supports": ["ag", "rg", "git-grep"],
                            	\"spec_success": ["alias test some_method","alias_method :test, :some_method","alias_method 'test' 'some_method'","some_class.send(:alias_method, :test, :some_method)"],
                            	\"spec_failed": ["alias some_method test","alias_method :some_method, :test","alias test_foo test"],
                            	\})
                            
    1   0.000015   0.000010 call s:add_definition('groovy', {
                            	\"type": 'variable',
                            	\"pcre2_regexp": '^\s*((\w+[.])*\w+,\s*)*KEYWORD(,\s*(\w+[.])*\w+)*\s*=([^=>~]|$)',
                            	\"emacs_regexp": '^\s*((\w+[.])*\w+,\s*)*JJJ(,\s*(\w+[.])*\w+)*\s*=([^=>~]|$)',
                            	\"supports": ["ag", "rg", "git-grep"],
                            	\"spec_success": ["test = 1234","self.foo, test, bar = args"],
                            	\"spec_failed": ["if test == 1234","foo_test = 1234"],
                            	\})
                            
    1   0.000015   0.000011 call s:add_definition('groovy', {
                            	\"type": 'function',
                            	\"pcre2_regexp": '(^|[^\w.])((private|public)\s+)?def\s+(\w+(::|[.]))*KEYWORD($|[^\w|:])',
                            	\"emacs_regexp": '(^|[^\w.])((private|public)\s+)?def\s+(\w+(::|[.]))*JJJ($|[^\w|:])',
                            	\"supports": ["ag", "rg", "git-grep"],
                            	\"spec_success": ["def test(foo)","def test()","def test foo","def test; end","def self.test()","def MODULE::test()","private def test"],
                            	\"spec_failed": ["def test_foo"],
                            	\})
                            
    1   0.000012   0.000009 call s:add_definition('groovy', {
                            	\"type": 'type',
                            	\"pcre2_regexp": '(^|[^\w.])class\s+(\w*::)*KEYWORD($|[^\w|:])',
                            	\"emacs_regexp": '(^|[^\w.])class\s+(\w*::)*JJJ($|[^\w|:])',
                            	\"supports": ["ag", "rg", "git-grep"],
                            	\"spec_success": ["class test","class Foo::test"],
                            	\"spec_failed": [],
                            	\})
                            
    1   0.000014   0.000010 call s:add_definition('crystal', {
                            	\"type": 'variable',
                            	\"pcre2_regexp": '^\s*((\w+[.])*\w+,\s*)*KEYWORD(,\s*(\w+[.])*\w+)*\s*=([^=>~]|$)',
                            	\"emacs_regexp": '^\s*((\w+[.])*\w+,\s*)*JJJ(,\s*(\w+[.])*\w+)*\s*=([^=>~]|$)',
                            	\"supports": ["ag", "rg", "git-grep"],
                            	\"spec_success": ["test = 1234","self.foo, test, bar = args"],
                            	\"spec_failed": ["if test == 1234","foo_test = 1234"],
                            	\})
                            
    1   0.000015   0.000011 call s:add_definition('crystal', {
                            	\"type": 'function',
                            	\"pcre2_regexp": '(^|[^\w.])((private|public|protected)\s+)?def\s+(\w+(::|[.]))*KEYWORD($|[^\w|:])',
                            	\"emacs_regexp": '(^|[^\w.])((private|public|protected)\s+)?def\s+(\w+(::|[.]))*JJJ($|[^\w|:])',
                            	\"supports": ["ag", "rg", "git-grep"],
                            	\"spec_success": ["def test(foo)","def test()","def test foo","def test; end","def self.test()","def MODULE::test()","private def test"],
                            	\"spec_failed": ["def test_foo"],
                            	\})
                            
    1   0.000012   0.000009 call s:add_definition('crystal', {
                            	\"type": 'type',
                            	\"pcre2_regexp": '(^|[^\w.])class\s+(\w*::)*KEYWORD($|[^\w|:])',
                            	\"emacs_regexp": '(^|[^\w.])class\s+(\w*::)*JJJ($|[^\w|:])',
                            	\"supports": ["ag", "rg", "git-grep"],
                            	\"spec_success": ["class test","class Foo::test"],
                            	\"spec_failed": [],
                            	\})
                            
    1   0.000018   0.000014 call s:add_definition('crystal', {
                            	\"type": 'type',
                            	\"pcre2_regexp": '(^|[^\w.])module\s+(\w*::)*KEYWORD($|[^\w|:])',
                            	\"emacs_regexp": '(^|[^\w.])module\s+(\w*::)*JJJ($|[^\w|:])',
                            	\"supports": ["ag", "rg", "git-grep"],
                            	\"spec_success": ["module test","module Foo::test"],
                            	\"spec_failed": [],
                            	\})
                            
    1   0.000012   0.000008 call s:add_definition('crystal', {
                            	\"type": 'type',
                            	\"pcre2_regexp": '(^|[^\w.])struct\s+(\w*::)*KEYWORD($|[^\w|:])',
                            	\"emacs_regexp": '(^|[^\w.])struct\s+(\w*::)*JJJ($|[^\w|:])',
                            	\"supports": ["ag", "rg", "git-grep"],
                            	\"spec_success": ["struct test","struct Foo::test"],
                            	\"spec_failed": [],
                            	\})
                            
    1   0.000012   0.000008 call s:add_definition('crystal', {
                            	\"type": 'type',
                            	\"pcre2_regexp": '(^|[^\w.])alias\s+(\w*::)*KEYWORD($|[^\w|:])',
                            	\"emacs_regexp": '(^|[^\w.])alias\s+(\w*::)*JJJ($|[^\w|:])',
                            	\"supports": ["ag", "rg", "git-grep"],
                            	\"spec_success": ["alias test","alias Foo::test"],
                            	\"spec_failed": [],
                            	\})
                            
    1   0.000014   0.000009 call s:add_definition('scad', {
                            	\"type": 'variable',
                            	\"pcre2_regexp": '\s*\bKEYWORD\s*=[^=\n]+',
                            	\"emacs_regexp": '\s*\bJJJ\s*=[^=\n]+',
                            	\"supports": ["ag", "grep", "rg", "git-grep"],
                            	\"spec_success": ["test = 1234"],
                            	\"spec_failed": ["if test == 1234 {"],
                            	\})
                            
    1   0.000012   0.000009 call s:add_definition('scad', {
                            	\"type": 'function',
                            	\"pcre2_regexp": 'function\s*KEYWORD\s*\(',
                            	\"emacs_regexp": 'function\s*JJJ\s*\(',
                            	\"supports": ["ag", "grep", "rg", "git-grep"],
                            	\"spec_success": ["function test()","function test ()"],
                            	\"spec_failed": [],
                            	\})
                            
    1   0.000012   0.000008 call s:add_definition('scad', {
                            	\"type": 'module',
                            	\"pcre2_regexp": 'module\s*KEYWORD\s*\(',
                            	\"emacs_regexp": 'module\s*JJJ\s*\(',
                            	\"supports": ["ag", "grep", "rg", "git-grep"],
                            	\"spec_success": ["module test()","module test ()"],
                            	\"spec_failed": [],
                            	\})
                            
    1   0.000013   0.000008 call s:add_definition('scala', {
                            	\"type": 'variable',
                            	\"pcre2_regexp": '\bval\s*KEYWORD\s*=[^=\n]+',
                            	\"emacs_regexp": '\bval\s*JJJ\s*=[^=\n]+',
                            	\"supports": ["ag", "grep", "rg", "git-grep"],
                            	\"spec_success": ["val test = 1234"],
                            	\"spec_failed": ["case test => 1234"],
                            	\})
                            
    1   0.000012   0.000009 call s:add_definition('scala', {
                            	\"type": 'variable',
                            	\"pcre2_regexp": '\bvar\s*KEYWORD\s*=[^=\n]+',
                            	\"emacs_regexp": '\bvar\s*JJJ\s*=[^=\n]+',
                            	\"supports": ["ag", "grep", "rg", "git-grep"],
                            	\"spec_success": ["var test = 1234"],
                            	\"spec_failed": ["case test => 1234"],
                            	\})
                            
    1   0.000012   0.000008 call s:add_definition('scala', {
                            	\"type": 'variable',
                            	\"pcre2_regexp": '\btype\s*KEYWORD\s*=[^=\n]+',
                            	\"emacs_regexp": '\btype\s*JJJ\s*=[^=\n]+',
                            	\"supports": ["ag", "grep", "rg", "git-grep"],
                            	\"spec_success": ["type test = 1234"],
                            	\"spec_failed": ["case test => 1234"],
                            	\})
                            
    1   0.000012   0.000008 call s:add_definition('scala', {
                            	\"type": 'function',
                            	\"pcre2_regexp": '\bdef\s*KEYWORD\s*\(',
                            	\"emacs_regexp": '\bdef\s*JJJ\s*\(',
                            	\"supports": ["ag", "grep", "rg", "git-grep"],
                            	\"spec_success": ["def test(asdf)","def test()"],
                            	\"spec_failed": [],
                            	\})
                            
    1   0.000011   0.000008 call s:add_definition('scala', {
                            	\"type": 'type',
                            	\"pcre2_regexp": 'class\s*KEYWORD\s*\(?',
                            	\"emacs_regexp": 'class\s*JJJ\s*\(?',
                            	\"supports": ["ag", "grep", "rg", "git-grep"],
                            	\"spec_success": ["class test(object)"],
                            	\"spec_failed": [],
                            	\})
                            
    1   0.000011   0.000008 call s:add_definition('scala', {
                            	\"type": 'type',
                            	\"pcre2_regexp": 'trait\s*KEYWORD\s*\(?',
                            	\"emacs_regexp": 'trait\s*JJJ\s*\(?',
                            	\"supports": ["ag", "grep", "rg", "git-grep"],
                            	\"spec_success": ["trait test(object)"],
                            	\"spec_failed": [],
                            	\})
                            
    1   0.000011   0.000008 call s:add_definition('scala', {
                            	\"type": 'type',
                            	\"pcre2_regexp": 'object\s*KEYWORD\s*\(?',
                            	\"emacs_regexp": 'object\s*JJJ\s*\(?',
                            	\"supports": ["ag", "grep", "rg", "git-grep"],
                            	\"spec_success": ["object test(object)"],
                            	\"spec_failed": [],
                            	\})
                            
    1   0.000014   0.000009 call s:add_definition('solidity', {
                            	\"type": 'function',
                            	\"pcre2_regexp": 'function\s*KEYWORD\s*\(',
                            	\"emacs_regexp": 'function\s*JJJ\s*\(',
                            	\"supports": ["ag", "grep", "rg", "git-grep"],
                            	\"spec_success": ["function test() internal","function test (uint x, address y)","function test() external"],
                            	\"spec_failed": [],
                            	\})
                            
    1   0.000012   0.000008 call s:add_definition('solidity', {
                            	\"type": 'modifier',
                            	\"pcre2_regexp": 'modifier\s*KEYWORD\s*\(',
                            	\"emacs_regexp": 'modifier\s*JJJ\s*\(',
                            	\"supports": ["ag", "grep", "rg", "git-grep"],
                            	\"spec_success": ["modifier test()","modifier test ()"],
                            	\"spec_failed": [],
                            	\})
                            
    1   0.000015   0.000012 call s:add_definition('solidity', {
                            	\"type": 'event',
                            	\"pcre2_regexp": 'event\s*KEYWORD\s*\(',
                            	\"emacs_regexp": 'event\s*JJJ\s*\(',
                            	\"supports": ["ag", "grep", "rg", "git-grep"],
                            	\"spec_success": ["event test();","event test (uint indexed x)","event test(uint x, address y)"],
                            	\"spec_failed": [],
                            	\})
                            
    1   0.000013   0.000009 call s:add_definition('solidity', {
                            	\"type": 'error',
                            	\"pcre2_regexp": 'error\s*KEYWORD\s*\(',
                            	\"emacs_regexp": 'error\s*JJJ\s*\(',
                            	\"supports": ["ag", "grep", "rg", "git-grep"],
                            	\"spec_success": ["error test();","error test (uint x)","error test(uint x, address y)"],
                            	\"spec_failed": [],
                            	\})
                            
    1   0.000012   0.000008 call s:add_definition('r', {
                            	\"type": 'variable',
                            	\"pcre2_regexp": '\bKEYWORD\s*=[^=><]',
                            	\"emacs_regexp": '\bJJJ\s*=[^=><]',
                            	\"supports": ["ag", "grep", "rg", "git-grep"],
                            	\"spec_success": ["test = 1234"],
                            	\"spec_failed": ["if (test == 1234)"],
                            	\})
                            
    1   0.000012   0.000009 call s:add_definition('r', {
                            	\"type": 'function',
                            	\"pcre2_regexp": '\bKEYWORD\s*<-\s*function\b',
                            	\"emacs_regexp": '\bJJJ\s*<-\s*function\b',
                            	\"supports": ["ag", "grep", "rg", "git-grep"],
                            	\"spec_success": ["test <- function","test <- function("],
                            	\"spec_failed": ["test <- functionX"],
                            	\})
                            
    1   0.000013   0.000008 call s:add_definition('perl', {
                            	\"type": 'function',
                            	\"pcre2_regexp": 'sub\s*KEYWORD\s*(\{|\()',
                            	\"emacs_regexp": 'sub\s*JJJ\s*(\{|\()',
                            	\"supports": ["ag", "grep", "rg", "git-grep"],
                            	\"spec_success": ["sub test{","sub test {","sub test(","sub test ("],
                            	\"spec_failed": [],
                            	\})
                            
    1   0.000011   0.000008 call s:add_definition('perl', {
                            	\"type": 'variable',
                            	\"pcre2_regexp": 'KEYWORD\s*=\s*',
                            	\"emacs_regexp": 'JJJ\s*=\s*',
                            	\"supports": ["ag", "grep", "rg", "git-grep"],
                            	\"spec_success": ["$test = 1234"],
                            	\"spec_failed": [],
                            	\})
                            
    1   0.000013   0.000009 call s:add_definition('tcl', {
                            	\"type": 'function',
                            	\"pcre2_regexp": 'proc\s+KEYWORD\s*\{',
                            	\"emacs_regexp": 'proc\s+JJJ\s*\{',
                            	\"supports": ["ag", "grep", "rg", "git-grep"],
                            	\"spec_success": ["proc test{","proc test {"],
                            	\"spec_failed": [],
                            	\})
                            
    1   0.000011   0.000008 call s:add_definition('tcl', {
                            	\"type": 'variable',
                            	\"pcre2_regexp": 'set\s+KEYWORD',
                            	\"emacs_regexp": 'set\s+JJJ',
                            	\"supports": ["ag", "grep", "rg", "git-grep"],
                            	\"spec_success": ["set test 1234"],
                            	\"spec_failed": [],
                            	\})
                            
    1   0.000012   0.000008 call s:add_definition('tcl', {
                            	\"type": 'variable',
                            	\"pcre2_regexp": '(variable|global)\s+KEYWORD',
                            	\"emacs_regexp": '(variable|global)\s+JJJ',
                            	\"supports": ["ag", "grep", "rg", "git-grep"],
                            	\"spec_success": ["variable test","global test"],
                            	\"spec_failed": [],
                            	\})
                            
    1   0.000013   0.000009 call s:add_definition('shell', {
                            	\"type": 'function',
                            	\"pcre2_regexp": 'function\s*KEYWORD\s*',
                            	\"emacs_regexp": 'function\s*JJJ\s*',
                            	\"supports": ["ag", "grep", "rg", "git-grep"],
                            	\"spec_success": ["function test{","function test {","function test () {"],
                            	\"spec_failed": ["function nottest {"],
                            	\})
                            
    1   0.000012   0.000008 call s:add_definition('shell', {
                            	\"type": 'function',
                            	\"pcre2_regexp": 'KEYWORD\(\)\s*\{',
                            	\"emacs_regexp": 'JJJ\(\)\s*\{',
                            	\"supports": ["ag", "grep", "rg", "git-grep"],
                            	\"spec_success": ["test() {"],
                            	\"spec_failed": ["testx() {"],
                            	\})
                            
    1   0.000011   0.000008 call s:add_definition('shell', {
                            	\"type": 'variable',
                            	\"pcre2_regexp": '\bKEYWORD\s*=\s*',
                            	\"emacs_regexp": '\bJJJ\s*=\s*',
                            	\"supports": ["ag", "grep", "rg", "git-grep"],
                            	\"spec_success": ["test = 1234"],
                            	\"spec_failed": ["blahtest = 1234"],
                            	\})
                            
    1   0.000012   0.000008 call s:add_definition('php', {
                            	\"type": 'function',
                            	\"pcre2_regexp": 'function\s*KEYWORD\s*\(',
                            	\"emacs_regexp": 'function\s*JJJ\s*\(',
                            	\"supports": ["ag", "grep", "rg", "git-grep"],
                            	\"spec_success": ["function test()","function test ()"],
                            	\"spec_failed": [],
                            	\})
                            
    1   0.000012   0.000009 call s:add_definition('php', {
                            	\"type": 'function',
                            	\"pcre2_regexp": '\*\s@method\s+[^ 	]+\s+KEYWORD\(',
                            	\"emacs_regexp": '\*\s@method\s+[^ 	]+\s+JJJ\(',
                            	\"supports": ["ag", "grep", "rg", "git-grep"],
                            	\"spec_success": ["/** @method string|false test($a)"," * @method bool test()"],
                            	\"spec_failed": [],
                            	\})
                            
    1   0.000012   0.000009 call s:add_definition('php', {
                            	\"type": 'variable',
                            	\"pcre2_regexp": '(\s|->|\$|::)KEYWORD\s*=\s*',
                            	\"emacs_regexp": '(\s|->|\$|::)JJJ\s*=\s*',
                            	\"supports": ["ag", "grep", "rg", "git-grep"],
                            	\"spec_success": ["$test = 1234","$foo->test = 1234"],
                            	\"spec_failed": [],
                            	\})
                            
    1   0.000018   0.000015 call s:add_definition('php', {
                            	\"type": 'variable',
                            	\"pcre2_regexp": '\*\s@property(-read|-write)?\s+([^ 	]+\s+)&?\$KEYWORD(\s+|$)',
                            	\"emacs_regexp": '\*\s@property(-read|-write)?\s+([^ 	]+\s+)&?\$JJJ(\s+|$)',
                            	\"supports": ["ag", "grep", "rg", "git-grep"],
                            	\"spec_success": ["/** @property string $test","/** @property string $test description for $test property"," * @property-read bool|bool $test"," * @property-write \\ArrayObject<string,resource[]> $test"],
                            	\"spec_failed": [],
                            	\})
                            
    1   0.000011   0.000008 call s:add_definition('php', {
                            	\"type": 'trait',
                            	\"pcre2_regexp": 'trait\s*KEYWORD\s*\{',
                            	\"emacs_regexp": 'trait\s*JJJ\s*\{',
                            	\"supports": ["ag", "grep", "rg", "git-grep"],
                            	\"spec_success": ["trait test{","trait test {"],
                            	\"spec_failed": [],
                            	\})
                            
    1   0.000012   0.000008 call s:add_definition('php', {
                            	\"type": 'interface',
                            	\"pcre2_regexp": 'interface\s*KEYWORD\s*\{',
                            	\"emacs_regexp": 'interface\s*JJJ\s*\{',
                            	\"supports": ["ag", "grep", "rg", "git-grep"],
                            	\"spec_success": ["interface test{","interface test {"],
                            	\"spec_failed": [],
                            	\})
                            
    1   0.000013   0.000009 call s:add_definition('php', {
                            	\"type": 'class',
                            	\"pcre2_regexp": 'class\s*KEYWORD\s*(extends|implements|\{)',
                            	\"emacs_regexp": 'class\s*JJJ\s*(extends|implements|\{)',
                            	\"supports": ["ag", "grep", "rg", "git-grep"],
                            	\"spec_success": ["class test{","class test {","class test extends foo","class test implements foo"],
                            	\"spec_failed": [],
                            	\})
                            
    1   0.000012   0.000008 call s:add_definition('dart', {
                            	\"type": 'function',
                            	\"pcre2_regexp": '\bKEYWORD\s*\([^()]*\)\s*[{]',
                            	\"emacs_regexp": '\bJJJ\s*\([^()]*\)\s*[{]',
                            	\"supports": ["ag", "grep", "rg", "git-grep"],
                            	\"spec_success": ["test(foo) {","test (foo){","test(foo){"],
                            	\"spec_failed": [],
                            	\})
                            
    1   0.000012   0.000008 call s:add_definition('dart', {
                            	\"type": 'function',
                            	\"pcre2_regexp": 'class\s*KEYWORD\s*[\(\{]',
                            	\"emacs_regexp": 'class\s*JJJ\s*[\(\{]',
                            	\"supports": ["ag", "grep", "rg", "git-grep"],
                            	\"spec_success": ["class test(object) {","class test{"],
                            	\"spec_failed": [],
                            	\})
                            
    1   0.000013   0.000009 call s:add_definition('faust', {
                            	\"type": 'function',
                            	\"pcre2_regexp": '\bKEYWORD(\(.+\))*\s*=',
                            	\"emacs_regexp": '\bJJJ(\(.+\))*\s*=',
                            	\"supports": ["ag", "grep", "rg", "git-grep"],
                            	\"spec_success": ["test = osc + 0.5;","test(freq) = osc(freq) + 0.5;"],
                            	\"spec_failed": [],
                            	\})
                            
    1   0.000012   0.000008 call s:add_definition('fennel', {
                            	\"type": 'variable',
                            	\"pcre2_regexp": '\((local|var)\s+KEYWORD($|[^a-zA-Z0-9\?\*-])',
                            	\"emacs_regexp": '\((local|var)\s+JJJ\j',
                            	\"supports": ["ag", "grep", "rg", "git-grep"],
                            	\"spec_success": ["(local test (foo)","(var test (foo)"],
                            	\"spec_failed": [],
                            	\})
                            
    1   0.000012   0.000008 call s:add_definition('fennel', {
                            	\"type": 'function',
                            	\"pcre2_regexp": '\(fn\s+KEYWORD($|[^a-zA-Z0-9\?\*-])',
                            	\"emacs_regexp": '\(fn\s+JJJ\j',
                            	\"supports": ["ag", "grep", "rg", "git-grep"],
                            	\"spec_success": ["(fn test [foo]"],
                            	\"spec_failed": ["(fn test? [foo]"],
                            	\})
                            
    1   0.000012   0.000008 call s:add_definition('fennel', {
                            	\"type": 'function',
                            	\"pcre2_regexp": '\(macro\s+KEYWORD($|[^a-zA-Z0-9\?\*-])',
                            	\"emacs_regexp": '\(macro\s+JJJ\j',
                            	\"supports": ["ag", "grep", "rg", "git-grep"],
                            	\"spec_success": ["(macro test [foo]"],
                            	\"spec_failed": [],
                            	\})
                            
    1   0.000012   0.000008 call s:add_definition('fortran', {
                            	\"type": 'variable',
                            	\"pcre2_regexp": '\s*\bKEYWORD\s*=[^=\n]+',
                            	\"emacs_regexp": '\s*\bJJJ\s*=[^=\n]+',
                            	\"supports": ["ag", "grep", "rg", "git-grep"],
                            	\"spec_success": ["test = 1234"],
                            	\"spec_failed": ["if (test == 1234)"],
                            	\})
                            
    1   0.000016   0.000012 call s:add_definition('fortran', {
                            	\"type": 'function',
                            	\"pcre2_regexp": '\b(function|subroutine|FUNCTION|SUBROUTINE)\s+KEYWORD\b\s*\(',
                            	\"emacs_regexp": '\b(function|subroutine|FUNCTION|SUBROUTINE)\s+JJJ\b\s*\(',
                            	\"supports": ["ag", "grep", "rg", "git-grep"],
                            	\"spec_success": ["function test (foo)","integer function test(foo)","subroutine test (foo, bar)","FUNCTION test (foo)","INTEGER FUNCTION test(foo)","SUBROUTINE test (foo, bar)"],
                            	\"spec_failed": ["end function test","end subroutine test","END FUNCTION test","END SUBROUTINE test"],
                            	\})
                            
    1   0.000035   0.000031 call s:add_definition('fortran', {
                            	\"type": 'function',
                            	\"pcre2_regexp": '^\s*(interface|INTERFACE)\s+KEYWORD\b',
                            	\"emacs_regexp": '^\s*(interface|INTERFACE)\s+JJJ\b',
                            	\"supports": ["ag", "grep", "rg", "git-grep"],
                            	\"spec_success": ["interface test","INTERFACE test"],
                            	\"spec_failed": ["interface test2","end interface test","INTERFACE test2","END INTERFACE test"],
                            	\})
                            
    1   0.000012   0.000009 call s:add_definition('fortran', {
                            	\"type": 'type',
                            	\"pcre2_regexp": '^\s*(module|MODULE)\s+KEYWORD\s*',
                            	\"emacs_regexp": '^\s*(module|MODULE)\s+JJJ\s*',
                            	\"supports": ["ag", "grep", "rg", "git-grep"],
                            	\"spec_success": ["module test","MODULE test"],
                            	\"spec_failed": ["end module test","END MODULE test"],
                            	\})
                            
    1   0.000012   0.000008 call s:add_definition('go', {
                            	\"type": 'variable',
                            	\"pcre2_regexp": '\s*\bKEYWORD\s*=[^=\n]+',
                            	\"emacs_regexp": '\s*\bJJJ\s*=[^=\n]+',
                            	\"supports": ["ag", "grep", "rg", "git-grep"],
                            	\"spec_success": ["test = 1234"],
                            	\"spec_failed": ["if test == 1234 {"],
                            	\})
                            
    1   0.000011   0.000008 call s:add_definition('go', {
                            	\"type": 'variable',
                            	\"pcre2_regexp": '\s*\bKEYWORD\s*:=\s*',
                            	\"emacs_regexp": '\s*\bJJJ\s*:=\s*',
                            	\"supports": ["ag", "grep", "rg", "git-grep"],
                            	\"spec_success": ["test := 1234"],
                            	\"spec_failed": [],
                            	\})
                            
    1   0.000012   0.000008 call s:add_definition('go', {
                            	\"type": 'function',
                            	\"pcre2_regexp": 'func\s+\([^\)]*\)\s+KEYWORD\s*\(',
                            	\"emacs_regexp": 'func\s+\([^\)]*\)\s+JJJ\s*\(',
                            	\"supports": ["ag", "grep", "rg", "git-grep"],
                            	\"spec_success": ["func (s *blah) test(filename string) string {"],
                            	\"spec_failed": [],
                            	\})
                            
    1   0.000011   0.000008 call s:add_definition('go', {
                            	\"type": 'function',
                            	\"pcre2_regexp": 'func\s+KEYWORD\s*\(',
                            	\"emacs_regexp": 'func\s+JJJ\s*\(',
                            	\"supports": ["ag", "grep", "rg", "git-grep"],
                            	\"spec_success": ["func test(url string) (string, error)"],
                            	\"spec_failed": [],
                            	\})
                            
    1   0.000011   0.000008 call s:add_definition('go', {
                            	\"type": 'type',
                            	\"pcre2_regexp": 'type\s+KEYWORD\s+struct\s+\{',
                            	\"emacs_regexp": 'type\s+JJJ\s+struct\s+\{',
                            	\"supports": ["ag", "grep", "rg", "git-grep"],
                            	\"spec_success": ["type test struct {"],
                            	\"spec_failed": [],
                            	\})
                            
    1   0.000013   0.000009 call s:add_definition('javascript', {
                            	\"type": 'function',
                            	\"pcre2_regexp": '(service|factory)\([''\"]KEYWORD[''\"]',
                            	\"emacs_regexp": '(service|factory)\([''\"]JJJ[''\"]',
                            	\"supports": ["ag", "grep", "rg", "git-grep"],
                            	\"spec_success": ["module.factory('test', [\"$rootScope\", function($rootScope) {"],
                            	\"spec_failed": [],
                            	\})
                            
    1   0.000012   0.000009 call s:add_definition('javascript', {
                            	\"type": 'function',
                            	\"pcre2_regexp": '\bKEYWORD\s*[=:]\s*\([^\)]*\)\s+=>',
                            	\"emacs_regexp": '\bJJJ\s*[=:]\s*\([^\)]*\)\s+=>',
                            	\"supports": ["ag", "grep", "rg", "git-grep"],
                            	\"spec_success": ["const test = (foo) => ","test: (foo) => {","  test: (foo) => {"],
                            	\"spec_failed": [],
                            	\})
                            
    1   0.000013   0.000009 call s:add_definition('javascript', {
                            	\"type": 'function',
                            	\"pcre2_regexp": '\bKEYWORD\s*\([^()]*\)\s*[{]',
                            	\"emacs_regexp": '\bJJJ\s*\([^()]*\)\s*[{]',
                            	\"supports": ["ag", "grep", "rg", "git-grep"],
                            	\"spec_success": ["test(foo) {","test (foo){","test(foo){"],
                            	\"spec_failed": ["test = blah.then(function(){"],
                            	\})
                            
    1   0.000015   0.000012 call s:add_definition('javascript', {
                            	\"type": 'function',
                            	\"pcre2_regexp": 'class\s*KEYWORD\s*[\(\{]',
                            	\"emacs_regexp": 'class\s*JJJ\s*[\(\{]',
                            	\"supports": ["ag", "grep", "rg", "git-grep"],
                            	\"spec_success": ["class test(object) {","class test{"],
                            	\"spec_failed": [],
                            	\})
                            
    1   0.000012   0.000008 call s:add_definition('javascript', {
                            	\"type": 'function',
                            	\"pcre2_regexp": 'class\s*KEYWORD\s+extends',
                            	\"emacs_regexp": 'class\s*JJJ\s+extends',
                            	\"supports": ["ag", "grep", "rg", "git-grep"],
                            	\"spec_success": ["class test extends Component{"],
                            	\"spec_failed": [],
                            	\})
                            
    1   0.000012   0.000008 call s:add_definition('javascript', {
                            	\"type": 'variable',
                            	\"pcre2_regexp": '\s*\bKEYWORD\s*=[^=\n]+',
                            	\"emacs_regexp": '\s*\bJJJ\s*=[^=\n]+',
                            	\"supports": ["ag", "grep", "rg", "git-grep"],
                            	\"spec_success": ["test = 1234","const test = props =>"],
                            	\"spec_failed": ["if (test === 1234)"],
                            	\})
                            
    1   0.000020   0.000016 call s:add_definition('javascript', {
                            	\"type": 'variable',
                            	\"pcre2_regexp": '\bfunction\b[^\(]*\(\s*[^\)]*\bKEYWORD\b\s*,?\s*\)?',
                            	\"emacs_regexp": '\bfunction\b[^\(]*\(\s*[^\)]*\bJJJ\b\s*,?\s*\)?',
                            	\"supports": ["ag", "grep", "rg", "git-grep"],
                            	\"spec_success": ["function (test)","function (test, blah)","function somefunc(test, blah) {","function(blah, test)"],
                            	\"spec_failed": ["function (testLen)","function (test1, blah)","function somefunc(testFirst, blah) {","function(blah, testLast)","function (Lentest)","function (blahtest, blah)","function somefunc(Firsttest, blah) {","function(blah, Lasttest)"],
                            	\})
                            
    1   0.000012   0.000008 call s:add_definition('javascript', {
                            	\"type": 'function',
                            	\"pcre2_regexp": 'function\s*KEYWORD\s*\(',
                            	\"emacs_regexp": 'function\s*JJJ\s*\(',
                            	\"supports": ["ag", "grep", "rg", "git-grep"],
                            	\"spec_success": ["function test()","function test ()"],
                            	\"spec_failed": [],
                            	\})
                            
    1   0.000012   0.000008 call s:add_definition('javascript', {
                            	\"type": 'function',
                            	\"pcre2_regexp": '\bKEYWORD\s*:\s*function\s*\(',
                            	\"emacs_regexp": '\bJJJ\s*:\s*function\s*\(',
                            	\"supports": ["ag", "grep", "rg", "git-grep"],
                            	\"spec_success": ["test: function()"],
                            	\"spec_failed": [],
                            	\})
                            
    1   0.000011   0.000008 call s:add_definition('javascript', {
                            	\"type": 'function',
                            	\"pcre2_regexp": '\bKEYWORD\s*=\s*function\s*\(',
                            	\"emacs_regexp": '\bJJJ\s*=\s*function\s*\(',
                            	\"supports": ["ag", "grep", "rg", "git-grep"],
                            	\"spec_success": ["test = function()"],
                            	\"spec_failed": [],
                            	\})
                            
    1   0.000013   0.000009 call s:add_definition('hcl', {
                            	\"type": 'block',
                            	\"pcre2_regexp": '(variable|output|module)\s*\"KEYWORD\"\s*\{',
                            	\"emacs_regexp": '(variable|output|module)\s*\"JJJ\"\s*\{',
                            	\"supports": ["ag", "grep", "rg", "git-grep"],
                            	\"spec_success": ["variable \"test\" {","output \"test\" {","module \"test\" {"],
                            	\"spec_failed": [],
                            	\})
                            
    1   0.000013   0.000009 call s:add_definition('hcl', {
                            	\"type": 'block',
                            	\"pcre2_regexp": '(data|resource)\s*\"\w+\"\s*\"KEYWORD\"\s*\{',
                            	\"emacs_regexp": '(data|resource)\s*\"\w+\"\s*\"JJJ\"\s*\{',
                            	\"supports": ["ag", "grep", "rg", "git-grep"],
                            	\"spec_success": ["data \"openstack_images_image_v2\" \"test\" {","resource \"google_compute_instance\" \"test\" {"],
                            	\"spec_failed": [],
                            	\})
                            
    1   0.000013   0.000009 call s:add_definition('typescript', {
                            	\"type": 'function',
                            	\"pcre2_regexp": '(service|factory)\([''\"]KEYWORD[''\"]',
                            	\"emacs_regexp": '(service|factory)\([''\"]JJJ[''\"]',
                            	\"supports": ["ag", "grep", "rg", "git-grep"],
                            	\"spec_success": ["module.factory('test', [\"$rootScope\", function($rootScope) {"],
                            	\"spec_failed": [],
                            	\})
                            
    1   0.000012   0.000009 call s:add_definition('typescript', {
                            	\"type": 'function',
                            	\"pcre2_regexp": '\bKEYWORD\s*[=:]\s*\([^\)]*\)\s+=>',
                            	\"emacs_regexp": '\bJJJ\s*[=:]\s*\([^\)]*\)\s+=>',
                            	\"supports": ["ag", "grep", "rg", "git-grep"],
                            	\"spec_success": ["const test = (foo) => ","test: (foo) => {","  test: (foo) => {"],
                            	\"spec_failed": [],
                            	\})
                            
    1   0.000012   0.000009 call s:add_definition('typescript', {
                            	\"type": 'function',
                            	\"pcre2_regexp": '\bKEYWORD\s*\([^()]*\)\s*[{]',
                            	\"emacs_regexp": '\bJJJ\s*\([^()]*\)\s*[{]',
                            	\"supports": ["ag", "grep", "rg", "git-grep"],
                            	\"spec_success": ["test(foo) {","test (foo){","test(foo){"],
                            	\"spec_failed": ["test = blah.then(function(){"],
                            	\})
                            
    1   0.000011   0.000008 call s:add_definition('typescript', {
                            	\"type": 'function',
                            	\"pcre2_regexp": 'class\s*KEYWORD\s*[\(\{]',
                            	\"emacs_regexp": 'class\s*JJJ\s*[\(\{]',
                            	\"supports": ["ag", "grep", "rg", "git-grep"],
                            	\"spec_success": ["class test{"],
                            	\"spec_failed": [],
                            	\})
                            
    1   0.000011   0.000008 call s:add_definition('typescript', {
                            	\"type": 'function',
                            	\"pcre2_regexp": 'class\s*KEYWORD\s+extends',
                            	\"emacs_regexp": 'class\s*JJJ\s+extends',
                            	\"supports": ["ag", "grep", "rg", "git-grep"],
                            	\"spec_success": ["class test extends Component{"],
                            	\"spec_failed": [],
                            	\})
                            
    1   0.000012   0.000009 call s:add_definition('typescript', {
                            	\"type": 'function',
                            	\"pcre2_regexp": 'function\s*KEYWORD\s*\(',
                            	\"emacs_regexp": 'function\s*JJJ\s*\(',
                            	\"supports": ["ag", "grep", "rg", "git-grep"],
                            	\"spec_success": ["function test()","function test ()"],
                            	\"spec_failed": [],
                            	\})
                            
    1   0.000012   0.000008 call s:add_definition('typescript', {
                            	\"type": 'function',
                            	\"pcre2_regexp": '\bKEYWORD\s*:\s*function\s*\(',
                            	\"emacs_regexp": '\bJJJ\s*:\s*function\s*\(',
                            	\"supports": ["ag", "grep", "rg", "git-grep"],
                            	\"spec_success": ["test: function()"],
                            	\"spec_failed": [],
                            	\})
                            
    1   0.000012   0.000008 call s:add_definition('typescript', {
                            	\"type": 'function',
                            	\"pcre2_regexp": '\bKEYWORD\s*=\s*function\s*\(',
                            	\"emacs_regexp": '\bJJJ\s*=\s*function\s*\(',
                            	\"supports": ["ag", "grep", "rg", "git-grep"],
                            	\"spec_success": ["test = function()"],
                            	\"spec_failed": [],
                            	\})
                            
    1   0.000014   0.000010 call s:add_definition('typescript', {
                            	\"type": 'variable',
                            	\"pcre2_regexp": '\s*\bKEYWORD\s*=[^=\n]+',
                            	\"emacs_regexp": '\s*\bJJJ\s*=[^=\n]+',
                            	\"supports": ["ag", "grep", "rg", "git-grep"],
                            	\"spec_success": ["test = 1234","const test = props =>"],
                            	\"spec_failed": ["if (test === 1234)"],
                            	\})
                            
    1   0.000017   0.000013 call s:add_definition('typescript', {
                            	\"type": 'variable',
                            	\"pcre2_regexp": '\bfunction\b[^\(]*\(\s*[^\)]*\bKEYWORD\b\s*,?\s*\)?',
                            	\"emacs_regexp": '\bfunction\b[^\(]*\(\s*[^\)]*\bJJJ\b\s*,?\s*\)?',
                            	\"supports": ["ag", "grep", "rg", "git-grep"],
                            	\"spec_success": ["function (test)","function (test, blah)","function somefunc(test, blah) {","function(blah, test)"],
                            	\"spec_failed": ["function (testLen)","function (test1, blah)","function somefunc(testFirst, blah) {","function(blah, testLast)","function (Lentest)","function (blahtest, blah)","function somefunc(Firsttest, blah) {","function(blah, Lasttest)"],
                            	\})
                            
    1   0.000013   0.000009 call s:add_definition('julia', {
                            	\"type": 'function',
                            	\"pcre2_regexp": '(@noinline|@inline)?\s*function\s*KEYWORD(\{[^\}]*\})?\(',
                            	\"emacs_regexp": '(@noinline|@inline)?\s*function\s*JJJ(\{[^\}]*\})?\(',
                            	\"supports": ["ag", "grep", "rg", "git-grep"],
                            	\"spec_success": ["function test()","@inline function test()","function test{T}(h)"],
                            	\"spec_failed": [],
                            	\})
                            
    1   0.000012   0.000009 call s:add_definition('julia', {
                            	\"type": 'function',
                            	\"pcre2_regexp": '(@noinline|@inline)?KEYWORD(\{[^\}]*\})?\([^\)]*\)s*=',
                            	\"emacs_regexp": '(@noinline|@inline)?JJJ(\{[^\}]*\})?\([^\)]*\)s*=',
                            	\"supports": ["ag", "grep", "rg", "git-grep"],
                            	\"spec_success": ["test(a)=1","test(a,b)=1*8","@noinline test()=1","test{T}(x)=x"],
                            	\"spec_failed": [],
                            	\})
                            
    1   0.000011   0.000008 call s:add_definition('julia', {
                            	\"type": 'function',
                            	\"pcre2_regexp": 'macro\s*KEYWORD\(',
                            	\"emacs_regexp": 'macro\s*JJJ\(',
                            	\"supports": ["ag", "grep", "rg", "git-grep"],
                            	\"spec_success": ["macro test(a)=1"," macro test(a,b)=1*8"],
                            	\"spec_failed": [],
                            	\})
                            
    1   0.000011   0.000008 call s:add_definition('julia', {
                            	\"type": 'variable',
                            	\"pcre2_regexp": 'const\s+KEYWORD\b',
                            	\"emacs_regexp": 'const\s+JJJ\b',
                            	\"supports": ["ag", "rg"],
                            	\"spec_success": ["const test = "],
                            	\"spec_failed": [],
                            	\})
                            
    1   0.000011   0.000008 call s:add_definition('julia', {
                            	\"type": 'type',
                            	\"pcre2_regexp": '(mutable)?\s*struct\s*KEYWORD',
                            	\"emacs_regexp": '(mutable)?\s*struct\s*JJJ',
                            	\"supports": ["ag", "rg"],
                            	\"spec_success": ["struct test"],
                            	\"spec_failed": [],
                            	\})
                            
    1   0.000012   0.000008 call s:add_definition('julia', {
                            	\"type": 'type',
                            	\"pcre2_regexp": '(type|immutable|abstract)\s*KEYWORD',
                            	\"emacs_regexp": '(type|immutable|abstract)\s*JJJ',
                            	\"supports": ["ag", "rg"],
                            	\"spec_success": ["type test","immutable test","abstract test <:Testable"],
                            	\"spec_failed": [],
                            	\})
                            
    1   0.000012   0.000008 call s:add_definition('haskell', {
                            	\"type": 'module',
                            	\"pcre2_regexp": '^module\s+KEYWORD\s+',
                            	\"emacs_regexp": '^module\s+JJJ\s+',
                            	\"supports": ["rg", "ag"],
                            	\"spec_success": ["module Test (exportA, exportB) where"],
                            	\"spec_failed": [],
                            	\})
                            
    1   0.000018   0.000014 call s:add_definition('haskell', {
                            	\"type": 'top level function',
                            	\"pcre2_regexp": '^\bKEYWORD(?!(\s+::))\s+((.|\s)*?)=\s+',
                            	\"emacs_regexp": '^\bJJJ(?!(\s+::))\s+((.|\s)*?)=\s+',
                            	\"supports": ["rg", "ag"],
                            	\"spec_success": ["test n = n * 2","test X{..} (Y a b c) \n bcd \n =\n x * y","test ab cd e@Datatype {..} (Another thing, inTheRow) = \n undefined","test = runRealBasedMode @ext @ctx identity identity","test unwrap wrap nr@Naoeu {..} (Action action, specSpecs) = \n    undefined"],
                            	\"spec_failed": ["nottest n = n * 2","let testnot x y = x * y","test $ y z","let test a o = mda","test :: Sometype -> AnotherType aoeu kek = undefined"],
                            	\})
                            
    1   0.000015   0.000012 call s:add_definition('haskell', {
                            	\"type": 'type-like',
                            	\"pcre2_regexp": '^\s*((data(\s+family)?)|(newtype)|(type(\s+family)?))\s+KEYWORD\s+',
                            	\"emacs_regexp": '^\s*((data(\s+family)?)|(newtype)|(type(\s+family)?))\s+JJJ\s+',
                            	\"supports": ["rg", "ag"],
                            	\"spec_success": ["newtype Test a = Something { b :: Kek }","data Test a b = Somecase a | Othercase b","type family Test (x :: *) (xs :: [*]) :: Nat where","data family Test ","type Test = TestAlias"],
                            	\"spec_failed": ["newtype NotTest a = NotTest (Not a)","data TestNot b = Aoeu"],
                            	\})
                            
    1   0.000017   0.000014 call s:add_definition('haskell', {
                            	\"type": '(data)type constructor 1',
                            	\"pcre2_regexp": '(data|newtype)\s{1,3}(?!KEYWORD\s+)([^=]{1,40})=((\s{0,3}KEYWORD\s+)|([^=]{0,500}?((?<!(-- ))\|\s{0,3}KEYWORD\s+)))',
                            	\"emacs_regexp": '(data|newtype)\s{1,3}(?!JJJ\s+)([^=]{1,40})=((\s{0,3}JJJ\s+)|([^=]{0,500}?((?<!(-- ))\|\s{0,3}JJJ\s+)))',
                            	\"supports": ["rg", "ag"],
                            	\"spec_success": ["data Something a = Test { b :: Kek }","data Mem a = TrueMem { b :: Kek } | Test (Mem Int) deriving Mda","newtype SafeTest a = Test (Kek a) deriving (YonedaEmbedding)"],
                            	\"spec_failed": ["data Test = Test { b :: Kek }"],
                            	\})
                            
    1   0.000022   0.000019 call s:add_definition('haskell', {
                            	\"type": 'data/newtype record field',
                            	\"pcre2_regexp": '(data|newtype)([^=]*)=[^=]*?({([^=}]*?)(\bKEYWORD)\s+::[^=}]+})',
                            	\"emacs_regexp": '(data|newtype)([^=]*)=[^=]*?({([^=}]*?)(\bJJJ)\s+::[^=}]+})',
                            	\"supports": ["rg", "ag"],
                            	\"spec_success": ["data Mem = Mem { \n mda :: A \n  , test :: Kek \n , \n aoeu :: E \n }","data Mem = Mem { \n test :: A \n  , mda :: Kek \n , \n aoeu :: E \n }","data Mem = Mem { \n mda :: A \n  , aoeu :: Kek \n , \n test :: E \n }","data Mem = Mem { test :: Kek } deriving Mda","data Mem = Mem { \n test :: Kek \n } deriving Mda","newtype Mem = Mem { \n test :: Kek \n } deriving (Eq)","newtype Mem = Mem { -- | Some docs \n test :: Kek -- ^ More docs } deriving Eq","newtype Mem = Mem { test :: Kek } deriving (Eq,Monad)","newtype NewMem = OldMem { test :: [Tx] }","newtype BlockHeaderList ssc = BHL\n { test :: ([Aoeu a], [Ssss])\n    } deriving (Eq)"],
                            	\"spec_failed": ["data Heh = Mda { sometest :: Kek, testsome :: Mem }"],
                            	\})
                            
    1   0.000013   0.000009 call s:add_definition('haskell', {
                            	\"type": 'typeclass',
                            	\"pcre2_regexp": '^class\s+(.+=>\s*)?KEYWORD\s+',
                            	\"emacs_regexp": '^class\s+(.+=>\s*)?JJJ\s+',
                            	\"supports": ["rg", "ag"],
                            	\"spec_success": ["class (Constr1 m, Constr 2) => Test (Kek a) where","class  Test  (Veryovka a)  where "],
                            	\"spec_failed": ["class Test2 (Kek a) where","class MakeTest (AoeuTest x y z) where"],
                            	\})
                            
    1   0.000013   0.000008 call s:add_definition('ocaml', {
                            	\"type": 'type',
                            	\"pcre2_regexp": '^\s*(and|type)\s+.*\bKEYWORD\b',
                            	\"emacs_regexp": '^\s*(and|type)\s+.*\bJJJ\b',
                            	\"supports": ["ag", "rg"],
                            	\"spec_success": ["type test =","and test =","type 'a test =","type ('a, _, 'c) test"],
                            	\"spec_failed": [],
                            	\})
                            
    1   0.000011   0.000008 call s:add_definition('ocaml', {
                            	\"type": 'variable',
                            	\"pcre2_regexp": 'let\s+KEYWORD\b',
                            	\"emacs_regexp": 'let\s+JJJ\b',
                            	\"supports": ["ag", "rg"],
                            	\"spec_success": ["let test =","let test x y ="],
                            	\"spec_failed": [],
                            	\})
                            
    1   0.000011   0.000008 call s:add_definition('ocaml', {
                            	\"type": 'variable',
                            	\"pcre2_regexp": 'let\s+rec\s+KEYWORD\b',
                            	\"emacs_regexp": 'let\s+rec\s+JJJ\b',
                            	\"supports": ["ag", "rg"],
                            	\"spec_success": ["let rec test =","let rec  test x y ="],
                            	\"spec_failed": [],
                            	\})
                            
    1   0.000011   0.000008 call s:add_definition('ocaml', {
                            	\"type": 'variable',
                            	\"pcre2_regexp": '\s*val\s*\bKEYWORD\b\s*',
                            	\"emacs_regexp": '\s*val\s*\bJJJ\b\s*',
                            	\"supports": ["ag", "rg"],
                            	\"spec_success": ["val test"],
                            	\"spec_failed": [],
                            	\})
                            
    1   0.000011   0.000008 call s:add_definition('ocaml', {
                            	\"type": 'module',
                            	\"pcre2_regexp": '^\s*module\s*\bKEYWORD\b',
                            	\"emacs_regexp": '^\s*module\s*\bJJJ\b',
                            	\"supports": ["ag", "rg"],
                            	\"spec_success": ["module test ="],
                            	\"spec_failed": [],
                            	\})
                            
    1   0.000011   0.000008 call s:add_definition('ocaml', {
                            	\"type": 'module',
                            	\"pcre2_regexp": '^\s*module\s*type\s*\bKEYWORD\b',
                            	\"emacs_regexp": '^\s*module\s*type\s*\bJJJ\b',
                            	\"supports": ["ag", "rg"],
                            	\"spec_success": ["module type test ="],
                            	\"spec_failed": [],
                            	\})
                            
    1   0.000012   0.000008 call s:add_definition('lua', {
                            	\"type": 'variable',
                            	\"pcre2_regexp": '\s*\bKEYWORD\s*=[^=\n]+',
                            	\"emacs_regexp": '\s*\bJJJ\s*=[^=\n]+',
                            	\"supports": ["ag", "grep", "rg", "git-grep"],
                            	\"spec_success": ["test = 1234"],
                            	\"spec_failed": ["if test === 1234"],
                            	\})
                            
    1   0.000029   0.000025 call s:add_definition('lua', {
                            	\"type": 'variable',
                            	\"pcre2_regexp": '\bfunction\b[^\(]*\(\s*[^\)]*\bKEYWORD\b\s*,?\s*\)?',
                            	\"emacs_regexp": '\bfunction\b[^\(]*\(\s*[^\)]*\bJJJ\b\s*,?\s*\)?',
                            	\"supports": ["ag", "grep", "rg", "git-grep"],
                            	\"spec_success": ["function (test)","function (test, blah)","function somefunc(test, blah)","function(blah, test)"],
                            	\"spec_failed": ["function (testLen)","function (test1, blah)","function somefunc(testFirst, blah)","function(blah, testLast)","function (Lentest)","function (blahtest, blah)","function somefunc(Firsttest, blah)","function(blah, Lasttest)"],
                            	\})
                            
    1   0.000012   0.000008 call s:add_definition('lua', {
                            	\"type": 'function',
                            	\"pcre2_regexp": 'function\s*KEYWORD\s*\(',
                            	\"emacs_regexp": 'function\s*JJJ\s*\(',
                            	\"supports": ["ag", "grep", "rg", "git-grep"],
                            	\"spec_success": ["function test()","function test ()"],
                            	\"spec_failed": [],
                            	\})
                            
    1   0.000013   0.000009 call s:add_definition('lua', {
                            	\"type": 'function',
                            	\"pcre2_regexp": 'function\s*.+[.:]KEYWORD\s*\(',
                            	\"emacs_regexp": 'function\s*.+[.:]JJJ\s*\(',
                            	\"supports": ["ag", "grep", "rg", "git-grep"],
                            	\"spec_success": ["function MyClass.test()","function MyClass.test ()","function MyClass:test()","function MyClass:test ()"],
                            	\"spec_failed": [],
                            	\})
                            
    1   0.000011   0.000008 call s:add_definition('lua', {
                            	\"type": 'function',
                            	\"pcre2_regexp": '\bKEYWORD\s*=\s*function\s*\(',
                            	\"emacs_regexp": '\bJJJ\s*=\s*function\s*\(',
                            	\"supports": ["ag", "grep", "rg", "git-grep"],
                            	\"spec_success": ["test = function()"],
                            	\"spec_failed": [],
                            	\})
                            
    1   0.000012   0.000008 call s:add_definition('lua', {
                            	\"type": 'function',
                            	\"pcre2_regexp": '\b.+\.KEYWORD\s*=\s*function\s*\(',
                            	\"emacs_regexp": '\b.+\.JJJ\s*=\s*function\s*\(',
                            	\"supports": ["ag", "grep", "rg", "git-grep"],
                            	\"spec_success": ["MyClass.test = function()"],
                            	\"spec_failed": [],
                            	\})
                            
    1   0.000017   0.000012 call s:add_definition('rust', {
                            	\"type": 'variable',
                            	\"pcre2_regexp": '\blet\s+(\([^=\n]*)?(muts+)?KEYWORD([^=\n]*\))?(:\s*[^=\n]+)?\s*=\s*[^=\n]+',
                            	\"emacs_regexp": '\blet\s+(\([^=\n]*)?(muts+)?JJJ([^=\n]*\))?(:\s*[^=\n]+)?\s*=\s*[^=\n]+',
                            	\"supports": ["ag", "grep", "rg", "git-grep"],
                            	\"spec_success": ["let test = 1234;","let test: u32 = 1234;","let test: Vec<u32> = Vec::new();","let mut test = 1234;","let mut test: Vec<u32> = Vec::new();","let (a, test, b) = (1, 2, 3);","let (a, mut test, mut b) = (1, 2, 3);","let (mut a, mut test): (u32, usize) = (1, 2);"],
                            	\"spec_failed": [],
                            	\})
                            
    1   0.000012   0.000009 call s:add_definition('rust', {
                            	\"type": 'variable',
                            	\"pcre2_regexp": '\bconst\s+KEYWORD:\s*[^=\n]+\s*=[^=\n]+',
                            	\"emacs_regexp": '\bconst\s+JJJ:\s*[^=\n]+\s*=[^=\n]+',
                            	\"supports": ["ag", "grep", "rg", "git-grep"],
                            	\"spec_success": ["const test: u32 = 1234;"],
                            	\"spec_failed": [],
                            	\})
                            
    1   0.000012   0.000009 call s:add_definition('rust', {
                            	\"type": 'variable',
                            	\"pcre2_regexp": '\bstatic\s+(mut\s+)?KEYWORD:\s*[^=\n]+\s*=[^=\n]+',
                            	\"emacs_regexp": '\bstatic\s+(mut\s+)?JJJ:\s*[^=\n]+\s*=[^=\n]+',
                            	\"supports": ["ag", "grep", "rg", "git-grep"],
                            	\"spec_success": ["static test: u32 = 1234;","static mut test: u32 = 1234;"],
                            	\"spec_failed": [],
                            	\})
                            
    1   0.000013   0.000010 call s:add_definition('rust', {
                            	\"type": 'variable',
                            	\"pcre2_regexp": '\bfn\s+.+\s*\((.+,\s+)?KEYWORD:\s*[^=\n]+\s*(,\s*.+)*\)',
                            	\"emacs_regexp": '\bfn\s+.+\s*\((.+,\s+)?JJJ:\s*[^=\n]+\s*(,\s*.+)*\)',
                            	\"supports": ["ag", "grep", "rg", "git-grep"],
                            	\"spec_success": ["fn abc(test: u32) -> u32 {","fn abc(x: u32, y: u32, test: Vec<u32>, z: Vec<Foo>)","fn abc(x: u32, y: u32, test: &mut Vec<u32>, z: Vec<Foo>)"],
                            	\"spec_failed": [],
                            	\})
                            
    1   0.000018   0.000015 call s:add_definition('rust', {
                            	\"type": 'variable',
                            	\"pcre2_regexp": '(if|while)\s+let\s+([^=\n]+)?(mut\s+)?KEYWORD([^=\n\(]+)?\s*=\s*[^=\n]+',
                            	\"emacs_regexp": '(if|while)\s+let\s+([^=\n]+)?(mut\s+)?JJJ([^=\n\(]+)?\s*=\s*[^=\n]+',
                            	\"supports": ["ag", "grep", "rg", "git-grep"],
                            	\"spec_success": ["if let Some(test) = abc() {","if let Some(mut test) = abc() {","if let Ok(test) = abc() {","if let Ok(mut test) = abc() {","if let Foo(mut test) = foo {","if let test = abc() {","if let Some(test) = abc()","if let Some((a, test, b)) = abc()","while let Some(test) = abc() {","while let Some(mut test) = abc() {","while let Ok(test) = abc() {","while let Ok(mut test) = abc() {"],
                            	\"spec_failed": ["while let test(foo) = abc() {"],
                            	\})
                            
    1   0.000018   0.000014 call s:add_definition('rust', {
                            	\"type": 'variable',
                            	\"pcre2_regexp": 'struct\s+[^\n{]+[{][^}]*(\s*KEYWORD\s*:\s*[^\n},]+)[^}]*}',
                            	\"emacs_regexp": 'struct\s+[^\n{]+[{][^}]*(\s*JJJ\s*:\s*[^\n},]+)[^}]*}',
                            	\"supports": ["ag", "grep", "rg", "git-grep"],
                            	\"spec_success": ["struct Foo { abc: u32, test: Vec<String>, b: PathBuf }","struct Foo<T>{test:Vec<T>}","struct FooBar<'a> { test: Vec<String> }"],
                            	\"spec_failed": ["struct Foo { abc: u32, b: Vec<String> }","/// ... construct the equivalent ...\nfn abc() {\n"],
                            	\})
                            
    1   0.000014   0.000010 call s:add_definition('rust', {
                            	\"type": 'variable',
                            	\"pcre2_regexp": 'enum\s+[^\n{]+\s*[{][^}]*\bKEYWORD\b[^}]*}',
                            	\"emacs_regexp": 'enum\s+[^\n{]+\s*[{][^}]*\bJJJ\b[^}]*}',
                            	\"supports": ["ag", "grep", "rg", "git-grep"],
                            	\"spec_success": ["enum Foo { VariantA, test, VariantB(u32) }","enum Foo<T> { test(T) }","enum BadStyle{test}","enum Foo32 { Bar, testing, test(u8) }"],
                            	\"spec_failed": ["enum Foo { testing }"],
                            	\})
                            
    1   0.000012   0.000008 call s:add_definition('rust', {
                            	\"type": 'function',
                            	\"pcre2_regexp": '\bfn\s+KEYWORD\s*\(',
                            	\"emacs_regexp": '\bfn\s+JJJ\s*\(',
                            	\"supports": ["ag", "grep", "rg", "git-grep"],
                            	\"spec_success": ["fn test(asdf: u32)","fn test()","pub fn test()"],
                            	\"spec_failed": [],
                            	\})
                            
    1   0.000011   0.000008 call s:add_definition('rust', {
                            	\"type": 'function',
                            	\"pcre2_regexp": '\bmacro_rules!\s+KEYWORD',
                            	\"emacs_regexp": '\bmacro_rules!\s+JJJ',
                            	\"supports": ["ag", "grep", "rg", "git-grep"],
                            	\"spec_success": ["macro_rules! test"],
                            	\"spec_failed": [],
                            	\})
                            
    1   0.000012   0.000008 call s:add_definition('rust', {
                            	\"type": 'type',
                            	\"pcre2_regexp": 'struct\s+KEYWORD\s*[{\(]?',
                            	\"emacs_regexp": 'struct\s+JJJ\s*[{\(]?',
                            	\"supports": ["ag", "grep", "rg", "git-grep"],
                            	\"spec_success": ["struct test(u32, u32)","struct test;","struct test { abc: u32, def: Vec<String> }"],
                            	\"spec_failed": [],
                            	\})
                            
    1   0.000011   0.000008 call s:add_definition('rust', {
                            	\"type": 'type',
                            	\"pcre2_regexp": 'trait\s+KEYWORD\s*[{]?',
                            	\"emacs_regexp": 'trait\s+JJJ\s*[{]?',
                            	\"supports": ["ag", "grep", "rg", "git-grep"],
                            	\"spec_success": ["trait test;","trait test { fn abc() -> u32; }"],
                            	\"spec_failed": [],
                            	\})
                            
    1   0.000012   0.000009 call s:add_definition('rust', {
                            	\"type": 'type',
                            	\"pcre2_regexp": '\btype\s+KEYWORD([^=\n]+)?\s*=[^=\n]+;',
                            	\"emacs_regexp": '\btype\s+JJJ([^=\n]+)?\s*=[^=\n]+;',
                            	\"supports": ["ag", "grep", "rg", "git-grep"],
                            	\"spec_success": ["type test<T> = Rc<RefCell<T>>;","type test = Arc<RwLock<Vec<u32>>>;"],
                            	\"spec_failed": [],
                            	\})
                            
    1   0.000013   0.000010 call s:add_definition('rust', {
                            	\"type": 'type',
                            	\"pcre2_regexp": 'impl\s+((\w+::)*\w+\s+for\s+)?(\w+::)*KEYWORD\s+[{]?',
                            	\"emacs_regexp": 'impl\s+((\w+::)*\w+\s+for\s+)?(\w+::)*JJJ\s+[{]?',
                            	\"supports": ["ag", "grep", "rg", "git-grep"],
                            	\"spec_success": ["impl test {","impl abc::test {","impl std::io::Read for test {","impl std::io::Read for abc::test {"],
                            	\"spec_failed": [],
                            	\})
                            
    1   0.000011   0.000008 call s:add_definition('rust', {
                            	\"type": 'type',
                            	\"pcre2_regexp": 'mod\s+KEYWORD\s*[{]?',
                            	\"emacs_regexp": 'mod\s+JJJ\s*[{]?',
                            	\"supports": ["ag", "grep", "rg", "git-grep"],
                            	\"spec_success": ["mod test;","pub mod test {"],
                            	\"spec_failed": [],
                            	\})
                            
    1   0.000014   0.000010 call s:add_definition('elixir', {
                            	\"type": 'function',
                            	\"pcre2_regexp": '\bdef(p)?\s+KEYWORD\s*[ ,\(]',
                            	\"emacs_regexp": '\bdef(p)?\s+JJJ\s*[ ,\(]',
                            	\"supports": ["ag", "grep", "rg", "git-grep"],
                            	\"spec_success": ["def test do","def test, do:","def test() do","def test(), do:","def test(foo, bar) do","def test(foo, bar), do:","defp test do","defp test(), do:"],
                            	\"spec_failed": [],
                            	\})
                            
    1   0.000012   0.000008 call s:add_definition('elixir', {
                            	\"type": 'variable',
                            	\"pcre2_regexp": '\s*KEYWORD\s*=[^=\n]+',
                            	\"emacs_regexp": '\s*JJJ\s*=[^=\n]+',
                            	\"supports": ["ag", "grep", "rg", "git-grep"],
                            	\"spec_success": ["test = 1234"],
                            	\"spec_failed": ["if test == 1234"],
                            	\})
                            
    1   0.000012   0.000008 call s:add_definition('elixir', {
                            	\"type": 'module',
                            	\"pcre2_regexp": 'defmodule\s+(\w+\.)*KEYWORD\s+',
                            	\"emacs_regexp": 'defmodule\s+(\w+\.)*JJJ\s+',
                            	\"supports": ["ag", "grep", "rg", "git-grep"],
                            	\"spec_success": ["defmodule test do","defmodule Foo.Bar.test do"],
                            	\"spec_failed": [],
                            	\})
                            
    1   0.000012   0.000009 call s:add_definition('elixir', {
                            	\"type": 'module',
                            	\"pcre2_regexp": 'defprotocol\s+(\w+\.)*KEYWORD\s+',
                            	\"emacs_regexp": 'defprotocol\s+(\w+\.)*JJJ\s+',
                            	\"supports": ["ag", "grep", "rg", "git-grep"],
                            	\"spec_success": ["defprotocol test do","defprotocol Foo.Bar.test do"],
                            	\"spec_failed": [],
                            	\})
                            
    1   0.000017   0.000010 call s:add_definition('erlang', {
                            	\"type": 'function',
                            	\"pcre2_regexp": '^KEYWORD\b\s*\(',
                            	\"emacs_regexp": '^JJJ\b\s*\(',
                            	\"supports": ["ag", "grep", "rg", "git-grep"],
                            	\"spec_success": ["test() ->","test()->","test(Foo) ->","test (Foo,Bar) ->","test(Foo, Bar)->"],
                            	\"spec_failed": [],
                            	\})
                            
    1   0.000012   0.000008 call s:add_definition('erlang', {
                            	\"type": 'variable',
                            	\"pcre2_regexp": '\s*KEYWORD\s*=[^:=\n]+',
                            	\"emacs_regexp": '\s*JJJ\s*=[^:=\n]+',
                            	\"supports": ["ag", "grep", "rg", "git-grep"],
                            	\"spec_success": ["test = 1234"],
                            	\"spec_failed": ["if test =:= 1234","if test == 1234"],
                            	\})
                            
    1   0.000011   0.000008 call s:add_definition('erlang', {
                            	\"type": 'module',
                            	\"pcre2_regexp": '^-module\(KEYWORD\)',
                            	\"emacs_regexp": '^-module\(JJJ\)',
                            	\"supports": ["ag", "grep", "rg", "git-grep"],
                            	\"spec_success": ["-module(test)."],
                            	\"spec_failed": [],
                            	\})
                            
    1   0.000012   0.000008 call s:add_definition('scss', {
                            	\"type": 'function',
                            	\"pcre2_regexp": '@mixin\sKEYWORD\b\s*\(',
                            	\"emacs_regexp": '@mixin\sJJJ\b\s*\(',
                            	\"supports": ["ag", "grep", "rg", "git-grep"],
                            	\"spec_success": ["@mixin test()"],
                            	\"spec_failed": [],
                            	\})
                            
    1   0.000011   0.000008 call s:add_definition('scss', {
                            	\"type": 'function',
                            	\"pcre2_regexp": '@function\sKEYWORD\b\s*\(',
                            	\"emacs_regexp": '@function\sJJJ\b\s*\(',
                            	\"supports": ["ag", "grep", "rg", "git-grep"],
                            	\"spec_success": ["@function test()"],
                            	\"spec_failed": [],
                            	\})
                            
    1   0.000011   0.000008 call s:add_definition('scss', {
                            	\"type": 'variable',
                            	\"pcre2_regexp": 'KEYWORD\s*:\s*',
                            	\"emacs_regexp": 'JJJ\s*:\s*',
                            	\"supports": ["ag", "grep", "rg", "git-grep"],
                            	\"spec_success": ["test  :"],
                            	\"spec_failed": [],
                            	\})
                            
    1   0.000014   0.000010 call s:add_definition('sml', {
                            	\"type": 'type',
                            	\"pcre2_regexp": '\s*(data)?type\s+.*\bKEYWORD\b',
                            	\"emacs_regexp": '\s*(data)?type\s+.*\bJJJ\b',
                            	\"supports": ["ag", "grep", "rg", "git-grep"],
                            	\"spec_success": ["datatype test =","datatype test=","datatype 'a test =","type test =","type 'a test =","type 'a test","type test"],
                            	\"spec_failed": ["datatypetest ="],
                            	\})
                            
    1   0.000012   0.000008 call s:add_definition('sml', {
                            	\"type": 'variable',
                            	\"pcre2_regexp": '\s*val\s+\bKEYWORD\b',
                            	\"emacs_regexp": '\s*val\s+\bJJJ\b',
                            	\"supports": ["ag", "grep", "rg", "git-grep"],
                            	\"spec_success": ["val test =","val test=","val test : bool"],
                            	\"spec_failed": [],
                            	\})
                            
    1   0.000013   0.000010 call s:add_definition('sml', {
                            	\"type": 'function',
                            	\"pcre2_regexp": '\s*fun\s+\bKEYWORD\b.*\s*=',
                            	\"emacs_regexp": '\s*fun\s+\bJJJ\b.*\s*=',
                            	\"supports": ["ag", "grep", "rg", "git-grep"],
                            	\"spec_success": ["fun test list =","fun test (STRING_NIL, a) =","fun test ((s1,s2): 'a queue) : 'a * 'a queue =","fun test (var : q) : int =","fun test f e xs ="],
                            	\"spec_failed": [],
                            	\})
                            
    1   0.000014   0.000010 call s:add_definition('sml', {
                            	\"type": 'module',
                            	\"pcre2_regexp": '\s*(structure|signature|functor)\s+\bKEYWORD\b',
                            	\"emacs_regexp": '\s*(structure|signature|functor)\s+\bJJJ\b',
                            	\"supports": ["ag", "grep", "rg", "git-grep"],
                            	\"spec_success": ["structure test =","structure test : MYTEST =","signature test =","functor test (T:TEST) =","functor test(T:TEST) ="],
                            	\"spec_failed": [],
                            	\})
                            
    1   0.000015   0.000011 call s:add_definition('sql', {
                            	\"type": 'function',
                            	\"pcre2_regexp": '(CREATE|create)\s+(.+?\s+)?(FUNCTION|function|PROCEDURE|procedure)\s+KEYWORD\s*\(',
                            	\"emacs_regexp": '(CREATE|create)\s+(.+?\s+)?(FUNCTION|function|PROCEDURE|procedure)\s+JJJ\s*\(',
                            	\"supports": ["ag", "grep", "rg", "git-grep"],
                            	\"spec_success": ["CREATE FUNCTION test(i INT) RETURNS INT","create or replace function test (int)","CREATE PROCEDURE test (OUT p INT)","create definer = 'test'@'localhost' procedure test()"],
                            	\"spec_failed": [],
                            	\})
                            
    1   0.000014   0.000011 call s:add_definition('sql', {
                            	\"type": 'table',
                            	\"pcre2_regexp": '(CREATE|create)\s+(.+?\s+)?(TABLE|table)(\s+(IF NOT EXISTS|if not exists))?\s+KEYWORD\b',
                            	\"emacs_regexp": '(CREATE|create)\s+(.+?\s+)?(TABLE|table)(\s+(IF NOT EXISTS|if not exists))?\s+JJJ\b',
                            	\"supports": ["ag", "grep", "rg", "git-grep"],
                            	\"spec_success": ["CREATE TABLE test (","create temporary table if not exists test","CREATE TABLE IF NOT EXISTS test (","create global temporary table test"],
                            	\"spec_failed": [],
                            	\})
                            
    1   0.000015   0.000011 call s:add_definition('sql', {
                            	\"type": 'view',
                            	\"pcre2_regexp": '(CREATE|create)\s+(.+?\s+)?(VIEW|view)\s+KEYWORD\b',
                            	\"emacs_regexp": '(CREATE|create)\s+(.+?\s+)?(VIEW|view)\s+JJJ\b',
                            	\"supports": ["ag", "grep", "rg", "git-grep"],
                            	\"spec_success": ["CREATE VIEW test (","create sql security definer view test","CREATE OR REPLACE VIEW test AS foo"],
                            	\"spec_failed": [],
                            	\})
                            
    1   0.000014   0.000011 call s:add_definition('sql', {
                            	\"type": 'type',
                            	\"pcre2_regexp": '(CREATE|create)\s+(.+?\s+)?(TYPE|type)\s+KEYWORD\b',
                            	\"emacs_regexp": '(CREATE|create)\s+(.+?\s+)?(TYPE|type)\s+JJJ\b',
                            	\"supports": ["ag", "grep", "rg", "git-grep"],
                            	\"spec_success": ["CREATE TYPE test","CREATE OR REPLACE TYPE test AS foo (","create type test as ("],
                            	\"spec_failed": [],
                            	\})
                            
    1   0.000016   0.000012 call s:add_definition('systemverilog', {
                            	\"type": 'type',
                            	\"pcre2_regexp": '\s*class\s+\bKEYWORD\b',
                            	\"emacs_regexp": '\s*class\s+\bJJJ\b',
                            	\"supports": ["ag", "grep", "rg", "git-grep"],
                            	\"spec_success": ["virtual class test;","class test;","class test extends some_class"],
                            	\"spec_failed": ["virtual class testing;","class test2;","class some_test","class some_class extends test"],
                            	\})
                            
    1   0.000012   0.000008 call s:add_definition('systemverilog', {
                            	\"type": 'type',
                            	\"pcre2_regexp": '\s*task\s+\bKEYWORD\b',
                            	\"emacs_regexp": '\s*task\s+\bJJJ\b',
                            	\"supports": ["ag", "grep", "rg", "git-grep"],
                            	\"spec_success": ["task test (","task test("],
                            	\"spec_failed": ["task testing (","task test2("],
                            	\})
                            
    1   0.000014   0.000011 call s:add_definition('systemverilog', {
                            	\"type": 'type',
                            	\"pcre2_regexp": '\s*\bKEYWORD\b\s*=',
                            	\"emacs_regexp": '\s*\bJJJ\b\s*=',
                            	\"supports": ["ag", "grep", "rg", "git-grep"],
                            	\"spec_success": ["assign test =","assign test=","int test =","int test="],
                            	\"spec_failed": ["assign testing =","assign test2="],
                            	\})
                            
    1   0.000012   0.000009 call s:add_definition('systemverilog', {
                            	\"type": 'function',
                            	\"pcre2_regexp": 'function\s[^\s]+\s*\bKEYWORD\b',
                            	\"emacs_regexp": 'function\s[^\s]+\s*\bJJJ\b',
                            	\"supports": ["ag", "rg", "git-grep"],
                            	\"spec_success": ["function Matrix test ;","function Matrix test;"],
                            	\"spec_failed": ["function test blah"],
                            	\})
                            
    1   0.000013   0.000010 call s:add_definition('systemverilog', {
                            	\"type": 'function',
                            	\"pcre2_regexp": '^\s*[^\s]*\s*[^\s]+\s+\bKEYWORD\b',
                            	\"emacs_regexp": '^\s*[^\s]*\s*[^\s]+\s+\bJJJ\b',
                            	\"supports": ["ag", "rg", "git-grep"],
                            	\"spec_success": ["some_class_name test","  another_class_name  test ;","some_class test[];","some_class #(1) test"],
                            	\"spec_failed": ["test some_class_name","class some_class extends test"],
                            	\})
                            
    1   0.000013   0.000009 call s:add_definition('vhdl', {
                            	\"type": 'type',
                            	\"pcre2_regexp": '\s*type\s+\bKEYWORD\b',
                            	\"emacs_regexp": '\s*type\s+\bJJJ\b',
                            	\"supports": ["ag", "grep", "rg", "git-grep"],
                            	\"spec_success": ["type test is","type test  is"],
                            	\"spec_failed": ["type testing is","type test2  is"],
                            	\})
                            
    1   0.000016   0.000013 call s:add_definition('vhdl', {
                            	\"type": 'type',
                            	\"pcre2_regexp": '\s*constant\s+\bKEYWORD\b',
                            	\"emacs_regexp": '\s*constant\s+\bJJJ\b',
                            	\"supports": ["ag", "grep", "rg", "git-grep"],
                            	\"spec_success": ["constant test :","constant test:"],
                            	\"spec_failed": ["constant testing ","constant test2:"],
                            	\})
                            
    1   0.000013   0.000009 call s:add_definition('vhdl', {
                            	\"type": 'function',
                            	\"pcre2_regexp": 'function\s*\"?KEYWORD\"?\s*\(',
                            	\"emacs_regexp": 'function\s*\"?JJJ\"?\s*\(',
                            	\"supports": ["ag", "grep", "rg", "git-grep"],
                            	\"spec_success": ["function test(signal)","function test (signal)","function \"test\" (signal)"],
                            	\"spec_failed": ["function testing(signal"],
                            	\})
                            
    1   0.000014   0.000010 call s:add_definition('tex', {
                            	\"type": 'command',
                            	\"pcre2_regexp": '\\.*newcommand\*?\s*\{\s*(\\)KEYWORD\s*}',
                            	\"emacs_regexp": '\\.*newcommand\*?\s*\{\s*(\\)JJJ\s*}',
                            	\"supports": ["ag", "grep", "rg", "git-grep"],
                            	\"spec_success": ["\\newcommand{\\test}","\\renewcommand{\\test}","\\renewcommand*{\\test}","\\newcommand*{\\test}","\\renewcommand{ \\test }"],
                            	\"spec_failed": ["\\test","test"],
                            	\})
                            
    1   0.000013   0.000010 call s:add_definition('tex', {
                            	\"type": 'command',
                            	\"pcre2_regexp": '\\.*newcommand\*?\s*(\\)KEYWORD($|[^a-zA-Z0-9\?\*-])',
                            	\"emacs_regexp": '\\.*newcommand\*?\s*(\\)JJJ\j',
                            	\"supports": ["ag", "grep", "rg", "git-grep"],
                            	\"spec_success": ["\\newcommand\\test {}","\\renewcommand\\test{}","\\newcommand \\test"],
                            	\"spec_failed": ["\\test","test"],
                            	\})
                            
    1   0.000013   0.000009 call s:add_definition('tex', {
                            	\"type": 'length',
                            	\"pcre2_regexp": '\\(s)etlength\s*\{\s*(\\)KEYWORD\s*}',
                            	\"emacs_regexp": '\\(s)etlength\s*\{\s*(\\)JJJ\s*}',
                            	\"supports": ["ag", "grep", "rg", "git-grep"],
                            	\"spec_success": ["\\setlength { \\test}","\\setlength{\\test}","\\setlength{\\test}{morecommands}"],
                            	\"spec_failed": ["\\test","test"],
                            	\})
                            
    1   0.000012   0.000008 call s:add_definition('tex', {
                            	\"type": 'counter',
                            	\"pcre2_regexp": '\\newcounter\{\s*KEYWORD\s*}',
                            	\"emacs_regexp": '\\newcounter\{\s*JJJ\s*}',
                            	\"supports": ["ag", "grep", "rg", "git-grep"],
                            	\"spec_success": ["\\newcounter{test}"],
                            	\"spec_failed": ["\\test","test"],
                            	\})
                            
    1   0.000013   0.000010 call s:add_definition('tex', {
                            	\"type": 'environment',
                            	\"pcre2_regexp": '\\.*newenvironment\s*\{\s*KEYWORD\s*}',
                            	\"emacs_regexp": '\\.*newenvironment\s*\{\s*JJJ\s*}',
                            	\"supports": ["ag", "grep", "rg", "git-grep"],
                            	\"spec_success": ["\\newenvironment{test}","\\newenvironment {test}{morecommands}","\\lstnewenvironment{test}","\\newenvironment {test}"],
                            	\"spec_failed": ["\\test","test"],
                            	\})
                            
    1   0.000012   0.000008 call s:add_definition('pascal', {
                            	\"type": 'function',
                            	\"pcre2_regexp": '\bfunction\s+KEYWORD\b',
                            	\"emacs_regexp": '\bfunction\s+JJJ\b',
                            	\"supports": ["ag", "grep", "rg", "git-grep"],
                            	\"spec_success": ["  function test : "],
                            	\"spec_failed": [],
                            	\})
                            
    1   0.000011   0.000008 call s:add_definition('pascal', {
                            	\"type": 'function',
                            	\"pcre2_regexp": '\bprocedure\s+KEYWORD\b',
                            	\"emacs_regexp": '\bprocedure\s+JJJ\b',
                            	\"supports": ["ag", "grep", "rg", "git-grep"],
                            	\"spec_success": ["  procedure test ; "],
                            	\"spec_failed": [],
                            	\})
                            
    1   0.000013   0.000009 call s:add_definition('fsharp', {
                            	\"type": 'variable',
                            	\"pcre2_regexp": 'let\s+KEYWORD\b.*\=',
                            	\"emacs_regexp": 'let\s+JJJ\b.*\=',
                            	\"supports": ["ag", "grep", "git-grep"],
                            	\"spec_success": ["let test = 1234","let test() = 1234","let test abc def = 1234"],
                            	\"spec_failed": ["let testnot = 1234","let testnot() = 1234","let testnot abc def = 1234"],
                            	\})
                            
    1   0.000012   0.000009 call s:add_definition('fsharp', {
                            	\"type": 'interface',
                            	\"pcre2_regexp": 'member(\b.+\.|\s+)KEYWORD\b.*\=',
                            	\"emacs_regexp": 'member(\b.+\.|\s+)JJJ\b.*\=',
                            	\"supports": ["ag", "grep", "git-grep"],
                            	\"spec_success": ["member test = 1234","member this.test = 1234"],
                            	\"spec_failed": ["member testnot = 1234","member this.testnot = 1234"],
                            	\})
                            
    1   0.000011   0.000008 call s:add_definition('fsharp', {
                            	\"type": 'type',
                            	\"pcre2_regexp": 'type\s+KEYWORD\b.*\=',
                            	\"emacs_regexp": 'type\s+JJJ\b.*\=',
                            	\"supports": ["ag", "grep", "git-grep"],
                            	\"spec_success": ["type test = 1234"],
                            	\"spec_failed": ["type testnot = 1234"],
                            	\})
                            
    1   0.000012   0.000008 call s:add_definition('kotlin', {
                            	\"type": 'function',
                            	\"pcre2_regexp": 'fun\s*(<[^>]*>)?\s*KEYWORD\s*\(',
                            	\"emacs_regexp": 'fun\s*(<[^>]*>)?\s*JJJ\s*\(',
                            	\"supports": ["ag", "grep", "rg", "git-grep"],
                            	\"spec_success": ["fun test()","fun <T> test()"],
                            	\"spec_failed": [],
                            	\})
                            
    1   0.000013   0.000009 call s:add_definition('kotlin', {
                            	\"type": 'variable',
                            	\"pcre2_regexp": '(val|var)\s*KEYWORD\b',
                            	\"emacs_regexp": '(val|var)\s*JJJ\b',
                            	\"supports": ["ag", "grep", "rg", "git-grep"],
                            	\"spec_success": ["val test ","var test"],
                            	\"spec_failed": ["val testval","var testvar"],
                            	\})
                            
    1   0.000012   0.000008 call s:add_definition('kotlin', {
                            	\"type": 'type',
                            	\"pcre2_regexp": '(class|interface)\s*KEYWORD\b',
                            	\"emacs_regexp": '(class|interface)\s*JJJ\b',
                            	\"supports": ["ag", "grep", "rg", "git-grep"],
                            	\"spec_success": ["class test","class test : SomeInterface","interface test"],
                            	\"spec_failed": [],
                            	\})
                            
    1   0.000014   0.000010 call s:add_definition('zig', {
                            	\"type": 'function',
                            	\"pcre2_regexp": 'fn\s+KEYWORD\b',
                            	\"emacs_regexp": 'fn\s+JJJ\b',
                            	\"supports": ["ag", "grep", "rg", "git-grep"],
                            	\"spec_success": ["fn test() void {","fn test(a: i32) i32 {","pub fn test(a: i32) i32 {","export fn test(a: i32) i32 {","extern \"c\" fn test(a: i32) i32 {","inline fn test(a: i32) i32 {"],
                            	\"spec_failed": [],
                            	\})
                            
    1   0.000012   0.000008 call s:add_definition('zig', {
                            	\"type": 'variable',
                            	\"pcre2_regexp": '(var|const)\s+KEYWORD\b',
                            	\"emacs_regexp": '(var|const)\s+JJJ\b',
                            	\"supports": ["ag", "grep", "rg", "git-grep"],
                            	\"spec_success": ["const test: i32 = 3;","var test: i32 = 3;","pub const test: i32 = 3;"],
                            	\"spec_failed": [],
                            	\})
                            
    1   0.000013   0.000009 call s:add_definition('protobuf', {
                            	\"type": 'message',
                            	\"pcre2_regexp": 'message\s+KEYWORD\s*\{',
                            	\"emacs_regexp": 'message\s+JJJ\s*\{',
                            	\"supports": ["ag", "grep", "rg", "git-grep"],
                            	\"spec_success": ["message test{","message test {"],
                            	\"spec_failed": [],
                            	\})
                            
    1   0.000011   0.000008 call s:add_definition('protobuf', {
                            	\"type": 'enum',
                            	\"pcre2_regexp": 'enum\s+KEYWORD\s*\{',
                            	\"emacs_regexp": 'enum\s+JJJ\s*\{',
                            	\"supports": ["ag", "grep", "rg", "git-grep"],
                            	\"spec_success": ["enum test{","enum test {"],
                            	\"spec_failed": [],
                            	\})
                            
    1   0.000016   0.000012 call s:add_definition('apex', {
                            	\"type": 'function',
                            	\"pcre2_regexp": '^\s*(?:[\w\[\]]+\s+){1,3}KEYWORD\s*\(',
                            	\"emacs_regexp": '^\s*(?:[\w\[\]]+\s+){1,3}JJJ\s*\(',
                            	\"supports": ["ag", "rg"],
                            	\"spec_success": ["int test()","int test(param)","static int test()","static int test(param)","public static MyType test()","private virtual SomeType test(param)","static int test()","private foo[] test()"],
                            	\"spec_failed": ["test()","testnot()","blah = new test()","foo bar = test()"],
                            	\})
                            
    1   0.000012   0.000008 call s:add_definition('apex', {
                            	\"type": 'variable',
                            	\"pcre2_regexp": '\s*\bKEYWORD\s*=[^=\n)]+',
                            	\"emacs_regexp": '\s*\bJJJ\s*=[^=\n)]+',
                            	\"supports": ["ag", "grep", "rg", "git-grep"],
                            	\"spec_success": ["int test = 1234"],
                            	\"spec_failed": ["if test == 1234:","int nottest = 44"],
                            	\})
                            
    1   0.000014   0.000010 call s:add_definition('apex', {
                            	\"type": 'type',
                            	\"pcre2_regexp": '(class|interface)\s*KEYWORD\b',
                            	\"emacs_regexp": '(class|interface)\s*JJJ\b',
                            	\"supports": ["ag", "grep", "rg", "git-grep"],
                            	\"spec_success": ["class test:","public class test implements Something"],
                            	\"spec_failed": ["class testnot:","public class testnot implements Something"],
                            	\})

SCRIPT  /Users/kaizhi/.local/share/nvim/lazy/any-jump.vim/autoload/internal_buffer.vim
Sourced 1 time
Total time:   0.000349
 Self time:   0.000349

count  total (s)   self (s)
                            " ----------------------------------------------
                            " Internal buffer prototype definition
                            " ----------------------------------------------
                            " represents ui internal structure
                            
                            " abstract structure of internal buffer representation:
                            "
                            " buffer = [ array of lines ]
                            "
                            " line = [ list of items
                            "   { type, strat_col, finish_col, text, hl_group },
                            "   { ... },
                            "   ...
                            " ]
                            
    1              0.000004 let s:nvim = has('nvim')
                            
    1              0.000001 let s:InternalBuffer = {}
                            
    1              0.000011 let s:InternalBuffer.MethodsList = [
                                  \'RenderLine',
                                  \'AddLine',
                                  \'AddLineAt',
                                  \'CreateItem',
                                  \'len',
                                  \'GetItemByPos',
                                  \'GetItemLineNumber',
                                  \'GetItemLineNumberByData',
                                  \'GetFirstItemOfType',
                                  \'TryFindOriginalLinkFromPos',
                                  \'TryRestoreCursorForItem',
                                  \'RenderUiUsagesList',
                                  \'RenderUi',
                                  \'HelpSection',
                                  \'StartUiTransaction',
                                  \'EndUiTransaction',
                                  \'GrepResultToItems',
                                  \'GrepResultToGroupedItems',
                                  \'RemoveGarbagedLines',
                                  \'JumpToFirstOfType',
                                  \'ClearBuffer',
                                  \'BufferLnum',
                                  \'RestorePopupCursor',
                                  \]
                            
                            " Produce new Render Buffer
    1              0.000002 fu! s:InternalBuffer.New() abort
                              let object = {
                                    \"items":                    [],
                                    \"current_page":             0,
                                    \"gc":                       v:false,
                                    \"preview_opened":           v:false,
                                    \"usages_opened":            v:false,
                                    \"grouping_enabled":         v:false,
                                    \"overmaxed_results_hidden": v:true,
                                    \"definitions_grep_results": [],
                                    \"usages_grep_results":      [],
                                    \"vim_bufnr":                0,
                                    \"popup_winid":              0,
                                    \"previous_bufnr":           0,
                                    \}
                            
                              for method in self.MethodsList
                                let object[method] = s:InternalBuffer[method]
                              endfor
                            
                              return object
                            endfu
                            
    1              0.000001 fu! s:InternalBuffer.len() dict abort
                              return len(self.items)
                            endfu
                            
    1              0.000001 fu! s:InternalBuffer.RenderLine(items, line) dict abort
                              let text           = s:nvim ? " " : ""
                              let idx            = 0
                              let next_start_col = 1
                            
                              " calculate & assign items start & end columns
                              for item in a:items
                                " separate items in line with 1 space
                                if idx == 0
                                  let text = text . item.text
                                else
                                  if has_key(item.data, 'no_padding')
                                    let text = text . item.text
                                  else
                                    let text = text . ' ' . item.text
                                    let next_start_col = next_start_col + 1
                                  endif
                                endif
                            
                                let item.start_col = next_start_col
                                let item.end_col   = next_start_col + len(item.text)
                            
                                let next_start_col  = item.end_col
                                let idx            += 1
                              endfor
                            
                              " filter out empty whitespaces
                              if text =~ '^\s\+$'
                                let text = ''
                              endif
                            
                              " write final text to buffer
                              call appendbufline(self.vim_bufnr, a:line - 1, text)
                            
                              " colorize
                              for item in a:items
                                if s:nvim
                                  call nvim_buf_add_highlight(
                                        \self.vim_bufnr,
                                        \-1,
                                        \item.hl_group,
                                        \a:line - 1,
                                        \item.start_col,
                                        \item.end_col)
                                else
                                  call prop_add(a:line, item.start_col, {
                                        \'length': item.len,
                                        \'type': item.hl_group,
                                        \'bufnr': self.vim_bufnr})
                                endif
                              endfor
                            endfu
                            
    1              0.000001 fu! s:InternalBuffer.AddLine(items) dict abort
                              if type(a:items) == v:t_list
                                call self.RenderLine(a:items, self.len() + 1)
                                call add(self.items, a:items)
                            
                                return v:true
                              else
                                echoe "array required, got invalid type: " . string(a:items)
                            
                                return v:false
                              endif
                            endfu
                            
    1              0.000001 fu! s:InternalBuffer.AddLineAt(items, line_number) dict abort
                              if type(a:items) == v:t_list
                                call self.RenderLine(a:items, a:line_number)
                                call insert(self.items, a:items, a:line_number - 1)
                            
                                return v:true
                              else
                                echoe "array required, got invalid type: " . string(a:items)
                            
                                return v:false
                              endif
                            endfu
                            
                            " type:
                            "   'text' / 'link' / 'button' / 'preview_text'
    1              0.000001 fu! s:InternalBuffer.CreateItem(type, text, hl_group, ...) dict abort
                              let data = {}
                            
                              if a:0
                                let data = a:1
                              endif
                            
                              let item = {
                                    \"type":      a:type,
                                    \"text":      a:text,
                                    \"len":       len(a:text),
                                    \"start_col": 0,
                                    \"end_col":   0,
                                    \"hl_group":  a:hl_group,
                                    \"gc":        v:false,
                                    \"data":      data
                                    \}
                            
                              " TODO: optimize this part for rednering perfomance
                              if !s:nvim
                                if prop_type_get(item.hl_group, {'bufnr': self.vim_bufnr}) == {}
                                  call prop_type_add(item.hl_group, {
                                        \'highlight': item.hl_group,
                                        \'bufnr': self.vim_bufnr
                                        \})
                                endif
                              endif
                            
                              return item
                            endfu
                            
                            
    1              0.000001 fu! s:InternalBuffer.GetItemByPos() dict abort
                              if s:nvim
                                let idx = getbufinfo(self.vim_bufnr)[0]['lnum']
                              else
                                " vim popup buffer doesn't have current line info inside getbufinfo()
                                " so extract line nr from win
                                let l:popup_pos = 0
                                call win_execute(self.popup_winid, 'let l:popup_pos = getcurpos()')
                                let idx = l:popup_pos[1]
                              end
                            
                              if idx > len(self.items)
                                return 0
                              endif
                            
                              if s:nvim
                                let column = col('.')
                              else
                                let column = 1
                              end
                            
                              let line = self.items[idx - 1]
                            
                              for item in line
                                if item.start_col <= column && (item.end_col >= column || item.end_col == -1 )
                                  return item
                                endif
                              endfor
                            
                              return 0
                            endfu
                            
                            " not optimal, but ok for current ui with around ~100/200 lines
                            " COMPLEXITY: O(1)
    1              0.000001 fu! s:InternalBuffer.GetItemLineNumber(item) dict abort
                              let i = 0
                              let found = 0
                            
                              for line in self.items
                                let i += 1
                            
                                for item in line
                                  if item == a:item
                                    let found = i
                                    break
                                  endif
                                endfor
                            
                                if found > 0
                                  break
                                endif
                              endfor
                            
                              return found
                            endfu
                            
                            " not optimal, but ok for current ui with around ~100/200 lines
                            " COMPLEXITY: O(1)
    1              0.000001 fu! s:InternalBuffer.GetItemLineNumberByData(data) dict abort
                              let i = 0
                              let found = 0
                            
                              for line in self.items
                                let i += 1
                            
                                for item in line
                                  if item.data == a:data
                                    let found = i
                                    break
                                  endif
                                endfor
                            
                                if found > 0
                                  break
                                endif
                              endfor
                            
                              return found
                            endfu
                            
    1              0.000001 fu! s:InternalBuffer.GetFirstItemOfType(type, ...) dict abort
                              let result = 0
                              let layer  = 0
                            
                              if a:0 == 1
                                let layer = a:1
                              endif
                            
                              for line in self.items
                                if type(result) == v:t_dict
                                  break
                                endif
                            
                                for item in line
                                  let type_is_ok  = item.type == a:type
                                  let layer_is_ok = v:true
                            
                                  if type(layer) == v:t_string
                                    let layer_is_ok = item.data.layer == layer
                                  endif
                            
                                  if type_is_ok && layer_is_ok
                                    let result = item
                                    break
                                  endif
                                endfor
                              endfor
                            
                              return result
                            endfu
                            
    1              0.000001 fu! s:InternalBuffer.TryFindOriginalLinkFromPos() dict abort
                              let cursor_item = self.GetItemByPos()
                            
                              " try to find original link
                              if type(cursor_item) == v:t_dict && type(cursor_item.data) == v:t_dict
                                    \ && cursor_item.type == 'link'
                                    \ && !has_key(cursor_item, 'original_link')
                                let ln   = self.GetItemLineNumber(cursor_item)
                                let line = self.items[ln - 1]
                            
                                for item in line
                                  if type(item.data) == v:t_dict && has_key(item.data, 'original_link')
                                    let cursor_item = item
                                    break
                                  endif
                                endfor
                              endif
                            
                              return cursor_item
                            endfu
                            
    1              0.000001 fu! s:InternalBuffer.TryRestoreCursorForItem(item,...) dict abort
                              let opts = {}
                              if a:0 == 1 && type(a:1) == v:t_dict
                                let opts = a:1
                              endif
                            
                              if type(a:item) == v:t_dict
                                    \ && a:item.type == "link"
                                    \ && !has_key(a:item.data, 'group_header')
                            
                                  let new_ln = self.GetItemLineNumberByData(a:item.data)
                            
                                  " item removed
                                  if new_ln == 0
                                    call self.JumpToFirstOfType('link')
                                  else
                                    call cursor(new_ln, 2)
                                  endif
                              else
                                if has_key(opts, 'last_ln_nr')
                                  if opts.last_ln_nr > self.len()
                                    call self.JumpToFirstOfType('link')
                                  else
                                    call cursor(opts.last_ln_nr, 2)
                                    call cursor(opts.last_ln_nr, 2)
                                  endif
                                else
                                  call self.JumpToFirstOfType('link')
                                endif
                              endif
                            endfu
                            
    1              0.000001 fu! s:InternalBuffer.JumpToFirstOfType(type, ...) dict abort
                              let item = self.GetFirstItemOfType(a:type, a:000)
                            
                              if type(item) == v:t_dict
                                let ln = self.GetItemLineNumber(item)
                                call cursor(ln, 2)
                              endif
                            endfu
                            
    1              0.000001 fu! s:InternalBuffer.ClearBuffer(buf) dict abort
                              call deletebufline(a:buf, 1, self.len() + 1)
                            endfu
                            
    1              0.000001 fu! s:InternalBuffer.BufferLnum() dict abort
                              return getbufinfo(self.vim_bufnr)[0]['lnum']
                            endfu
                            
    1              0.000001 fu! s:InternalBuffer.RestorePopupCursor() dict abort
                              if !s:nvim
                                call popup_filter_menu(self.popup_winid, 'j')
                              endif
                            endfu
                            
    1              0.000001 fu! s:InternalBuffer.StartUiTransaction() dict abort
                              if !s:nvim
                                return
                              endif
                            
                              call setbufvar(self.vim_bufnr, '&modifiable', 1)
                            endfu
                            
    1              0.000001 fu! s:InternalBuffer.EndUiTransaction() dict abort
                              if !s:nvim
                                return
                              endif
                            
                              call setbufvar(self.vim_bufnr, '&modifiable', 0)
                            endfu
                            
    1              0.000001 fu! s:InternalBuffer.GrepResultToItems(gr, current_idx, layer) dict abort
                              let gr    = a:gr
                              let items = []
                            
                              let options =
                                    \{ "path": gr.path, "line_number": gr.line_number, "layer": a:layer }
                              let original_link_options =
                                    \{ "path": gr.path, "line_number": gr.line_number,
                                    \"layer": a:layer, "original_link": v:true }
                            
                              if g:any_jump_list_numbers
                                let prefix_text = a:current_idx + 1
                                let prefix = self.CreateItem("link", prefix_text, g:AnyJumpGetColor('result_line_number'), options)
                            
                                call add(items, prefix)
                              endif
                            
                              if g:any_jump_results_ui_style == 'filename_first'
                                let path_text    = gr.path .  ":" . gr.line_number
                                let matched_text = self.CreateItem("link", "" . gr.text, g:AnyJumpGetColor('result_text'), original_link_options)
                                let file_path    = self.CreateItem("link", path_text, g:AnyJumpGetColor('result_path'), options)
                            
                                call add(items, file_path)
                                call add(items, matched_text)
                              elseif g:any_jump_results_ui_style == 'filename_last'
                                let path_text    = '' .  gr.path .  ":" . gr.line_number
                                let matched_text = self.CreateItem("link", gr.text, g:AnyJumpGetColor('result_text'), original_link_options)
                                let file_path    = self.CreateItem("link", path_text, g:AnyJumpGetColor('result_path'), options)
                            
                                call add(items, matched_text)
                                call add(items, file_path)
                              endif
                            
                              return items
                            endfu
                            
    1              0.000001 fu! s:InternalBuffer.GrepResultToGroupedItems(gr, current_idx, layer) dict abort
                              let gr      = a:gr
                              let items   = []
                            
                              let options =
                                    \{ "path": gr.path, "line_number": gr.line_number, "layer": a:layer }
                              let original_link_options =
                                    \{ "path": gr.path, "line_number": gr.line_number,
                                    \"layer": a:layer, "original_link": v:true }
                            
                              let prefix_text = gr.line_number
                              let prefix = self.CreateItem("link", prefix_text, g:AnyJumpGetColor('result_line_number'), options)
                            
                              call add(items, prefix)
                            
                              let matched_text = self.CreateItem("link", gr.text, g:AnyJumpGetColor('result_text'), original_link_options)
                            
                              call add(items, matched_text)
                            
                              return items
                            endfu
                            
    1              0.000001 fu! s:InternalBuffer.RenderUiUsagesList(grep_results, start_ln) dict abort
                              let start_ln     = a:start_ln
                              let hidden_count = 0
                            
                              " TODO: move to method
                              if type(g:any_jump_max_search_results) == v:t_number
                                    \ && g:any_jump_max_search_results > 0
                                    \ && self.overmaxed_results_hidden == v:true
                            
                                let cp = self.current_page ? self.current_page : 1
                                let to = (cp * g:any_jump_max_search_results) - 1
                            
                                let collection   = self.usages_grep_results[0 : to]
                                let hidden_count = len(self.usages_grep_results[to : -1])
                              else
                                let collection = self.usages_grep_results
                              endif
                            
                              call self.AddLineAt([
                                \self.CreateItem("text", ">", g:AnyJumpGetColor('heading_text'), {'layer': 'usages'}),
                                \self.CreateItem("text", self.keyword, g:AnyJumpGetColor('heading_keyword'), {'layer': 'usages'}),
                                \self.CreateItem("text", len(self.usages_grep_results) . " references", g:AnyJumpGetColor('heading_text'), {'layer': 'usages'}),
                                \], start_ln)
                            
                            
                              let start_ln += 1
                            
                              call self.AddLineAt([ self.CreateItem("text", "", "Comment", {"layer": "usages"}) ], start_ln)
                            
                              let start_ln += 1
                            
                              let idx = 0
                              if self.grouping_enabled
                                " group by file name rendering
                                let render_map = {}
                            
                                for gr in collection
                                  if !has_key(render_map, gr.path)
                                    let render_map[gr.path] = []
                                  endif
                            
                                  call add(render_map[gr.path], gr)
                                endfor
                            
                                let path_idx = 0
                                for path in keys(render_map)
                                  let first_gr = render_map[path][0]
                                  let opts     = {
                                        \"path":         path,
                                        \"line_number":  first_gr.line_number,
                                        \"layer":        "usages",
                                        \"group_header": v:true,
                                        \}
                            
                                  let prefix     = self.CreateItem("link", ">", g:AnyJumpGetColor('group_text'), opts)
                                  let group_name = self.CreateItem("link", path, g:AnyJumpGetColor('group_name'), opts)
                                  let line       = [ prefix, group_name ]
                            
                                  call self.AddLineAt(line, start_ln)
                                  let start_ln += 1
                            
                                  for gr in render_map[path]
                                    let items = self.GrepResultToGroupedItems(gr, idx, "usages")
                                    call self.AddLineAt(items, start_ln)
                            
                                    let start_ln += 1
                                    let idx += 1
                                  endfor
                            
                                  if path_idx != len(keys(render_map)) - 1
                                    call self.AddLineAt([ self.CreateItem("text", "", "Comment", {"layer": "usages"}) ], start_ln)
                            
                                    let start_ln += 1
                                  endif
                            
                                  let path_idx += 1
                                endfor
                              else
                                for gr in collection
                                  let items = self.GrepResultToItems(gr, idx, "usages")
                                  call self.AddLineAt(items, start_ln)
                            
                                  let idx += 1
                                  let start_ln += 1
                                endfor
                              endif
                            
                              if hidden_count > 0
                                call self.AddLineAt([ self.CreateItem("text", "", "Comment", {"layer": "usages"}) ], start_ln)
                                let start_ln += 1
                            
                                call self.AddLineAt([
                                      \self.CreateItem("more_button", '[ ' . hidden_count . ' more ]', g:AnyJumpGetColor('more_button'), {"layer": "usages"}),
                                      \self.CreateItem("more_button", '— [a] load more results [A] load all', g:AnyJumpGetColor('more_explain'), {"layer": "usages"}),
                                      \], start_ln)
                                let start_ln += 1
                              endif
                            
                              call self.AddLineAt([ self.CreateItem("text", " ", "Comment", {"layer": "usages"}) ], start_ln)
                            
                              return v:true
                            endfu
                            
    1              0.000001 fu! s:InternalBuffer.RenderUi() dict abort
                              " clear items before render
                              let self.items = []
                            
                              call self.AddLine([ self.CreateItem("text", "", "Comment") ])
                            
                              call self.AddLine([
                                \self.CreateItem("text", ">", g:AnyJumpGetColor('heading_text')),
                                \self.CreateItem("text", self.keyword, g:AnyJumpGetColor('heading_keyword')),
                                \self.CreateItem("text", len(self.definitions_grep_results) . " definitions", g:AnyJumpGetColor('heading_text')),
                                \])
                            
                              call self.AddLine([ self.CreateItem("text", "", "Comment") ])
                            
                              " draw grep results
                              let idx          = 0
                              let hidden_count = 0
                            
                              " TODO: move to method
                              if type(g:any_jump_max_search_results) == v:t_number
                                    \ && g:any_jump_max_search_results > 0
                                    \ && self.overmaxed_results_hidden == v:true
                            
                                let cp = self.current_page ? self.current_page : 1
                                let to = (cp * g:any_jump_max_search_results) - 1
                            
                                let collection   = self.definitions_grep_results[0 : to]
                                let hidden_count = len(self.definitions_grep_results[to : -1])
                              else
                                let collection = self.definitions_grep_results
                              endif
                            
                              if self.grouping_enabled
                                " group by file name rendering
                                let render_map = {}
                            
                                for gr in collection
                                  if !has_key(render_map, gr.path)
                                    let render_map[gr.path] = []
                                  endif
                            
                                  call add(render_map[gr.path], gr)
                                endfor
                            
                                let path_idx = 0
                            
                                for path in keys(render_map)
                                  let first_gr = render_map[path][0]
                                  let opts     = {
                                        \"path":         path,
                                        \"line_number":  first_gr.line_number,
                                        \"layer":        "definitions",
                                        \"group_header": v:true,
                                        \}
                            
                                  let prefix     = self.CreateItem("link", ">", g:AnyJumpGetColor('group_text'), opts)
                                  let group_name = self.CreateItem("link", path, g:AnyJumpGetColor('group_name'), opts)
                                  let line       = [ prefix, group_name ]
                            
                                  call self.AddLine(line)
                            
                                  for gr in render_map[path]
                                    let items = self.GrepResultToGroupedItems(gr, idx, "definitions")
                                    call self.AddLine(items)
                            
                                    let idx += 1
                                  endfor
                            
                                  if path_idx != len(keys(render_map)) - 1
                                     call self.AddLine([ self.CreateItem("text", "", "Comment") ])
                                  endif
                            
                                  let path_idx += 1
                                endfor
                            
                                call self.AddLine([ self.CreateItem("text", "", "Comment") ])
                              else
                                if len(collection)
                                  for gr in collection
                                    let items = self.GrepResultToItems(gr, idx, "definitions")
                                    call self.AddLine(items)
                            
                                    let idx += 1
                                  endfor
                                else
                                  call self.AddLine([ self.CreateItem("text", "No definitions results", g:AnyJumpGetColor('plain_text')) ])
                                endif
                            
                                call self.AddLine([ self.CreateItem("text", "", "Comment") ])
                              endif
                            
                              if hidden_count > 0
                                call self.AddLine([
                                      \self.CreateItem("more_button", '[ + ' . hidden_count . ' more ]', g:AnyJumpGetColor('more_button')),
                                      \self.CreateItem("more_button", '— [a] load more results [A] load all', g:AnyJumpGetColor('more_explain')),
                                      \])
                                call self.AddLine([ self.CreateItem("text", "", "Comment") ])
                              endif
                            
                              if self.usages_opened && len(self.usages_grep_results) > 0
                                call self.RenderUiUsagesList(self.usages_grep_results, self.len() + 1)
                              endif
                            
                              call self.HelpSection()
                            endfu
                            
    1              0.000001 fu! s:InternalBuffer.HelpSection() abort
                              if g:any_jump_show_help_section
                                call self.AddLine([ self.CreateItem("help_link", "> Help", g:AnyJumpGetColor('heading_text')) ])
                            
                                let color = g:AnyJumpGetColor('help')
                            
                                call self.AddLine([ self.CreateItem("help_text", "", color) ])
                                call self.AddLine([ self.CreateItem("help_text", "[o] open               [t] open in tab        [s] open in split   [v] open in vsplit", color) ])
                                call self.AddLine([ self.CreateItem("help_text", "[p/tab] preview file   [b] scroll to first result", color) ])
                                call self.AddLine([ self.CreateItem("help_text", "[a] load more results  [A] load all results", color) ])
                                call self.AddLine([ self.CreateItem("help_text", "[r] show references    [T] group by file", color) ])
                                call self.AddLine([ self.CreateItem("help_text", "[L] toggle search                             [esc/q] exit", color) ])
                                call self.AddLine([ self.CreateItem("help_text", "    results ui style", color) ])
                              endif
                            endfu
                            
    1              0.000001 fu! s:InternalBuffer.RemoveGarbagedLines() dict abort
                              " remove marked for garbage collection lines
                              let new_items = []
                            
                              for line in self.items
                                if has_key(line[0], 'gc') == v:false || line[0].gc == v:false
                                  call add(new_items, line)
                                endif
                              endfor
                            
                              let self.items = new_items
                            endfu
                            
                            
                            " Public api
    1              0.000001 fu! internal_buffer#GetClass() abort
                              return s:InternalBuffer
                            endfu

SCRIPT  /Users/kaizhi/.local/share/nvim/lazy/any-jump.vim/autoload/search.vim
Sourced 1 time
Total time:   0.000838
 Self time:   0.000822

count  total (s)   self (s)
                            " Search methods
                            
    1              0.000002 let s:regexp_keyword_word = 'KEYWORD'
    1              0.000001 let s:engines             = ['rg', 'ag']
                            
    1              0.000001 let s:rg_base_cmd = "rg -n --auto-hybrid-regex --json"
    1              0.000001 let s:ag_base_cmd = "ag --nogroup --noheading"
                            
    1              0.000006 let s:rg_filetype_convertion_map = {
                                  \"python":     "py",
                                  \"javascript": "js",
                                  \"typescript": "ts",
                                  \"commonlisp": "lisp",
                                  \"scss":       "css",
                                  \}
                            
    1              0.000004 let s:ag_filetype_convertion_map = {
                                  \"javascript": "js",
                                  \"typescript": "ts",
                                  \"commonlisp": "lisp",
                                  \"scss":       "css",
                                  \}
                            
    1              0.000014 let s:non_standard_ft_extensions_map = {
                                  \"coffeescript":  [ '\.cjs\$', '\.coffee\$', 'Cakefile', '\._coffee\$', '\.coffeekup$', '\.ck\$' ],
                                  \"coq":           [ '\.v\$' ],
                                  \"scad":          [ '\.scad\$' ],
                                  \"protobuf":      [ '\.proto\$' ],
                                  \"scss":          [ '\.scss\$' ],
                                  \"systemverilog": [ '\.sv\$', '\.svh\$' ],
                                  \"racket":        [ '\.rkt\$' ],
                                  \"scheme":        [ '\.scm\$', '\.ss\$', '\.sld\$' ],
                                  \"faust":         [ '\.dsp\$', '\.lib\$' ],
                                  \"pascal":        [ '\.pas\$', '\.dpr\$', '\.int\$', '\.dfm\$'  ],
                                  \"shell":         [ '\.sh\$', '\.bash\$', '\.csh\$', '\.ksh\$', '\.tcsh\$' ],
                                  \"haskell":       [ '\.hs\$', '\.lhs\$' ],
                                  \"dart":          [ '\.dart\$' ],
                                  \"zig":           [ '\.zig\$' ],
                                  \}
                            
    1              0.000029 let s:filetypes_comments_map = {
                                  \"cpp":           ["//"],
                                  \"elisp":         [";"],
                                  \"commonlisp":    [";"],
                                  \"javascript":    ["//"],
                                  \"typescript":    ["//"],
                                  \"dart":          ["//"],
                                  \"haskell":       ["--"],
                                  \"lua":           ["--"],
                                  \"rust":          ["//"],
                                  \"julia":         ["#"] ,
                                  \"objc":          ["//"],
                                  \"csharp":        ["//"],
                                  \"java":          ["//"],
                                  \"clojure":       [";"] ,
                                  \"coffeescript":  ["#"] ,
                                  \"faust":         ["//"],
                                  \"fortran":       ["!"] ,
                                  \"go":            ["//"],
                                  \"perl":          ["#"] ,
                                  \"php":           ["//", "#"],
                                  \"python":        ["#"] ,
                                  \"matlab":        ["%"] ,
                                  \"r":             ["#"] ,
                                  \"racket":        [";"] ,
                                  \"ruby":          ["#"] ,
                                  \"crystal":       ["#"] ,
                                  \"nim":           ["#"] ,
                                  \"nix":           ["#"] ,
                                  \"scala":         ["//"],
                                  \"scheme":        [";"] ,
                                  \"shell":         ["#"] ,
                                  \"swift":         ["//"],
                                  \"elixir":        ["#"] ,
                                  \"erlang":        ["%"] ,
                                  \"tex":           ["%"] ,
                                  \"systemverilog": ["//"],
                                  \"vhdl":          ["--"],
                                  \"scss":          ["//"],
                                  \"pascal":        ["//"],
                                  \"protobuf":      ["//"],
                                  \"zig":           ["//"],
                                  \}
                            
                            " Compiled expressions to avoid recompilation
    1              0.000002 let s:non_standard_ft_extensions_map_compiled = {}
    1              0.000001 let s:filetypes_comments_map_compiled         = {}
                            
                            " Do compilation
   15              0.000011 for lang in keys(s:non_standard_ft_extensions_map)
   14              0.000017   let rules  = s:non_standard_ft_extensions_map[lang]
   14   0.000112   0.000096   let regexp = map(rules, { _, pattern -> '(' . pattern . ')' })
   14              0.000021   let regexp = join(regexp, '|')
   14              0.000017   let regexp = "\"(" . regexp . ")\""
                            
   14              0.000024   let s:non_standard_ft_extensions_map_compiled[lang] = regexp
   15              0.000005 endfor
                            
   42              0.000022 for lang in keys(s:filetypes_comments_map)
   41              0.000039   let rules = s:filetypes_comments_map[lang]
   41              0.000078   let compiled_rules = map(copy(rules), "'^\s*' . v:val")
   41              0.000057   let s:filetypes_comments_map_compiled[lang] = compiled_rules
   42              0.000011 endfor
                            
                            " End of compilation
                            
    1              0.000001 fu! s:GetRgFiletype(lang) abort
                              if has_key(s:rg_filetype_convertion_map, a:lang)
                                return s:rg_filetype_convertion_map[a:lang]
                              else
                                return a:lang
                              endif
                            endfu
                            
    1              0.000001 fu! s:GetAgFiletype(lang) abort
                              if has_key(s:ag_filetype_convertion_map, a:lang)
                                return s:ag_filetype_convertion_map[a:lang]
                              else
                                return a:lang
                              endif
                            endfu
                            
    1              0.000002 fu! search#GetSearchEngineFileTypeSpecifier(engine, language) abort
                              let cmd = 0
                            
                              if has_key(s:non_standard_ft_extensions_map_compiled, a:language)
                                if a:engine == 'rg'
                                  let file_lists_cmd = 'rg --files | rg ' . s:non_standard_ft_extensions_map_compiled[a:language]
                                  let files = split(system(file_lists_cmd), "\n")
                                  let cmd   = join(map(files, {_,fname -> ('-f ' . fname)}), ' ')
                                elseif a:engine == 'ag'
                                  let cmd = '-G ' . s:non_standard_ft_extensions_map_compiled[a:language]
                                endif
                              else
                                if a:engine == 'rg'
                                  let cmd = '-t ' . s:GetRgFiletype(a:language)
                                elseif a:engine == 'ag'
                                  let cmd = '--' . s:GetAgFiletype(a:language)
                                endif
                              endif
                            
                              return cmd
                            endfu
                            
    1              0.000001 fu! s:GetRgIgnoreSpecifier() abort
                              let result = ''
                            
                              if g:any_jump_disable_vcs_ignore
                                let result .= " --no-ignore-vcs"
                              endif
                            
                              for glob in g:any_jump_ignored_files
                                let result = result . ' -g !' . string(glob)
                              endfor
                            
                              return result
                            endfu
                            
    1              0.000001 fu! s:GetAgIgnoreSpecifier() abort
                              let result = ''
                            
                              if g:any_jump_disable_vcs_ignore
                                let result .= " --skip-vcs-ignores"
                              endif
                            
                              for glob in g:any_jump_ignored_files
                                let result = result . ' --ignore ' . string(glob)
                              endfor
                            
                              return result
                            endfu
                            
    1              0.000001 fu! search#GetCurrentSearchEngine() abort
                              let search_engine = g:any_jump_search_prefered_engine
                              let engine_ok     = executable(search_engine)
                            
                              if !engine_ok
                                let search_engine = search_engine == 'rg' ? 'ag' : 'rg'
                              endif
                            
                              return search_engine
                            endfu
                            
    1              0.000001 fu! search#SearchUsages(internal_buffer) abort
                              let search_engine = search#GetCurrentSearchEngine()
                            
                              if search_engine == 'rg'
                                let grep_results = s:RunRgUsagesSearch(a:internal_buffer.language, a:internal_buffer.keyword)
                              elseif search_engine == 'ag'
                                let grep_results = s:RunAgUsagesSearch(a:internal_buffer.language, a:internal_buffer.keyword)
                              end
                            
                              return grep_results
                            endfu
                            
    1              0.000001 fu! search#SearchDefinitions(lang, keyword) abort
                              let patterns      = []
                              let lang          = lang_map#find_definitions(a:lang)
                              let search_engine = search#GetCurrentSearchEngine()
                            
                              " if lang regexp doesn't support prefered search engine
                              if index(lang[0].supports, search_engine) == -1
                                " try to change selected engine
                                let search_engine = (search_engine == 'rg' ? 'ag' : 'rg')
                            
                                " end error of changed engine not installed
                                if !executable(search_engine)
                                  echoe "please install " . search_engine . " to run " . a:lang . " any-jump.vim search"
                                endif
                            
                                return 0
                              endif
                            
                              for rule in lang
                                let regexp = substitute(rule.pcre2_regexp, s:regexp_keyword_word, a:keyword, "g")
                            
                                if match(&shell, 'fish') != -1
                                  let regexp = substitute(regexp, '\$', '\\$', 'g')
                                endif
                            
                                call add(patterns, regexp)
                              endfor
                            
                              let regexp = map(patterns, { _, pattern -> '(' . pattern . ')' })
                              let regexp = join(regexp, '|')
                              let regexp = "\"(" . regexp . ")\""
                            
                              if search_engine == 'rg'
                                let grep_results = s:RunRgDefinitionSearch(a:lang, regexp)
                              elseif search_engine == 'ag'
                                let grep_results = s:RunAgDefinitionSearch(a:lang, regexp)
                              end
                            
                              return grep_results
                            endfu
                            
    1              0.000001 fu! search#RunSearchEnginesSpecs() abort
                              let errors = []
                            
                              let has_rg = executable('rg')
                              let has_ag = executable('ag')
                            
                              if !(has_rg || has_ag)
                                let error = "rg or ag executable not found"
                                echoe error
                            
                                call add(errors, error)
                              endif
                            
                              return errors
                            endfu
                            
    1              0.000001 fu! search#RunRegexpSpecs() abort
                              let errors = []
                              let passed = 0
                              let failed = 0
                            
                              for lang in keys(lang_map#definitions())
                                let lang_passed = 0
                                let lang_failed = 0
                            
                                for entry in lang_map#definitions()[lang]
                                  let re = entry.pcre2_regexp
                                  let keyword = 'test'
                            
                                  if len(re) > 0
                                    let test_re = substitute(re, 'KEYWORD', keyword, 'g')
                                    let invalid_exist_statues = {"spec_success": [1,2], "spec_failed": [0,2]}
                                    let spec_types = keys(invalid_exist_statues)
                            
                                    for spec_type in spec_types
                                      for spec_string in entry[spec_type]
                                        for engine in s:engines
                                          if index(entry.supports, engine) == -1
                                            continue
                                          endif
                            
                                          let cmd = 0
                                          let ft_args = search#GetSearchEngineFileTypeSpecifier(engine, lang)
                            
                                          if engine == 'rg'
                                            let rg_ft = s:GetRgFiletype(lang)
                                            let cmd   = "echo \"" . spec_string . "\" | "
                                                  \ . s:rg_base_cmd .  " --no-filename  "
                                                  \ . ft_args . " \"" . test_re . "\""
                                          end
                            
                                          if engine == 'ag'
                                            let ag_ft = s:GetAgFiletype(lang)
                                            let cmd   = "echo \"" . spec_string . "\" | "
                                                  \ . s:ag_base_cmd . " " . ft_args . " \""
                                                  \ . test_re . "\""
                                          endif
                            
                                          let raw_results = system(shellescape(cmd))
                            
                                          if index(invalid_exist_statues[spec_type], v:shell_error) != -1
                                            call add(errors, 'FAILED ' . engine . ' ' . lang . ' ' . spec_type . ' -- result: ' . string(raw_results) . "; spec: " . string(spec_string)  . '; re: ' . string(test_re))
                                            let lang_failed += 1
                                          else
                                            let lang_passed += 1
                                          endif
                            
                                        endfor
                                      endfor
                                    endfor
                                  endif
                            
                                endfor
                            
                                echo "lang " . lang . ' finished  success:' . lang_passed . ' failed: ' . lang_failed
                              endfor
                            
                              return errors
                            endfu
                            
                            "
                            " --- Private api ---
                            "
                            
    1              0.000001 fu! s:NewGrepResult() abort
                              return { "line_number": 0, "path": 0, "text": 0 }
                            endfu
                            
    1              0.000001 fu! s:RunRgDefinitionSearch(language, patterns) abort
                              let rg_ft = s:GetRgFiletype(a:language)
                            
                              let cmd = s:rg_base_cmd . ' -t ' . rg_ft
                              let cmd = cmd . s:GetRgIgnoreSpecifier()
                              let cmd = cmd . ' ' . a:patterns
                            
                              let raw_results  = system(cmd)
                              let grep_results = s:ParseRgResults(raw_results)
                              let grep_results = s:FilterGrepResults(a:language, grep_results)
                            
                              return grep_results
                            endfu
                            
    1              0.000001 fu! s:RunAgDefinitionSearch(language, patterns) abort
                              let ag_ft = s:GetAgFiletype(a:language)
                            
                              let cmd = s:ag_base_cmd . ' --' . ag_ft
                              let cmd = cmd . s:GetAgIgnoreSpecifier()
                              let cmd = cmd . ' ' . a:patterns
                            
                              let raw_results  = system(cmd)
                              let grep_results = s:ParseAgResults(raw_results)
                              let grep_results = s:FilterGrepResults(a:language, grep_results)
                            
                              return grep_results
                            endfu
                            
    1              0.000001 fu! s:RunRgUsagesSearch(language, keyword) abort
                              let kw = a:keyword
                              let kw = substitute(kw, "\-", "\\\\-", "g") " shell escape
                            
                              let cmd = s:rg_base_cmd . ' -w ' . string(kw)
                              let cmd = cmd . s:GetRgIgnoreSpecifier()
                            
                              if g:any_jump_references_only_for_current_filetype
                                    \ && type(a:language) == v:t_string
                            
                                let rg_ft = s:GetRgFiletype(a:language)
                                let cmd   = cmd . ' -t ' . rg_ft
                              endif
                            
                              let raw_results  = system(cmd)
                              let grep_results = s:ParseRgResults(raw_results)
                              let grep_results = s:FilterGrepResults(a:language, grep_results)
                            
                              return grep_results
                            endfu
                            
    1              0.000001 fu! s:RunAgUsagesSearch(language, keyword) abort
                              let cmd = s:ag_base_cmd . ' -w ' . string(a:keyword)
                              let cmd = cmd . s:GetAgIgnoreSpecifier()
                            
                              if g:any_jump_references_only_for_current_filetype
                                    \ && type(a:language) == v:t_string
                            
                                let ag_ft = s:GetAgFiletype(a:language)
                                let cmd   = cmd . ' --' . ag_ft
                              endif
                            
                              let raw_results  = system(cmd)
                            
                              let grep_results = s:ParseAgResults(raw_results)
                              let grep_results = s:FilterGrepResults(a:language, grep_results)
                            
                              return grep_results
                            endfu
                            
    1              0.000001 fu! s:FilterGrepResults(language, grep_results) abort
                              if type(a:language) != v:t_string
                                return a:grep_results
                              endif
                            
                              if g:any_jump_remove_comments_from_results
                                    \ && has_key(s:filetypes_comments_map_compiled, a:language)
                            
                                let filtered = copy(a:grep_results)
                            
                                for comment_pattern in s:filetypes_comments_map_compiled[a:language]
                                  call filter(filtered, 'v:val.text !~# comment_pattern')
                                endfor
                            
                                return filtered
                              else
                                return a:grep_results
                              endif
                            endfu
                            
    1              0.000001 fu! s:ParseRgResults(raw_results) abort
                              let grep_results = []
                            
                              if len(a:raw_results) > 0
                                let matches = []
                            
                                for res in split(a:raw_results, "\n")
                                  let match = json_decode(res)
                                  call add(matches, match)
                                endfor
                            
                                for match in matches
                                  if get(match, 'type') == 'match'
                                    let data = get(match, 'data')
                            
                                    if type(data) == v:t_dict
                                      let text = data.lines.text
                                      let text = substitute(text, '^\s*', '', 'g')
                                      let text = substitute(text, '\n', '', 'g')
                            
                                      let grep_result             = s:NewGrepResult()
                                      let grep_result.line_number = data.line_number
                                      let grep_result.path        = data.path.text
                                      let grep_result.text        = text
                            
                                      call add(grep_results, grep_result)
                                    endif
                                  endif
                                endfor
                              endif
                            
                              return grep_results
                            endfu
                            
    1              0.000001 fu! s:ParseAgResults(raw_results) abort
                              let grep_results = []
                            
                              if len(a:raw_results) > 0
                                let matches = []
                            
                                for line in split(a:raw_results, "\n")
                                  if len(line) == 0
                                    continue
                                  endif
                            
                                  let max_splits = 3
                                  let head = 0
                                  let tail = line
                                  let res  = []
                            
                                  while len(tail) != 0
                                    let midx = match(tail, ':')
                            
                                    if midx >= 0 && len(res) != (max_splits - 1)
                                      let head = tail[0 : midx - 1]
                                      let tail = tail[midx + 1 : -1]
                            
                                      call add(res, head)
                                    else
                                      call add(res, tail)
                                      let tail = ''
                                    endif
                                  endwhile
                            
                                  let grep_result = s:NewGrepResult()
                            
                                  if len(res) != 3
                                    continue
                                  endif
                            
                                  let grep_result.line_number = res[1]
                                  let grep_result.path        = res[0]
                                  let grep_result.text        = substitute(res[2], '^\s*', '', '')
                            
                                  call add(grep_results, grep_result)
                                endfor
                              endif
                            
                              return grep_results
                            endfu

FUNCTION  <SNR>109_start()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/main.vim:94
Called 13 times
Total time:   0.006765
 Self time:   0.000397

count  total (s)   self (s)
   13   0.000181   0.000100   if !wilder#main#in_mode() || !s:enabled
   11   0.000091   0.000044     call wilder#main#stop()
   11              0.000003     return
    2              0.000002   endif
                            
    2   0.000022   0.000006   if !s:init && wilder#options#get('use_python_remote_plugin')
    1              0.000002     let s:init = 1
                            
    1              0.000001     try
    1              0.000002       if !has('nvim')
                                    " set up yarp
                                    call wilder#yarp#init()
    1              0.000000       endif
                            
    1              0.000016       call _wilder_init({'num_workers': s:opts.num_workers})
    1              0.000010     catch
    1              0.000002       echohl ErrorMsg
    1              0.000012       echomsg 'wilder: Python initialization failed'
    1              0.000005       echomsg v:exception
    1              0.000001       echohl Normal
    1              0.000001     endtry
    2              0.000001   endif
                            
    2              0.000002   if s:opts.use_cmdlinechanged
    2              0.000006     if !exists('#WilderCmdlineChanged')
    2              0.000004       augroup WilderCmdlineChanged
    2              0.000023         autocmd!
                                    " call from a timer so statusline does not change during mappings
    2              0.000009         autocmd CmdlineChanged * call timer_start(0, {_ -> s:do(1)})
    2              0.000001       augroup END
    2              0.000001     endif
                              elseif s:timer is v:null
                                  let s:timer = timer_start(s:opts.interval, {_ -> s:do(1)}, {'repeat': -1})
    2              0.000001   endif
                            
    2              0.000003   if !exists('#WilderCmdlineLeave')
    2              0.000002     augroup WilderCmdlineLeave
    2              0.000006       autocmd!
    2              0.000004       autocmd CmdlineLeave * call wilder#main#stop()
    2              0.000003       autocmd CmdwinEnter * call wilder#main#stop()
    2              0.000001     augroup END
    2              0.000001   endif
                            
    2              0.000003   if !exists('#WilderVimResized')
    2              0.000001     augroup WilderVimResized
    2              0.000005       autocmd!
    2              0.000005         autocmd VimResized * call timer_start(0, {_ -> s:draw_resized()})
    2              0.000001     augroup END
    2              0.000000   endif
                            
    2              0.000003   let s:active = 1
    2              0.000001   let s:hidden = 0
                            
    2              0.000003   if !has_key(s:opts, 'renderer')
                                let s:opts.renderer = wilder#wildmenu_renderer()
    2              0.000001   endif
                            
    2              0.000002   if !has_key(s:opts, 'pipeline')
                                let s:opts.pipeline = [ wilder#branch(   wilder#cmdline_pipeline(),   has('nvim') && has('python3')     ? wilder#python_search_pipeline()     : wilder#vim_search_pipeline(), ), ]
    2              0.000001   endif
                            
    2              0.000003   let s:session_id += 1
                            
    2   0.005137   0.000009   call s:pre_hook()
                            
    2   0.001104   0.000008   call s:do(0)

FUNCTION  <lambda>80()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer/popupmenu.vim:113
Called 8 times
Total time:   0.002378
 Self time:   0.000034

count  total (s)   self (s)
                            return s:render(l:state, ctx, result)

FUNCTION  <lambda>81()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer/popupmenu.vim:113
Called 2 times
Total time:   0.002326
 Self time:   0.000010

count  total (s)   self (s)
                            return s:pre_hook(l:state, ctx)

FUNCTION  <SNR>66_result()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/pipe/result.vim:23
Called 12 times
Total time:   0.000891
 Self time:   0.000681

count  total (s)   self (s)
   12              0.000010   if empty(a:kvs)
                                return a:result
   12              0.000003   endif
                            
   12              0.000009   let l:kvs = a:kvs
                            
   28              0.000024   while !empty(l:kvs)
   16              0.000014     let l:kv = l:kvs[0]
   16              0.000015     let l:kvs = l:kvs[1:]
   16              0.000013     let l:key = l:kv.key
   16              0.000018     let l:Value = l:kv.value
                            
   16              0.000016     if type(l:Value) is v:t_func
   12   0.000288   0.000078       let l:R = l:Value(a:ctx, get(a:result, l:key, v:null), get(a:result, 'data', {}))
                            
   12              0.000012       if type(l:R) is v:t_func
                                    return wilder#wait(l:R, {ctx, value -> wilder#resolve(ctx, s:result(l:kvs, ctx, s:add_key(a:result, l:key, value)))})
   12              0.000004       endif
                            
   12              0.000015       let a:result[l:key] = l:R
    4              0.000005     elseif type(l:Value) is v:t_list
    4              0.000010       let a:result[l:key] = get(a:result, l:key, []) + l:Value
                                elseif type(l:Value) is v:t_dict
                                  let a:result[l:key] = extend(get(a:result, l:key, {}), l:Value)
                                else
                                  let a:result[l:key] = l:Value
   16              0.000017     endif
   28              0.000030   endwhile
                            
   12              0.000007   return a:result

FUNCTION  <SNR>103_RunDeferred()
    Defined: ~/.local/share/nvim/lazy/copilot.vim/autoload/copilot/util.vim:12
Called 24 times
Total time:   0.024865
 Self time:   0.000319

count  total (s)   self (s)
   24              0.000079   if empty(s:deferred)
   12              0.000009     return
   12              0.000007   endif
   12              0.000037   let Fn = remove(s:deferred, 0)
   12              0.000057   call timer_start(0, function('s:RunDeferred'))
   12   0.024647   0.000101   call call(Fn, [])

FUNCTION  search#SearchUsages()
    Defined: ~/.local/share/nvim/lazy/any-jump.vim/autoload/search.vim:184
Called 3 times
Total time:   0.043791
 Self time:   0.000081

count  total (s)   self (s)
    3   0.000359   0.000016   let search_engine = search#GetCurrentSearchEngine()
                            
    3              0.000003   if search_engine == 'rg'
    3   0.043413   0.000046     let grep_results = s:RunRgUsagesSearch(a:internal_buffer.language, a:internal_buffer.keyword)
                              elseif search_engine == 'ag'
                                let grep_results = s:RunAgUsagesSearch(a:internal_buffer.language, a:internal_buffer.keyword)
    3              0.000001   end
                            
    3              0.000002   return grep_results

FUNCTION  <SNR>58_draw_top_or_bottom_line()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer/popupmenu.vim:795
Called 24 times
Total time:   0.008551
 Self time:   0.003207

count  total (s)   self (s)
   24              0.000020   let l:width = a:ctx.width
                            
   24              0.000024   let l:Line = a:line
   24              0.000025   if type(l:Line) is v:t_dict
    6              0.000006     let l:Line = l:Line.value
   24              0.000007   endif
                            
   24              0.000023   if type(l:Line) is v:t_func
   24   0.008260   0.002917     let l:Line = l:Line(a:ctx, a:result)
   24              0.000008   endif
                            
   24              0.000024   if type(l:Line) is v:t_string
                                if empty(l:Line)
                                  return l:Line
                                endif
                            
                                let l:Line = [[wilder#render#truncate_and_pad(a:ctx.width, l:Line)]]
   24              0.000006   endif
                            
   24              0.000013   return l:Line

FUNCTION  <lambda>91()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/cmdline.vim:1325
Called 4 times
Total time:   0.000003
 Self time:   0.000003

count  total (s)   self (s)
                            return res[0] ? res : v:false

FUNCTION  <lambda>94()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/cmdline.vim:1344
Called 4 times
Total time:   0.000001
 Self time:   0.000001

count  total (s)   self (s)
                            return res[2]

FUNCTION  <lambda>95()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/transform.vim:95
Called 4 times
Total time:   0.000088
 Self time:   0.000020

count  total (s)   self (s)
                            return wilder#vim_fuzzy_filt(ctx, {}, xs, q)

FUNCTION  <lambda>96()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/cmdline.vim:1127
Called 4 times
Total time:   0.000034
 Self time:   0.000020

count  total (s)   self (s)
                            return wilder#cmdline#is_file_expansion(res.expand)

FUNCTION  <SNR>58_draw_columns()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer/popupmenu.vim:543
Called 12 times
Total time:   0.015297
 Self time:   0.002330

count  total (s)   self (s)
   12              0.000012   let l:height = a:ctx.height
                            
   48              0.000033   for l:Column in a:columns
   36   0.013232   0.000265     let l:column = wilder#renderer#popupmenu#draw_column(a:ctx, a:result, l:Column)
                            
   36              0.000028     if empty(l:column)
    8              0.000004       continue
   28              0.000008     endif
                            
   28              0.000018     let l:i = 0
  572              0.000427     while l:i < len(l:column)
  544              0.000590       let a:column_chunks[l:i] += l:column[l:i]
                            
  544              0.000278       let l:i += 1
  572              0.000174     endwhile
                            
   28              0.000019     if l:i < l:height
                                  let l:width = wilder#render#chunks_displaywidth(l:column[0])
                            
                                  while l:i < l:height
                                    let a:column_chunks[l:i] += [[repeat(' ', l:width)]]
                            
                                    let l:i += 1
                                  endwhile
   28              0.000007     endif
   40              0.000020   endfor

FUNCTION  <SNR>10_has()
    Defined: ~/.local/share/nvim/lazy/vim-rooter/plugin/rooter.vim:203
Called 42 times
Total time:   0.000278
 Self time:   0.000278

count  total (s)   self (s)
                              " We do not want a:dir to be treated as a glob so escape any wildcards.
                              " If this approach is problematic (e.g. on Windows), an alternative
                              " might be to change directory to a:dir, call globpath() with just
                              " a:identifier, then restore the working directory.
   42              0.000237   return !empty(globpath(escape(a:dir, '?*[]'), a:identifier, 1))

FUNCTION  <SNR>56_wrap_string_or_func_with_border()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer/popupmenu_border_theme.vim:121
Called 6 times
Total time:   0.001271
 Self time:   0.000188

count  total (s)   self (s)
    6              0.000006   let l:width = a:ctx.width
    6              0.000009   let l:width -= strdisplaywidth(a:left)
    6              0.000008   let l:width -= strdisplaywidth(a:right)
    6              0.000004   if l:width < 0
                                let l:width = 0
    6              0.000002   endif
                            
    6              0.000006   if type(a:line) is v:t_func
    6              0.000013     let l:ctx = copy(a:ctx)
    6              0.000005     let l:ctx.width = l:width
    6   0.001117   0.000034     let l:result = a:line(l:ctx, a:result)
                            
    6              0.000005     if empty(l:result)
                                  return l:result
    6              0.000002     endif
                            
    6              0.000006     if type(l:result) is v:t_string
                                  let l:chunks = [[wilder#render#truncate_and_pad(l:width, l:result)]]
    6              0.000002     else
    6              0.000005       let l:chunks = l:result
    6              0.000002     endif
                              else
                                if empty(a:line)
                                  return a:line
                                endif
                            
                                let l:chunks = [[wilder#render#truncate_and_pad(l:width, a:line)]]
    6              0.000002   endif
                            
    6              0.000007   let l:border_hl = a:ctx.highlights.border
    6              0.000020   return [[a:left, l:border_hl]] + l:chunks + [[a:right, l:border_hl]]

FUNCTION  wilder#transform#uniq_filt()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/transform.vim:57
Called 2 times
Total time:   0.000043
 Self time:   0.000043

count  total (s)   self (s)
    2              0.000002   let l:seen = {}
    2              0.000001   let l:res = []
                            
    8              0.000005   for l:x in a:xs
    6              0.000007     if !has_key(l:seen, l:x)
    6              0.000006       let l:seen[l:x] = 1
    6              0.000007       call add(l:res, l:x)
    6              0.000002     endif
    8              0.000003   endfor
                            
    2              0.000001   return l:res

FUNCTION  copilot#OnFileType()
    Defined: ~/.local/share/nvim/lazy/copilot.vim/autoload/copilot.vim:446
Called 7 times
Total time:   0.000361
 Self time:   0.000080

count  total (s)   self (s)
    7   0.000303   0.000044   if empty(s:BufferDisabled()) && &l:modifiable && &l:buflisted
    3   0.000043   0.000021     call copilot#util#Defer(function('s:Attach'), bufnr(''))
    7              0.000002   endif

FUNCTION  <SNR>110_pre_draw()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer.vim:62
Called 60 times
Total time:   0.001007
 Self time:   0.000885

count  total (s)   self (s)
   60              0.000065   if type(a:component) isnot v:t_dict
   54              0.000030     return a:ctx.done
    6              0.000002   endif
                            
    6              0.000007   if has_key(a:component, 'pre_draw')
    6   0.000872   0.000750     return a:component.pre_draw(a:ctx, a:result)
                              endif
                            
                              return a:ctx.done || get(a:component, 'dynamic', 0)

FUNCTION  <lambda>942()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/pipeline.vim:171
Called 1 time
Total time:   0.000060
 Self time:   0.000003

count  total (s)   self (s)
                            return s:wait_start(l:state, ctx)

FUNCTION  wilder#cmdline#parse()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/cmdline.vim:3
Called 4 times
Total time:   0.002981
 Self time:   0.000228

count  total (s)   self (s)
    4   0.000027   0.000017   if !s:cmdline_cache.has_key(a:cmdline)
    2              0.000021     let l:ctx = {'cmdline': a:cmdline, 'pos': 0, 'cmd': '', 'expand': ''}
    2   0.002812   0.000137     call wilder#cmdline#main#do(l:ctx)
                            
    2              0.000004     let l:ctx['arg'] = l:ctx['cmdline'][l:ctx.pos :]
    2              0.000002     let l:ctx['pos'] = l:ctx.pos
    2   0.000070   0.000009     call s:cmdline_cache.set(a:cmdline, l:ctx)
    4              0.000001   endif
                            
    4   0.000026   0.000019   return copy(s:cmdline_cache.get(a:cmdline))

FUNCTION  <SNR>61_show()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer/nvim_api.vim:67
Called 6 times
Total time:   0.000775
 Self time:   0.000035

count  total (s)   self (s)
    6              0.000010   if self.state.win != -1 || self.state.window_state !=# 'hidden'
    4              0.000002     return
    2              0.000000   endif
                            
    2              0.000002   let self.state.window_state = 'pending'
                            
    2              0.000001   try
    2   0.000749   0.000008     call self._open_win()
                              catch
                                call timer_start(0, {-> self._open_win()})
    2              0.000001   endtry

FUNCTION  wilder#highlight#init_hl()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/highlight.vim:16
Called 2 times
Total time:   0.002727
 Self time:   0.000041

count  total (s)   self (s)
    6              0.000011   for [l:name, l:x, l:xs] in s:hl_list
    4   0.002710   0.000024     call s:make_hl(l:name, l:x, l:xs)
    6              0.000002   endfor

FUNCTION  <SNR>104_NvimNotify()
    Defined: ~/.local/share/nvim/lazy/copilot.vim/autoload/copilot/client.vim:482
Called 3 times
Total time:   0.000049
 Self time:   0.000028

count  total (s)   self (s)
    3   0.000048   0.000027   call self.AfterInitialized(function('s:NvimDoNotify', [self.client_id, a:method, a:params]))

FUNCTION  <lambda>117()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder.vim:198
Called 4 times
Total time:   0.000001
 Self time:   0.000001

count  total (s)   self (s)
                            return x

FUNCTION  <SNR>65_check()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/pipe/check.vim:5
Called 12 times
Total time:   0.000152
 Self time:   0.000111

count  total (s)   self (s)
   12              0.000008   let l:i = 0
                            
   16              0.000019   for l:Check in a:checks
   12   0.000077   0.000035     if !l:Check(a:ctx, a:x)
    8              0.000005       return v:false
    4              0.000001     endif
    8              0.000018   endfor
                            
    4              0.000003   return a:x

FUNCTION  <SNR>10_rooter()
    Defined: ~/.local/share/nvim/lazy/vim-rooter/plugin/rooter.vim:76
Called 6 times
Total time:   0.002039
 Self time:   0.000135

count  total (s)   self (s)
    6   0.000413   0.000028   if !s:activate() | return | endif
                            
    3              0.000004   let bufnr = a:0 ? a:1 : '%'
                            
    3              0.000007   let root = getbufvar(bufnr, 'rootDir')
    3              0.000002   if empty(root)
    3   0.001542   0.000049     let root = s:root()
    3              0.000008     call setbufvar(bufnr, 'rootDir', root)
    3              0.000001   endif
                            
    3              0.000002   if empty(root)
    3   0.000049   0.000024     call s:rootless()
    3              0.000001     return
                              endif
                            
                              call s:cd(root)

FUNCTION  wilder#resolve()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder.vim:37
Called 20 times
Total time:   0.000061
 Self time:   0.000061

count  total (s)   self (s)
   20              0.000056   call timer_start(0, {-> wilder#pipeline#resolve(a:ctx, a:x)})

FUNCTION  <SNR>16_CreateUi()
    Defined: ~/.local/share/nvim/lazy/any-jump.vim/plugin/any-jump.vim:187
Called 3 times
Total time:   0.040744
 Self time:   0.000044

count  total (s)   self (s)
    3              0.000002   if s:nvim
    3   0.040733   0.000033     call s:CreateNvimUi(a:internal_buffer)
                              else
                                call s:CreateVimUi(a:internal_buffer)
    3              0.000001   endif

FUNCTION  <SNR>61__open_win()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer/nvim_api.vim:82
Called 2 times
Total time:   0.000740
 Self time:   0.000220

count  total (s)   self (s)
                              " window might have been open or closed already.
    2              0.000002   if self.state.window_state !=# 'pending'
                                return
    2              0.000001   endif
                            
                              " Fix E5555 when re-showing wilder when inccommand is cancelled.
    2              0.000007   let l:buf = has('nvim-0.6') && !has('nvim-0.7') ? 0 : self.state.buf
                            
    2              0.000007   let l:win_opts = { 'relative': 'editor', 'height': 1, 'width': 1, 'row': &lines - 1, 'col': 0, 'focusable': 0, }
                            
    2              0.000003   if has('nvim-0.5.1')
    2              0.000002     let l:win_opts.zindex = self.state.zindex
    2              0.000001   endif
                            
    2   0.000519   0.000088   let self.state.win = nvim_open_win(l:buf, 0, l:win_opts)
                            
    2              0.000003   let self.state.window_state = 'showing'
                            
    2              0.000006   if has('nvim-0.6') && !has('nvim-0.7')
                                try
                                  call self._set_buf()
                                catch
                                  call timer_start(0, {-> self._set_buf()})
                                endtry
    2              0.000001   else
    2              0.000020     call nvim_win_set_config(self.state.win, { 'style': 'minimal', })
    2              0.000001   endif
                            
    2   0.000055   0.000011   call self.set_option('winhighlight', 'Search:None,IncSearch:None,Normal:' . self.state.normal_highlight)
    2              0.000002   if self.state.pumblend != -1
                                call self.set_option('winblend', self.state.pumblend)
    2              0.000001   else
    2   0.000054   0.000008     call self.set_option('winblend', &pumblend)
    2              0.000001   endif
                            
    2              0.000002   if self.state.firstline isnot -1
                                call nvim_win_set_cursor(self.state.win, [self.state.firstline, 0])
    2              0.000000   endif
                            
    2              0.000001   if self.state.dimensions isnot -1
                                let [l:row, l:col, l:height, l:width] = self.state.dimensions
                                call nvim_win_set_config(self.state.win, { 'relative': 'editor', 'row': l:row, 'col': l:col, 'height': l:height, 'width': l:width, })
    2              0.000000   endif
                            
    2              0.000004   for l:option in keys(self.state.options)
                                let l:value = self.state.options[l:option]
                                call nvim_win_set_option(self.state.win, l:option, l:value)
    2              0.000001   endfor
                            
    2              0.000002   let self.state.firstline = -1
    2              0.000002   let self.state.dimensions = -1
    2              0.000003   let self.state.options = {}

FUNCTION  <lambda>1243()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/pipe/branch.vim:5
Called 1 time
Total time:   0.000515
 Self time:   0.000005

count  total (s)   self (s)
                            return s:branch(a:args, ctx, x)

FUNCTION  <lambda>1244()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/pipeline.vim:105
Called 1 time
Total time:   0.000099
 Self time:   0.000004

count  total (s)   self (s)
                            return s:run(a:pipeline, a:on_finish, a:on_error, ctx, x, a:i)

FUNCTION  <SNR>109_post_hook()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/main.vim:236
Called 2 times
Total time:   0.001145
 Self time:   0.000092

count  total (s)   self (s)
    2   0.000050   0.000020   call wilder#pipeline#clear_handlers()
                            
    2              0.000010   if has_key(s:opts.renderer, 'post_hook')
    2   0.001070   0.000047     call s:opts.renderer.post_hook({})
    2              0.000001   endif
                            
    2              0.000004   if has_key(s:opts, 'post_hook')
                                call s:opts.post_hook({})
    2              0.000001   endif

FUNCTION  <lambda>1267()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/pipeline.vim:171
Called 1 time
Total time:   0.000085
 Self time:   0.000003

count  total (s)   self (s)
                            return s:wait_start(l:state, ctx)

FUNCTION  internal_buffer#GetClass()
    Defined: ~/.local/share/nvim/lazy/any-jump.vim/autoload/internal_buffer.vim:688
Called 3 times
Total time:   0.000006
 Self time:   0.000006

count  total (s)   self (s)
    3              0.000005   return s:InternalBuffer

FUNCTION  <lambda>1251()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/pipe/branch.vim:38
Called 1 time
Total time:   0.000018
 Self time:   0.000003

count  total (s)   self (s)
                            return s:on_finish(a:state, ctx, x)

FUNCTION  <SNR>51_devicons()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer/component/popupmenu_devicons.vim:24
Called 6 times
Total time:   0.000050
 Self time:   0.000050

count  total (s)   self (s)
    6              0.000008   if !has_key(a:result, 'data')
                                return ''
    6              0.000002   endif
                            
    6              0.000010   let l:expand = get(a:result.data, 'cmdline.expand', '')
                            
    6              0.000016   if l:expand !=# 'file' && l:expand !=# 'file_in_path' && l:expand !=# 'dir' && l:expand !=# 'shellcmd' && l:expand !=# 'buffer'
    6              0.000003     return ''
                              endif
                            
                              let l:session_id = a:ctx.session_id
                              if a:state.session_id != l:session_id
                                call a:state.cache.clear()
                                let a:state.created_hls = {}
                                let a:state.session_id = l:session_id
                              endif
                            
                              let l:slash = !has('win32') && !has('win64') ? '/' : &shellslash ? '/' : '\'
                            
                              let [l:start, l:end] = a:ctx.page
                            
                              let l:rows = repeat([0], l:end - l:start + 1)
                            
                              if !has_key(a:state, 'get_icon')
                                let a:state.get_icon = s:get_icon_func()
                              endif
                            
                              if a:state.get_icon is v:null
                                return []
                              endif
                            
                              if !has_key(a:state, 'get_hl')
                                let a:state.get_hl = s:get_hl_func()
                              endif
                            
                              let l:i = l:start
                              while l:i <= l:end
                                let l:index = l:i - l:start
                            
                                let l:x = wilder#main#get_candidate(a:ctx, a:result, l:i)
                            
                                if a:state.cache.has_key(l:x)
                                  let l:rows[l:index] = a:state.cache.get(l:x)
                            
                                  let l:i += 1
                                  continue
                                endif
                            
                                let l:is_dir = l:x[-1:] ==# l:slash || l:x[-1:] ==# '/'
                            
                                let l:icon = a:state.get_icon(a:ctx, l:x, l:is_dir)
                                let l:icon_width = strdisplaywidth(l:icon)
                                if l:icon_width < a:state.min_width
                                  let l:icon .= repeat(' ', a:state.min_width - l:icon_width)
                                endif
                            
                                if a:state.get_hl is v:null
                                  let l:chunks = [[a:state.left_padding . l:icon . a:state.right_padding]]
                                else
                                  let l:hl = a:state.get_hl(a:ctx, l:x, l:is_dir, l:icon)
                            
                                  if !has_key(a:state.created_hls, l:hl)
                                    let l:guifg = s:get_guifg(l:hl)
                                    let l:default_hl = s:make_temp_hl(l:hl, a:ctx.highlights['default'], l:guifg)
                            
                                    if a:state.combine_selected_hl
                                      let l:selected_hl = s:make_temp_hl(l:hl . '_Selected', a:ctx.highlights['selected'], l:guifg)
                                    else
                                      let l:selected_hl = a:ctx.highlights['selected']
                                    endif
                            
                                    let a:state.created_hls[l:hl] = [l:default_hl, l:selected_hl]
                                  endif
                            
                                  let [l:default_hl, l:selected_hl] = a:state.created_hls[l:hl]
                                  let l:chunks = [[a:state.left_padding], [l:icon, l:default_hl, l:selected_hl], [a:state.right_padding]]
                                endif
                            
                                call a:state.cache.set(l:x, l:chunks)
                            
                                let l:rows[l:index] = l:chunks
                            
                                let l:i += 1
                              endwhile
                            
                              let l:height = a:ctx.height
                              let l:width = empty(l:rows) ? 0 : wilder#render#chunks_displaywidth(l:rows[0])
                              let l:empty_row = [[repeat(' ', l:width)]]
                              let l:rows += repeat([l:empty_row], l:height - len(l:rows))
                            
                              return l:rows

FUNCTION  wilder#highlight#get_hl()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/highlight.vim:229
Called 4 times
Total time:   0.000111
 Self time:   0.000065

count  total (s)   self (s)
    4              0.000007   if has('nvim')
    4   0.000102   0.000057     return wilder#highlight#get_hl_nvim(a:group)
                              else
                                return wilder#highlight#get_hl_vim(a:group)
                              endif

FUNCTION  <lambda>1258()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/pipeline.vim:105
Called 1 time
Total time:   0.000289
 Self time:   0.000005

count  total (s)   self (s)
                            return s:run(a:pipeline, a:on_finish, a:on_error, ctx, x, a:i)

FUNCTION  wilder#lua#unref_wrapped_function()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/lua.vim:50
Called 4 times
Total time:   0.000017
 Self time:   0.000017

count  total (s)   self (s)
    4              0.000015   unlet s:functions[a:index]

FUNCTION  <SNR>62_getcompletion()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/cmdline.vim:777
Called 4 times
Total time:   0.001144
 Self time:   0.000150

count  total (s)   self (s)
                              " For python file completions, use wilder#cmdline#python_get_file_completion()
                              " For help tags, use _wilder_python_get_help_tags()
                              " Else use wilder#cmdline#getcompletion()
    4              0.000008   if a:use_python && wilder#cmdline#is_file_expansion(a:res.expand)
                                let l:Completion_func = funcref('wilder#cmdline#python_get_file_completion')
    4              0.000005   elseif a:use_python && a:res.expand ==# 'help' && a:fuzzy
                                let l:Completion_func = {-> {ctx -> _wilder_python_get_help_tags(ctx, &rtp, &helplang)}}
    4              0.000001   else
    4              0.000016     let l:Completion_func = funcref('wilder#cmdline#getcompletion')
    4              0.000001   endif
                            
                              " For tag-regexp, don't do fuzzy completion
                              " If fuzzy, wrap the completion func in wilder#cmdline#get_fuzzy_completion()
    4              0.000005   if a:res.expand ==# 'tags' && a:res.expand_arg[0] ==# '/'
                                let l:Getcompletion = l:Completion_func
    4              0.000002   elseif a:fuzzy
    4              0.000018     let l:Getcompletion = {ctx, x -> wilder#cmdline#get_fuzzy_completion( ctx, x, l:Completion_func, a:fuzzy, a:use_python)}
                              else
                                let l:Getcompletion = l:Completion_func
    4              0.000001   endif
                            
    4   0.001049   0.000054   return wilder#wait(l:Getcompletion(a:ctx, a:res), {ctx, xs -> wilder#resolve(ctx, { 'value': xs, 'pos': a:res.pos, 'data': s:convert_result_to_data(a:res), })})

FUNCTION  <SNR>102_BufferDisabled()
    Defined: ~/.local/share/nvim/lazy/copilot.vim/autoload/copilot.vim:140
Called 7 times
Total time:   0.000259
 Self time:   0.000259

count  total (s)   self (s)
    7              0.000059   if &buftype =~# '^\%(help\|prompt\|quickfix\|terminal\)$'
                                return 5
    7              0.000003   endif
    7              0.000010   if exists('b:copilot_disabled')
                                return empty(b:copilot_disabled) ? 0 : 3
    7              0.000002   endif
    7              0.000008   if exists('b:copilot_enabled')
                                return empty(b:copilot_enabled) ? 4 : 0
    7              0.000002   endif
    7              0.000029   let short = empty(&l:filetype) ? '.' : split(&l:filetype, '\.', 1)[0]
    7              0.000008   let config = {}
    7              0.000020   if type(get(g:, 'copilot_filetypes')) == v:t_dict
    7              0.000010     let config = g:copilot_filetypes
    7              0.000002   endif
    7              0.000010   if has_key(config, &l:filetype)
                                return empty(config[&l:filetype])
    7              0.000009   elseif has_key(config, short)
                                return empty(config[short])
    7              0.000006   elseif has_key(config, '*')
                                return empty(config['*'])
    7              0.000003   else
    7              0.000017     return get(s:filetype_defaults, short, 1) == 0 ? 2 : 0
                              endif

FUNCTION  <lambda>1261()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/pipeline.vim:177
Called 2 times
Total time:   0.000071
 Self time:   0.000009

count  total (s)   self (s)
                            return s:wait_on_finish(a:state, ctx, x)

FUNCTION  <lambda>1266()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/cmdline.vim:309
Called 1 time
Total time:   0.000053
 Self time:   0.000008

count  total (s)   self (s)
                            return wilder#resolve(ctx, wilder#uniq_filt(0, 0, lower_xs + upper_xs))

FUNCTION  <SNR>1_LoadFTPlugin()
    Defined: /opt/homebrew/Cellar/neovim/0.10.1/share/nvim/runtime/ftplugin.vim:15
Called 7 times
Total time:   0.019191
 Self time:   0.019191

count  total (s)   self (s)
    7              0.000013     if exists("b:undo_ftplugin")
                                  exe b:undo_ftplugin
                                  unlet! b:undo_ftplugin b:did_ftplugin
    7              0.000003     endif
                            
    7              0.000013     let s = expand("<amatch>")
    7              0.000006     if s != ""
    7              0.000017       if &cpo =~# "S" && exists("b:did_ftplugin")
                            	" In compatible mode options are reset to the global values, need to
                            	" set the local values also when a plugin was already used.
                            	unlet b:did_ftplugin
    7              0.000003       endif
                            
                                  " When there is a dot it is used to separate filetype names.  Thus for
                                  " "aaa.bbb" load "aaa" and then "bbb".
   14              0.000023       for name in split(s, '\.')
                                    " Load Lua ftplugins after Vim ftplugins _per directory_
                                    " TODO(clason): use nvim__get_runtime when supports globs and modeline
                                    " XXX: "[.]" in the first pattern makes it a wildcard on Windows
    7              0.019005         exe $'runtime! ftplugin/{name}[.]{{vim,lua}} ftplugin/{name}_*.{{vim,lua}} ftplugin/{name}/*.{{vim,lua}}'
   14              0.000046       endfor
    7              0.000003     endif

FUNCTION  <SNR>111_run()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/pipeline.vim:118
Called 44 times
Total time:   0.035603
 Self time:   0.003643

count  total (s)   self (s)
   44              0.000053   if a:x is v:false || a:x is v:true
                                call a:on_finish(a:ctx, a:x)
                                return
   44              0.000012   endif
                            
   44              0.000043   if type(a:x) is v:t_func
                                let l:ctx = copy(a:ctx)
                                call s:prepare_call(a:x, a:pipeline, a:on_finish, a:on_error, l:ctx, a:i)
                                return
   44              0.000011   endif
                            
   44              0.000029   let l:x = a:x
   44              0.000027   let l:i = a:i
                            
   96              0.000106   while l:i < len(a:pipeline)
   80              0.000105     let l:F = a:pipeline[l:i]
                            
   80              0.000078     if type(l:F) isnot v:t_func
                                  call a:on_error(a:ctx, 'pipeline: expected function but got: ' . string(l:F))
                                  return
   80              0.000021     endif
                            
   80              0.000028     try
   80   0.026536   0.001638       let l:Result = l:F(a:ctx, l:x)
                                catch
                                  call a:on_error(a:ctx, 'pipeline: ' . v:exception)
                                  return
   80              0.000032     endtry
                            
   80              0.000099     if l:Result is v:false || l:Result is v:true
   12              0.000323       call a:on_finish(a:ctx, l:Result)
   12              0.000004       return
   68              0.000017     endif
                            
   68              0.000082     if type(l:Result) is v:t_func
   16              0.000026       let l:ctx = copy(a:ctx)
   16   0.000373   0.000133       call s:prepare_call(l:Result, a:pipeline, a:on_finish, a:on_error, l:ctx, l:i+1)
   16              0.000008       return
   52              0.000012     endif
                            
   52              0.000042     let l:x = l:Result
   52              0.000036     let l:i += 1
   68              0.000051   endwhile
                            
   16   0.002425   0.000054   call a:on_finish(a:ctx, l:x)

FUNCTION  <SNR>61_set_firstline()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer/nvim_api.vim:217
Called 6 times
Total time:   0.000073
 Self time:   0.000073

count  total (s)   self (s)
    6              0.000006   if self.state.window_state ==# 'hidden'
                                return
    6              0.000002   endif
                            
    6              0.000005   if self.state.window_state ==# 'pending'
                                let self.state.firstline = a:line
                                return
    6              0.000002   endif
                            
    6              0.000029   call nvim_win_set_cursor(self.state.win, [a:line, 0])

FUNCTION  <SNR>54_get_cmdline_data()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer/popupmenu_palette_theme.vim:127
Called 6 times
Total time:   0.000116
 Self time:   0.000116

count  total (s)   self (s)
    6              0.000008   if a:state.cached_cmdline ==# a:cmdline
    3              0.000003     return a:state.cached_cmdline_data
    3              0.000001   endif
                            
    3              0.000015   let l:cmdline_chars = split(a:cmdline, '\zs')
    3              0.000003   let l:cmdline_data = []
                            
    3              0.000003   let l:byte_pos = 0
    3              0.000003   let l:displaywidth_pos = 0
                            
    3              0.000002   let l:i = 0
    5              0.000006   while l:i < len(l:cmdline_chars)
    2              0.000003     let l:char = l:cmdline_chars[l:i]
                            
                                " [char, byte_len, strdisplaywidth, byte_pos, displaywidth_pos]
    2              0.000002     let l:byte_len = len(l:char)
    2              0.000003     let l:displaywidth = strdisplaywidth(l:char)
    2              0.000004     let l:data = [l:char, l:byte_len, l:displaywidth, l:byte_pos, l:displaywidth_pos]
    2              0.000003     call add(l:cmdline_data, l:data)
                            
    2              0.000002     let l:byte_pos += l:byte_len
    2              0.000003     let l:displaywidth_pos += l:displaywidth
                            
    2              0.000001     let l:i += 1
    5              0.000003   endwhile
                            
    3              0.000003   let a:state.cached_cmdline = a:cmdline
    3              0.000005   let a:state.cached_cmdline_data = l:cmdline_data
                            
    3              0.000002   return a:state.cached_cmdline_data

FUNCTION  <SNR>102_Running()
    Defined: ~/.local/share/nvim/lazy/copilot.vim/autoload/copilot.vim:41
Called 21 times
Total time:   0.000077
 Self time:   0.000077

count  total (s)   self (s)
   21              0.000068   return exists('s:client.job') || exists('s:client.client_id')

FUNCTION  <SNR>60_get_attrs_as_list()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/highlight.vim:209
Called 24 times
Total time:   0.001291
 Self time:   0.001291

count  total (s)   self (s)
   24              0.000016   let l:res = []
                            
  216              0.000104   for l:attr in s:attr_list
  192              0.000177     if has_key(a:attrs, l:attr)
   18              0.000013       if l:attr ==# 'inverse'
                                    let l:attr = 'reverse'
   18              0.000004       endif
                            
   18              0.000014       if a:attrs[l:attr]
   18              0.000020         call add(l:res, l:attr)
                                  else
                                    call add(l:res, 'no' . l:attr)
   18              0.000005       endif
  192              0.000043     endif
  216              0.000075   endfor
                            
   24              0.000013   return l:res

FUNCTION  <lambda>914()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/pipe/branch.vim:16
Called 1 time
Total time:   0.000018
 Self time:   0.000004

count  total (s)   self (s)
                            return s:on_finish(l:state, ctx, x)

FUNCTION  <SNR>52_mru_update()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/cache.vim:56
Called 2 times
Total time:   0.000033
 Self time:   0.000033

count  total (s)   self (s)
    2              0.000003   let l:queue = self['_queue']
    2              0.000002   let l:counts = self['_counts']
                            
    2              0.000004   call add(l:queue, a:key)
    2              0.000003   if !has_key(l:counts, a:key)
    2              0.000002     let l:counts[a:key] = 1
                              else
                                let l:counts[a:key] += 1
    2              0.000001   endif
                            
    2              0.000003   if len(l:queue) > self['_max_size']
                                let l:removed_key = remove(l:queue, 0)
                                let l:counts[l:removed_key] -= 1
                            
                                if l:counts[l:removed_key] == 0
                                  unlet l:counts[l:removed_key]
                                  unlet self['_cache'][l:removed_key]
                                endif
    2              0.000001   endif

FUNCTION  <SNR>16_GetCurrentInternalBuffer()
    Defined: ~/.local/share/nvim/lazy/any-jump.vim/plugin/any-jump.vim:331
Called 3 times
Total time:   0.000018
 Self time:   0.000018

count  total (s)   self (s)
    3              0.000010   if exists('t:any_jump')
    3              0.000005     return t:any_jump
                              else
                                throw "any-jump internal buffer lost"
                              endif

FUNCTION  19()
    Defined: ~/.local/share/nvim/lazy/any-jump.vim/autoload/internal_buffer.vim:47
Called 3 times
Total time:   0.000231
 Self time:   0.000231

count  total (s)   self (s)
    3              0.000029   let object = {"items":                    [],"current_page":             0,"gc":                       v:false,"preview_opened":           v:false,"usages_opened":            v:false,"grouping_enabled":         v:false,"overmaxed_results_hidden": v:true,"definitions_grep_results": [],"usages_grep_results":      [],"vim_bufnr":                0,"popup_winid":              0,"previous_bufnr":           0,}
                            
   72              0.000039   for method in self.MethodsList
   69              0.000128     let object[method] = s:InternalBuffer[method]
   72              0.000019   endfor
                            
    3              0.000002   return object

FUNCTION  wilder#render#chunks_displaywidth()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/render.vim:250
Called 330 times
Total time:   0.003846
 Self time:   0.003846

count  total (s)   self (s)
  330              0.000189   let l:width = 0
                            
  984              0.000489   for l:chunk in a:chunks
  654              0.000438     if !empty(l:chunk)
  654              0.000823       let l:width += strdisplaywidth(l:chunk[0])
  654              0.000153     endif
  984              0.000737   endfor
                            
  330              0.000161   return l:width

FUNCTION  <SNR>67_branch()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/pipe/branch.vim:9
Called 12 times
Total time:   0.009195
 Self time:   0.000279

count  total (s)   self (s)
   12              0.000058   let l:state = { 'index': 0, 'pipelines': a:pipelines, 'original_ctx': copy(a:ctx), 'original_x': copy(a:x), }
                            
   12   0.009126   0.000210   call wilder#pipeline#run( l:state.pipelines[0], {ctx, x -> s:on_finish(l:state, ctx, x)}, {ctx, x -> s:on_error(l:state, ctx, x)}, copy(a:ctx), copy(a:x), )

FUNCTION  <SNR>2_LoadIndent()
    Defined: /opt/homebrew/Cellar/neovim/0.10.1/share/nvim/runtime/indent.vim:14
Called 7 times
Total time:   0.005200
 Self time:   0.005200

count  total (s)   self (s)
    7              0.000011     if exists("b:undo_indent")
                                  exe b:undo_indent
                                  unlet! b:undo_indent b:did_indent
    7              0.000002     endif
    7              0.000012     let s = expand("<amatch>")
    7              0.000005     if s != ""
    7              0.000007       if exists("b:did_indent")
                            	unlet b:did_indent
    7              0.000002       endif
                            
                                  " When there is a dot it is used to separate filetype names.  Thus for
                                  " "aaa.bbb" load "indent/aaa.vim" and then "indent/bbb.vim".
   14              0.000020       for name in split(s, '\.')
                                    " XXX: "[.]" in the pattern makes it a wildcard on Windows
    7              0.005091         exe $'runtime! indent/{name}[.]{{vim,lua}}'
   14              0.000009       endfor
    7              0.000002     endif

FUNCTION  <SNR>60_make_hl_from_list()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/highlight.vim:158
Called 4 times
Total time:   0.000763
 Self time:   0.000269

count  total (s)   self (s)
    4   0.000168   0.000036   let l:term_hl = s:normalise_attrs(a:args[0])
    4   0.000182   0.000019   let l:cterm_hl = s:normalise_attrs(a:args[1])
    4   0.000217   0.000019   let l:gui_hl = s:normalise_attrs(a:args[2])
                            
    4              0.000006   let l:cmd = 'hi! ' . a:name . ' '
                            
    4              0.000004   let l:term_attr = l:term_hl[2:]
    4              0.000004   if len(l:term_hl) >= 2
                                let l:cmd .= 'term=' . join(l:term_attr, ',') . ' '
    4              0.000001   endif
                            
    4              0.000005   let l:cterm_attr = l:cterm_hl[2:]
    4              0.000004   if !empty(l:cterm_attr)
    4              0.000012     let l:cmd .= 'cterm=' . join(l:cterm_attr, ',') . ' '
    4              0.000001   endif
                            
    4              0.000004   if len(l:cterm_hl) >= 1
    4              0.000004     if l:cterm_hl[0] >= 0
    4              0.000009       let l:cmd .= 'ctermfg=' . l:cterm_hl[0] . ' '
    4              0.000001     endif
                            
    4              0.000006     if len(l:cterm_hl) >= 2 && l:cterm_hl[1] >= 0
    4              0.000007       let l:cmd .= 'ctermbg=' . l:cterm_hl[1] . ' '
    4              0.000001     endif
    4              0.000001   endif
                            
    4              0.000005   let l:gui_attr = l:gui_hl[2:]
    4              0.000004   if !empty(l:gui_attr)
    4              0.000010     let l:cmd .= 'gui=' . join(l:gui_attr, ',') . ' '
    4              0.000001   endif
                            
    4              0.000003   if len(l:gui_hl) >= 1
    4              0.000006     if type(l:gui_hl[0]) == v:t_number
    2              0.000009       let l:cmd .= 'guifg=' . printf('#%06x', l:gui_hl[0]) . ' '
    2              0.000001     else
    2              0.000003       let l:cmd .= 'guifg=' . l:gui_hl[0] . ' '
    4              0.000001     endif
                            
    4              0.000003     if len(l:gui_hl) >= 2
    4              0.000005       if type(l:gui_hl[1]) == v:t_number
    2              0.000005         let l:cmd .= 'guibg=' . printf('#%06x', l:gui_hl[1]) . ' '
    2              0.000001       else
    2              0.000003         let l:cmd .= 'guibg=' . l:gui_hl[1] . ' '
    4              0.000001       endif
    4              0.000001     endif
    4              0.000001   endif
                            
    4              0.000031   exe l:cmd

FUNCTION  20()
    Defined: ~/.local/share/nvim/lazy/any-jump.vim/autoload/internal_buffer.vim:70
Called 75 times
Total time:   0.000079
 Self time:   0.000079

count  total (s)   self (s)
   75              0.000064   return len(self.items)

FUNCTION  21()
    Defined: ~/.local/share/nvim/lazy/any-jump.vim/autoload/internal_buffer.vim:74
Called 117 times
Total time:   0.007354
 Self time:   0.007354

count  total (s)   self (s)
  117              0.000098   let text           = s:nvim ? " " : ""
  117              0.000064   let idx            = 0
  117              0.000083   let next_start_col = 1
                            
                              " calculate & assign items start & end columns
  312              0.000155   for item in a:items
                                " separate items in line with 1 space
  195              0.000090     if idx == 0
  117              0.000118       let text = text . item.text
   78              0.000021     else
   78              0.000078       if has_key(item.data, 'no_padding')
                                    let text = text . item.text
   78              0.000019       else
   78              0.000110         let text = text . ' ' . item.text
   78              0.000071         let next_start_col = next_start_col + 1
   78              0.000020       endif
  195              0.000045     endif
                            
  195              0.000152     let item.start_col = next_start_col
  195              0.000247     let item.end_col   = next_start_col + len(item.text)
                            
  195              0.000151     let next_start_col  = item.end_col
  195              0.000111     let idx            += 1
  312              0.000223   endfor
                            
                              " filter out empty whitespaces
  117              0.000244   if text =~ '^\s\+$'
   24              0.000014     let text = ''
  117              0.000030   endif
                            
                              " write final text to buffer
  117              0.001424   call appendbufline(self.vim_bufnr, a:line - 1, text)
                            
                              " colorize
  312              0.000165   for item in a:items
  195              0.000078     if s:nvim
  195              0.000553       call nvim_buf_add_highlight(self.vim_bufnr,-1,item.hl_group,a:line - 1,item.start_col,item.end_col)
                                else
                                  call prop_add(a:line, item.start_col, {'length': item.len,'type': item.hl_group,'bufnr': self.vim_bufnr})
  195              0.000046     endif
  312              0.000115   endfor

FUNCTION  22()
    Defined: ~/.local/share/nvim/lazy/any-jump.vim/autoload/internal_buffer.vim:127
Called 72 times
Total time:   0.005137
 Self time:   0.000476

count  total (s)   self (s)
   72              0.000072   if type(a:items) == v:t_list
   72   0.004899   0.000238     call self.RenderLine(a:items, self.len() + 1)
   72              0.000079     call add(self.items, a:items)
                            
   72              0.000042     return v:true
                              else
                                echoe "array required, got invalid type: " . string(a:items)
                            
                                return v:false
                              endif

FUNCTION  24()
    Defined: ~/.local/share/nvim/lazy/any-jump.vim/autoload/internal_buffer.vim:155
Called 195 times
Total time:   0.002269
 Self time:   0.002269

count  total (s)   self (s)
  195              0.000150   let data = {}
                            
  195              0.000080   if a:0
  144              0.000099     let data = a:1
  195              0.000054   endif
                            
  195              0.000742   let item = {"type":      a:type,"text":      a:text,"len":       len(a:text),"start_col": 0,"end_col":   0,"hl_group":  a:hl_group,"gc":        v:false,"data":      data}
                            
                              " TODO: optimize this part for rednering perfomance
  195              0.000081   if !s:nvim
                                if prop_type_get(item.hl_group, {'bufnr': self.vim_bufnr}) == {}
                                  call prop_type_add(item.hl_group, {'highlight': item.hl_group,'bufnr': self.vim_bufnr})
                                endif
  195              0.000047   endif
                            
  195              0.000090   return item

FUNCTION  26()
    Defined: ~/.local/share/nvim/lazy/any-jump.vim/autoload/internal_buffer.vim:221
Called 3 times
Total time:   0.000116
 Self time:   0.000116

count  total (s)   self (s)
    3              0.000002   let i = 0
    3              0.000002   let found = 0
                            
   12              0.000006   for line in self.items
   12              0.000007     let i += 1
                            
   27              0.000012     for item in line
   18              0.000016       if item == a:item
    3              0.000002         let found = i
    3              0.000001         break
   15              0.000003       endif
   27              0.000007     endfor
                            
   12              0.000006     if found > 0
    3              0.000001       break
    9              0.000002     endif
   12              0.000004   endfor
                            
    3              0.000002   return found

FUNCTION  28()
    Defined: ~/.local/share/nvim/lazy/any-jump.vim/autoload/internal_buffer.vim:267
Called 3 times
Total time:   0.000243
 Self time:   0.000243

count  total (s)   self (s)
    3              0.000002   let result = 0
    3              0.000002   let layer  = 0
                            
    3              0.000002   if a:0 == 1
    3              0.000002     let layer = a:1
    3              0.000001   endif
                            
   15              0.000008   for line in self.items
   15              0.000015     if type(result) == v:t_dict
    3              0.000001       break
   12              0.000003     endif
                            
   27              0.000013     for item in line
   18              0.000019       let type_is_ok  = item.type == a:type
   18              0.000013       let layer_is_ok = v:true
                            
   18              0.000016       if type(layer) == v:t_string
                                    let layer_is_ok = item.data.layer == layer
   18              0.000004       endif
                            
   18              0.000012       if type_is_ok && layer_is_ok
    3              0.000002         let result = item
    3              0.000001         break
   15              0.000003       endif
   27              0.000007     endfor
   15              0.000006   endfor
                            
    3              0.000002   return result

FUNCTION  <SNR>109_do()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/main.vim:248
Called 4 times
Total time:   0.002848
 Self time:   0.000218

count  total (s)   self (s)
    4              0.000008   if !s:active || !s:enabled
                                return
    4              0.000002   endif
                            
    4   0.000026   0.000012   if a:check && !wilder#main#in_mode()
                                call wilder#main#stop()
                                return
    4              0.000001   endif
                            
    4   0.000046   0.000032   let l:input = s:getcmdline()
                            
    4              0.000007   let l:has_completion = l:input ==# s:completion
    4              0.000008   let l:is_new_input = s:previous_cmdline is v:null
    4              0.000008   let l:input_changed = s:previous_cmdline isnot v:null && s:previous_cmdline !=# l:input
    4              0.000011   let l:should_keep_completion = s:completion_from_reject_completion isnot v:null && s:completion_from_reject_completion ==# l:input
                            
    4              0.000005   if !l:has_completion && !l:should_keep_completion
    4              0.000004     let s:completion = v:null
    4              0.000004     let s:replaced_cmdline = v:null
    4              0.000005     let s:completion_stack = []
    4              0.000001   endif
                            
    4              0.000003   if !l:should_keep_completion
    4              0.000005     let s:completion_from_reject_completion = v:null
    4              0.000001   endif
                            
    4              0.000005   if s:previous_cmdline is v:null || l:input_changed
    4              0.000004     let s:previous_cmdline = l:input
    4              0.000001   endif
                            
    4              0.000003   let s:draw_done = 0
                            
    4              0.000006   if !l:has_completion && (l:input_changed || l:is_new_input)
    4   0.001078   0.000020     call s:run_pipeline(l:input)
                            
    4              0.000003     if !s:draw_done
    4   0.001561   0.000016       call s:draw()
    4              0.000001     endif
    4              0.000001   endif
                            
    4              0.000003   let s:force = 0

FUNCTION  wilder#main#start()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/main.vim:79
Called 11 times
Total time:   0.000848
 Self time:   0.000496

count  total (s)   self (s)
                              " Workaround for https://github.com/neovim/neovim/issues/15403
   11   0.000556   0.000204   if wilder#main#in_mode() && s:enabled
                                " use timer_start so statusline does not flicker
                                " when using mappings which performs a command
   11              0.000155     call timer_start(0, {-> s:start()})
   11              0.000066   endif

FUNCTION  <SNR>58_render_lines()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer/popupmenu.vim:285
Called 6 times
Total time:   0.072428
 Self time:   0.015491

count  total (s)   self (s)
    6              0.000008   if !has_key(a:ctx, 'error')
                                " +1 to account for the cmdline prompt.
    6              0.000010     let l:pos = get(a:result, 'pos', 0) + 1
    6              0.000007     let l:pos -= a:state.left_offset
    6              0.000004     if l:pos < 0
                                  let l:pos = 0
    6              0.000002     endif
                              else
                                let l:cmdline = getcmdline()
                                let l:parsed = wilder#cmdline#parse(l:cmdline)
                                let l:pos = l:parsed.pos
    6              0.000002   endif
                            
    6              0.000006   let l:selected = a:ctx.selected
    6              0.000005   let l:reverse = a:state.reverse
                            
    6              0.000010   let [l:page_start, l:page_end] = a:state.page
                            
    6              0.000006   if a:state.page != [-1, -1]
                                " draw candidates
    6   0.031561   0.000111     let [l:lines, l:width] = s:make_lines(a:state, a:ctx, a:result)
    6              0.000010     let l:lines = l:reverse ? reverse(l:lines) : l:lines
                              else
                                if has_key(a:ctx, 'error')
                                  " draw error
                                  let l:lines = s:make_message(a:state, a:ctx, a:state.error_message, s:empty_result, a:ctx.error, 'error')
                                else
                                  " draw empty message
                                  let l:lines = s:make_message(a:state, a:ctx, a:state.empty_message, a:result, a:result, 'empty_message')
                                endif
                            
                                let l:width = empty(l:lines) ? a:state.get_min_width(a:ctx, a:result) : wilder#render#chunks_displaywidth(l:lines[0])
    6              0.000002   endif
                            
    6              0.000038   let l:ctx = extend({'width': l:width}, a:ctx)
                            
                              " height excluding top and bottom
    6              0.000008   let l:lines_height = len(l:lines)
                            
    6              0.000005   let l:top_lines = []
    6              0.000005   let l:top_height = 0
   24              0.000020   for l:Top in a:state.top
   18   0.006946   0.000108     let l:line = s:draw_top_or_bottom_line(l:Top, l:ctx, a:result)
                            
   18              0.000016     if empty(l:line)
                                  continue
   18              0.000005     endif
                            
   18              0.000026     call add(l:top_lines, l:line)
   18              0.000018     let l:top_height += 1
   24              0.000009   endfor
    6              0.000014   let l:lines = l:top_lines + l:lines
                            
    6              0.000005   let l:bottom_height = 0
   12              0.000016   for l:Bottom in a:state.bottom
    6   0.001745   0.000033     let l:line = s:draw_top_or_bottom_line(l:Bottom, l:ctx, a:result)
                            
    6              0.000005     if empty(l:line)
                                  continue
    6              0.000002     endif
                            
    6              0.000007     call add(l:lines, l:line)
    6              0.000007     let l:bottom_height += 1
   12              0.000005   endfor
                            
    6              0.000005   if empty(l:lines)
                                call a:state.api.hide()
                                return
    6              0.000002   endif
                            
    6   0.000794   0.000019   call a:state.api.show()
                            
    6              0.000007   let l:height = len(l:lines)
    6   0.000085   0.000022   let l:max_height = a:state.get_max_height(a:ctx, a:result)
    6              0.000005   if l:max_height > &lines
                                let l:max_height = &lines
    6              0.000002   endif
    6   0.000444   0.000160   let [l:row, l:col] = a:state.position(a:ctx, l:pos, {'height': l:height, 'width': l:width, 'max_height': l:max_height})
                            
    6   0.000116   0.000024   call a:state.api.move(l:row, l:col, l:height, l:width)
    6   0.000157   0.000037   call a:state.api.set_option('wrap', v:false)
    6   0.000115   0.000025   call a:state.api.clear_all_highlights()
    6   0.000310   0.000052   call a:state.api.delete_all_lines()
                            
    6              0.000015   let l:default_hl = a:state.highlights['default']
    6              0.000008   let l:selected_hl = a:state.highlights['selected']
                            
    6              0.000004   let l:i = 0
  140              0.000123   while l:i < len(l:lines)
  134              0.000122     let l:chunks = l:lines[l:i]
                            
  134              0.000080     let l:text = ''
  994              0.000409     for l:chunk in l:chunks
  860              0.000825       let l:text .= l:chunk[0]
  994              0.000244     endfor
                            
  134   0.001798   0.000423     call a:state.api.set_line(l:i, l:text)
                            
                                " Don't apply selected for top lines or error or empty message.
  134              0.000284     if l:page_start == -1 || (!l:reverse && l:i < l:top_height) || (l:reverse && l:i >= l:top_height + l:lines_height)
   18              0.000016       let l:is_selected = 0
  116              0.000030     else
  116              0.000296       let l:is_selected = l:reverse ?  l:page_start + (l:height - l:i - l:bottom_height - 1) == l:selected : l:page_start + l:i - l:top_height == l:selected
  134              0.000032     endif
                            
  134              0.000072     let l:start = 0
  994              0.000421     for l:chunk in l:chunks
  860              0.001001       let l:end = l:start + len(l:chunk[0])
                            
  860              0.000395       if l:is_selected
                                    if len(l:chunk) == 1
                                      let l:hl = l:selected_hl
                                    elseif len(l:chunk) == 2
                                      let l:hl = l:chunk[1]
                                    else
                                      let l:hl = l:chunk[2]
                                    endif
  860              0.000192       else
  860              0.001040         let l:hl = get(l:chunk, 1, l:default_hl)
  860              0.000203       endif
                            
  860              0.000594       if l:hl !=# l:default_hl
  110   0.000830   0.000426         call a:state.api.add_highlight(l:hl, l:i, l:start, l:end)
  860              0.000210       endif
                            
  860              0.000509       let l:start = l:end
  994              0.000463     endfor
                            
  134              0.000079     let l:i += 1
  140              0.000049   endwhile
                            
    6   0.000109   0.000036   call a:state.api.set_firstline(1)
    6   0.013431   0.000031   call wilder#renderer#redraw(a:state.apply_incsearch_fix)

FUNCTION  31()
    Defined: ~/.local/share/nvim/lazy/any-jump.vim/autoload/internal_buffer.vim:351
Called 3 times
Total time:   0.000406
 Self time:   0.000047

count  total (s)   self (s)
    3   0.000253   0.000010   let item = self.GetFirstItemOfType(a:type, a:000)
                            
    3              0.000003   if type(item) == v:t_dict
    3   0.000132   0.000016     let ln = self.GetItemLineNumber(item)
    3              0.000013     call cursor(ln, 2)
    3              0.000001   endif

FUNCTION  37()
    Defined: ~/.local/share/nvim/lazy/any-jump.vim/autoload/internal_buffer.vim:390
Called 60 times
Total time:   0.003922
 Self time:   0.002224

count  total (s)   self (s)
   60              0.000039   let gr    = a:gr
   60              0.000036   let items = []
                            
   60              0.000135   let options ={ "path": gr.path, "line_number": gr.line_number, "layer": a:layer }
   60              0.000170   let original_link_options ={ "path": gr.path, "line_number": gr.line_number,"layer": a:layer, "original_link": v:true }
                            
   60              0.000041   if g:any_jump_list_numbers
                                let prefix_text = a:current_idx + 1
                                let prefix = self.CreateItem("link", prefix_text, g:AnyJumpGetColor('result_line_number'), options)
                            
                                call add(items, prefix)
   60              0.000015   endif
                            
   60              0.000068   if g:any_jump_results_ui_style == 'filename_first'
   60              0.000088     let path_text    = gr.path .  ":" . gr.line_number
   60   0.001219   0.000355     let matched_text = self.CreateItem("link", "" . gr.text, g:AnyJumpGetColor('result_text'), original_link_options)
   60   0.001187   0.000352     let file_path    = self.CreateItem("link", path_text, g:AnyJumpGetColor('result_path'), options)
                            
   60              0.000063     call add(items, file_path)
   60              0.000059     call add(items, matched_text)
                              elseif g:any_jump_results_ui_style == 'filename_last'
                                let path_text    = '' .  gr.path .  ":" . gr.line_number
                                let matched_text = self.CreateItem("link", gr.text, g:AnyJumpGetColor('result_text'), original_link_options)
                                let file_path    = self.CreateItem("link", path_text, g:AnyJumpGetColor('result_path'), options)
                            
                                call add(items, matched_text)
                                call add(items, file_path)
   60              0.000016   endif
                            
   60              0.000029   return items

FUNCTION  wilder#cmdline#getcompletion()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/cmdline.vim:345
Called 6 times
Total time:   0.000899
 Self time:   0.000899

count  total (s)   self (s)
    6              0.000012   if has_key(a:res, 'completions')
                                return a:res['completions']
    6              0.000002   endif
                            
    6              0.000007   let l:expand_arg = a:res.expand_arg
                            
                              " getting all shellcmds takes a significant amount of time
    6              0.000009   if a:res.expand ==# 'shellcmd' && empty(l:expand_arg)
                                return []
    6              0.000002   endif
                            
    6              0.000013   if a:res.expand ==# 'dir' || a:res.expand ==# 'file' || a:res.expand ==# 'file_in_path' || a:res.expand ==# 'shellcmd'
                            
                                if get(a:res, 'has_wildcard', 0)
                                  let l:xs = expand(l:expand_arg, 0, 1)
                            
                                  if len(l:xs) == 1 && l:xs[0] ==# l:expand_arg
                                    return []
                                  endif
                            
                                  return l:xs
                                endif
                            
                                return getcompletion(l:expand_arg, a:res.expand, 1)
    6              0.000001   endif
                            
    6              0.000007   if a:res.expand ==# 'nothing' || a:res.expand ==# 'unsuccessful'
                                return []
    6              0.000005   elseif a:res.expand ==# 'augroup'
                                return getcompletion(l:expand_arg, 'augroup')
    6              0.000004   elseif a:res.expand ==# 'arglist'
                                return getcompletion(l:expand_arg, 'arglist')
    6              0.000004   elseif a:res.expand ==# 'behave'
                                return getcompletion(l:expand_arg, 'behave')
    6              0.000004   elseif a:res.expand ==# 'buffer'
                                let l:buffers = getcompletion(l:expand_arg, 'buffer')
                                return map(l:buffers, {_, x -> fnamemodify(x, ':~:.')})
    6              0.000004   elseif a:res.expand ==# 'checkhealth'
                                return has('nvim') ? getcompletion(l:expand_arg, 'checkhealth') : []
    6              0.000004   elseif a:res.expand ==# 'color'
                                return getcompletion(l:expand_arg, 'color')
    6              0.000004   elseif a:res.expand ==# 'command'
    6              0.000700     return getcompletion(l:expand_arg, 'command')
                              elseif a:res.expand ==# 'compiler'
                                return getcompletion(l:expand_arg, 'compiler')
                              elseif a:res.expand ==# 'cscope'
                                return getcompletion(a:res.cmdline[a:res.subcommand_start :], 'cscope')
                              elseif a:res.expand ==# 'event'
                                return getcompletion(l:expand_arg, 'event')
                              elseif a:res.expand ==# 'event_and_augroup'
                                return getcompletion(l:expand_arg, 'event') + getcompletion(l:expand_arg, 'augroup')
                              elseif a:res.expand ==# 'expression'
                                return getcompletion(l:expand_arg, 'expression')
                              elseif a:res.expand ==# 'environment'
                                return getcompletion(l:expand_arg, 'environment')
                              elseif a:res.expand ==# 'file_opt'
                                let l:opts = ['bad', 'bin', 'enc', 'ff', 'nobin']
                                if a:res.cmd ==# 'read'
                                  call insert(l:opts, 'edit', 2)
                                endif
                            
                                return filter(l:opts, {_, x -> s:is_prefix(x, l:expand_arg)})
                              elseif a:res.expand ==# 'function'
                                return getcompletion(l:expand_arg, 'function')
                              elseif a:res.expand ==# 'help'
                                return getcompletion(l:expand_arg, 'help')
                              elseif a:res.expand ==# 'highlight'
                                return getcompletion(l:expand_arg, 'highlight')
                              elseif a:res.expand ==# 'history'
                                return getcompletion(l:expand_arg, 'history')
                              elseif a:res.expand ==# 'language'
                                return getcompletion(l:expand_arg, 'locale') + filter(['ctype', 'messages', 'time'], {_, x -> s:is_prefix(x, l:expand_arg)})
                              elseif a:res.expand ==# 'locale'
                                return getcompletion(l:expand_arg, 'locale')
                              elseif a:res.expand ==# 'lua'
                                " Lua completion handled by s:get_lua_completion()
                                return []
                              elseif a:res.expand ==# 'mapping'
                                let l:map_args = get(a:res, 'map_args', {})
                            
                                let l:result = []
                            
                                if l:expand_arg ==# '' || l:expand_arg[0] ==# '<'
                                  for l:map_arg in ['<buffer>', '<unique>', '<nowait>', '<silent>', '<special>', '<script>', '<expr>']
                                    if !has_key(l:map_args, l:map_arg)
                                      call add(l:result, l:map_arg)
                                    endif
                                  endfor
                            
                                  if l:expand_arg[0] ==# '<'
                                    call filter(l:result, {_, x -> s:is_prefix(x, l:expand_arg)})
                                  endif
                                endif
                            
                                if a:res.cmd[-5 :] ==# 'unmap'
                                  let l:mode = a:res.cmd ==# 'unmap' ? '' : a:res.cmd[0]
                                  let l:cmd = 'map'
                                elseif a:res.cmd[-3 :] ==# 'map'
                                  let l:mode = a:res.cmd ==# 'map' || a:res.cmd ==# 'noremap' ? '' : a:res.cmd[0]
                                  let l:cmd = 'map'
                                elseif a:res.cmd[-12 :] ==# 'unabbreviate'
                                  let l:mode = a:res.cmd ==# 'unabbreviate' ? '' : a:res.cmd[0]
                                  let l:cmd = 'abbrev'
                                elseif a:res.cmd ==# 'abbreviate'
                                  let l:mode = ''
                                  let l:cmd = 'abbrev'
                                elseif a:res.cmd[-6 :] ==# 'abbrev'
                                  let l:mode = a:res.cmd ==# 'noreabbrev' ? '' : a:res.cmd[0]
                                  let l:cmd = 'abbrev'
                                else
                                  let l:mode = ''
                                  let l:cmd = 'map'
                                endif
                            
                                let l:lines = split(execute(l:mode . l:cmd . ' ' . join(keys(l:map_args), ' ') . ' ' . l:expand_arg), "\n")
                            
                                if len(l:lines) != 1 || (l:lines[0] !=# 'No mapping found' && l:lines[0] !=# 'No abbreviation found')
                                  for l:line in l:lines
                                    let l:words = split(l:line,'\s\+')
                                    if l:line[0] ==# ' '
                                      let l:map_lhs = l:words[0]
                                    else
                                      let l:map_lhs = l:words[1]
                                    endif
                            
                                    call add(l:result, l:map_lhs)
                                  endfor
                                endif
                            
                                return wilder#uniq_filt(0, 0, l:result)
                              elseif a:res.expand ==# 'mapclear'
                                return s:is_prefix('<buffer>', l:expand_arg) ? ['<buffer>'] : []
                              elseif a:res.expand ==# 'menu'
                                if !has_key(a:res, 'menu_arg')
                                  return []
                                endif
                                return getcompletion(a:res.menu_arg, 'menu')
                              elseif a:res.expand ==# 'messages'
                                return getcompletion(l:expand_arg, 'messages')
                              elseif a:res.expand ==# 'option'
                                return getcompletion(l:expand_arg, 'option')
                              elseif a:res.expand ==# 'option_bool'
                                return filter(wilder#cmdline#set#get_bool_options(), {_, x -> s:is_prefix(x, l:expand_arg)})
                              elseif a:res.expand ==# 'option_old'
                                let l:old_option = eval('&' . a:res.option)
                                return [type(l:old_option) is v:t_string ? l:old_option : string(l:old_option)]
                              elseif a:res.expand ==# 'packadd'
                                return getcompletion(l:expand_arg, 'packadd')
                              elseif a:res.expand ==# 'profile'
                                return filter(['continue', 'dump', 'file', 'func', 'pause', 'start'], {_, x -> s:is_prefix(x, l:expand_arg)})
                              elseif a:res.expand ==# 'ownsyntax'
                                return getcompletion(l:expand_arg, 'syntax')
                              elseif a:res.expand ==# 'shellcmd'
                                return getcompletion(l:expand_arg, 'shellcmd')
                              elseif a:res.expand ==# 'sign'
                                return getcompletion(a:res.cmdline[a:res.subcommand_start :], 'sign')
                              elseif a:res.expand ==# 'syntax'
                                return getcompletion(l:expand_arg, 'syntax')
                              elseif a:res.expand ==# 'syntax_subcommand'
                                return filter(['case', 'clear', 'cluster', 'conceal', 'enable', 'foldlevel', 'include', 'iskeyword', 'keyword', 'list', 'manual', 'match', 'off', 'on', 'region', 'reset', 'spell', 'sync'], {_, x -> s:is_prefix(x, l:expand_arg)})
                                return getcompletion(l:expand_arg, 'syntax')
                              elseif a:res.expand ==# 'syntime'
                                return getcompletion(l:expand_arg, 'syntime')
                              elseif a:res.expand ==# 'user'
                                return getcompletion(l:expand_arg, 'user')
                              elseif a:res.expand ==# 'user_func'
                                let l:functions = getcompletion(l:expand_arg, 'function')
                                let l:functions = filter(l:functions, {_, x -> !(x[0] >= 'a' && x[0] <= 'z')})
                                return map(l:functions, {_, x -> x[-1 :] ==# ')' ? x[: -3] : x[: -2]})
                              elseif a:res.expand ==# 'user_addr_type'
                                return filter(['arguments', 'buffers', 'lines', 'loaded_buffers', 'quickfix', 'tabs', 'windows'], {_, x -> s:is_prefix(x, l:expand_arg)})
                              elseif a:res.expand ==# 'user_cmd_flags'
                                return filter(['addr', 'bar', 'buffer', 'complete', 'count', 'nargs', 'range', 'register'], {_, x -> s:is_prefix(x, l:expand_arg)})
                              elseif a:res.expand ==# 'user_complete'
                                return filter(['arglist', 'augroup', 'behave', 'buffer', 'checkhealth', 'color', 'command', 'compiler', 'cscope', 'custom', 'customlist', 'dir', 'environment', 'event', 'expression', 'file', 'file_in_path', 'filetype', 'function', 'help', 'highlight', 'history', 'locale', 'mapclear', 'mapping', 'menu', 'messages', 'option', 'packadd', 'shellcmd', 'sign', 'syntax', 'syntime', 'tag', 'tag_listfiles', 'user', 'var'], {_, x -> s:is_prefix(x, l:expand_arg)})
                              elseif a:res.expand ==# 'user_nargs'
                                if empty(l:expand_arg)
                                  return ['*', '+', '0', '1', '?']
                                endif
                            
                                if l:expand_arg ==# '*' || l:expand_arg ==# '+' || l:expand_arg ==# '0' || l:expand_arg ==# '1' || l:expand_arg ==# '?'
                                  return [l:expand_arg]
                                endif
                            
                                return []
                              elseif a:res.expand ==# 'user_commands'
                                return filter(getcompletion(l:expand_arg, 'command'), {_, x -> x[0] >=# 'A' && x[0] <=# 'Z'})
                              elseif a:res.expand ==# 'tags'
                                if a:ctx.session_id > s:cached_tags_session_id
                                  let s:cached_tags_session_id = a:ctx.session_id
                                  let s:cached_tags = {}
                                endif
                            
                                let l:arg = a:res.expand_arg
                                if l:arg[0] ==# '/'
                                  let l:taglist_arg = l:arg[1:]
                                else
                                  let l:taglist_arg = l:arg
                                endif
                            
                                if empty(l:taglist_arg)
                                  let l:taglist_arg = '.'
                                endif
                            
                                if !has_key(s:cached_tags, l:taglist_arg)
                                  let s:cached_tags[l:taglist_arg] = map(taglist(l:taglist_arg), {_, x -> x.name})
                                endif
                            
                                return copy(s:cached_tags[l:taglist_arg])
                              elseif a:res.expand ==# 'var'
                                return getcompletion(l:expand_arg, 'var')
                              endif
                            
                              if !exists('s:has_get_completion_cmdline')
                                try
                                  " cmdline completion only available in Vim 8.2+
                                  call getcompletion('foo', 'cmdline')
                                  let s:has_getcompletion_cmdline = 1
                                catch
                                  let s:has_getcompletion_cmdline = 0
                                endtry
                              endif
                            
                              " fallback to cmdline getcompletion
                              if s:has_getcompletion_cmdline
                                return getcompletion(a:res.cmdline, 'cmdline')
                              endif
                            
                              return []

FUNCTION  39()
    Defined: ~/.local/share/nvim/lazy/any-jump.vim/autoload/internal_buffer.vim:448
Called 3 times
Total time:   0.005835
 Self time:   0.000555

count  total (s)   self (s)
    3              0.000003   let start_ln     = a:start_ln
    3              0.000002   let hidden_count = 0
                            
                              " TODO: move to method
    3              0.000009   if type(g:any_jump_max_search_results) == v:t_number && g:any_jump_max_search_results > 0 && self.overmaxed_results_hidden == v:true
                            
    3              0.000004     let cp = self.current_page ? self.current_page : 1
    3              0.000004     let to = (cp * g:any_jump_max_search_results) - 1
                            
    3              0.000006     let collection   = self.usages_grep_results[0 : to]
    3              0.000011     let hidden_count = len(self.usages_grep_results[to : -1])
                              else
                                let collection = self.usages_grep_results
    3              0.000001   endif
                            
    3   0.000441   0.000057   call self.AddLineAt([self.CreateItem("text", ">", g:AnyJumpGetColor('heading_text'), {'layer': 'usages'}),self.CreateItem("text", self.keyword, g:AnyJumpGetColor('heading_keyword'), {'layer': 'usages'}),self.CreateItem("text", len(self.usages_grep_results) . " references", g:AnyJumpGetColor('heading_text'), {'layer': 'usages'}),], start_ln)
                            
                            
    3              0.000003   let start_ln += 1
                            
    3   0.000291   0.000017   call self.AddLineAt([ self.CreateItem("text", "", "Comment", {"layer": "usages"}) ], start_ln)
                            
    3              0.000003   let start_ln += 1
                            
    3              0.000002   let idx = 0
    3              0.000002   if self.grouping_enabled
                                " group by file name rendering
                                let render_map = {}
                            
                                for gr in collection
                                  if !has_key(render_map, gr.path)
                                    let render_map[gr.path] = []
                                  endif
                            
                                  call add(render_map[gr.path], gr)
                                endfor
                            
                                let path_idx = 0
                                for path in keys(render_map)
                                  let first_gr = render_map[path][0]
                                  let opts     = {"path":         path,"line_number":  first_gr.line_number,"layer":        "usages","group_header": v:true,}
                            
                                  let prefix     = self.CreateItem("link", ">", g:AnyJumpGetColor('group_text'), opts)
                                  let group_name = self.CreateItem("link", path, g:AnyJumpGetColor('group_name'), opts)
                                  let line       = [ prefix, group_name ]
                            
                                  call self.AddLineAt(line, start_ln)
                                  let start_ln += 1
                            
                                  for gr in render_map[path]
                                    let items = self.GrepResultToGroupedItems(gr, idx, "usages")
                                    call self.AddLineAt(items, start_ln)
                            
                                    let start_ln += 1
                                    let idx += 1
                                  endfor
                            
                                  if path_idx != len(keys(render_map)) - 1
                                    call self.AddLineAt([ self.CreateItem("text", "", "Comment", {"layer": "usages"}) ], start_ln)
                            
                                    let start_ln += 1
                                  endif
                            
                                  let path_idx += 1
                                endfor
    3              0.000001   else
   33              0.000014     for gr in collection
   30   0.002009   0.000086       let items = self.GrepResultToItems(gr, idx, "usages")
   30   0.002095   0.000061       call self.AddLineAt(items, start_ln)
                            
   30              0.000020       let idx += 1
   30              0.000022       let start_ln += 1
   33              0.000010     endfor
    3              0.000001   endif
                            
    3              0.000002   if hidden_count > 0
    3   0.000217   0.000015     call self.AddLineAt([ self.CreateItem("text", "", "Comment", {"layer": "usages"}) ], start_ln)
    3              0.000003     let start_ln += 1
                            
    3   0.000324   0.000042     call self.AddLineAt([self.CreateItem("more_button", '[ ' . hidden_count . ' more ]', g:AnyJumpGetColor('more_button'), {"layer": "usages"}),self.CreateItem("more_button", '— [a] load more results [A] load all', g:AnyJumpGetColor('more_explain'), {"layer": "usages"}),], start_ln)
    3              0.000002     let start_ln += 1
    3              0.000001   endif
                            
    3   0.000195   0.000014   call self.AddLineAt([ self.CreateItem("text", " ", "Comment", {"layer": "usages"}) ], start_ln)
                            
    3              0.000002   return v:true

FUNCTION  <lambda>1092()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/pipe/branch.vim:5
Called 1 time
Total time:   0.000918
 Self time:   0.000004

count  total (s)   self (s)
                            return s:branch(a:args, ctx, x)

FUNCTION  <lambda>1094()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/pipeline.vim:105
Called 1 time
Total time:   0.000407
 Self time:   0.000004

count  total (s)   self (s)
                            return s:run(a:pipeline, a:on_finish, a:on_error, ctx, x, a:i)

FUNCTION  wilder#pipeline#wait()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/pipeline.vim:166
Called 8 times
Total time:   0.000039
 Self time:   0.000039

count  total (s)   self (s)
    8              0.000015   let l:state = { 'f': a:f, 'on_finish': a:on_finish, }
                            
    8              0.000019   return {ctx -> s:wait_start(l:state, ctx)}

FUNCTION  <lambda>1098()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/pipe/branch.vim:16
Called 1 time
Total time:   0.000017
 Self time:   0.000003

count  total (s)   self (s)
                            return s:on_finish(l:state, ctx, x)

FUNCTION  <SNR>58_render_lines_from_timer()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer/popupmenu.vim:275
Called 6 times
Total time:   0.072612
 Self time:   0.000184

count  total (s)   self (s)
                              " Multiple renders might be queued, skip if there is a newer render
    6              0.000011   if a:render_id != a:state.render_id || !a:state.active
                                return
    6              0.000002   endif
                            
    6   0.072589   0.000161   call s:render_lines(a:state, a:ctx, a:result)

FUNCTION  <lambda>97()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/pipe/check.vim:1
Called 4 times
Total time:   0.000071
 Self time:   0.000014

count  total (s)   self (s)
                            return s:check(a:args, ctx, x)

FUNCTION  40()
    Defined: ~/.local/share/nvim/lazy/any-jump.vim/autoload/internal_buffer.vim:551
Called 3 times
Total time:   0.014422
 Self time:   0.000653

count  total (s)   self (s)
                              " clear items before render
    3              0.000004   let self.items = []
                            
    3   0.000458   0.000019   call self.AddLine([ self.CreateItem("text", "", "Comment") ])
                            
    3   0.000511   0.000085   call self.AddLine([self.CreateItem("text", ">", g:AnyJumpGetColor('heading_text')),self.CreateItem("text", self.keyword, g:AnyJumpGetColor('heading_keyword')),self.CreateItem("text", len(self.definitions_grep_results) . " definitions", g:AnyJumpGetColor('heading_text')),])
                            
    3   0.000205   0.000012   call self.AddLine([ self.CreateItem("text", "", "Comment") ])
                            
                              " draw grep results
    3              0.000002   let idx          = 0
    3              0.000002   let hidden_count = 0
                            
                              " TODO: move to method
    3              0.000011   if type(g:any_jump_max_search_results) == v:t_number && g:any_jump_max_search_results > 0 && self.overmaxed_results_hidden == v:true
                            
    3              0.000004     let cp = self.current_page ? self.current_page : 1
    3              0.000004     let to = (cp * g:any_jump_max_search_results) - 1
                            
    3              0.000008     let collection   = self.definitions_grep_results[0 : to]
    3              0.000014     let hidden_count = len(self.definitions_grep_results[to : -1])
                              else
                                let collection = self.definitions_grep_results
    3              0.000001   endif
                            
    3              0.000002   if self.grouping_enabled
                                " group by file name rendering
                                let render_map = {}
                            
                                for gr in collection
                                  if !has_key(render_map, gr.path)
                                    let render_map[gr.path] = []
                                  endif
                            
                                  call add(render_map[gr.path], gr)
                                endfor
                            
                                let path_idx = 0
                            
                                for path in keys(render_map)
                                  let first_gr = render_map[path][0]
                                  let opts     = {"path":         path,"line_number":  first_gr.line_number,"layer":        "definitions","group_header": v:true,}
                            
                                  let prefix     = self.CreateItem("link", ">", g:AnyJumpGetColor('group_text'), opts)
                                  let group_name = self.CreateItem("link", path, g:AnyJumpGetColor('group_name'), opts)
                                  let line       = [ prefix, group_name ]
                            
                                  call self.AddLine(line)
                            
                                  for gr in render_map[path]
                                    let items = self.GrepResultToGroupedItems(gr, idx, "definitions")
                                    call self.AddLine(items)
                            
                                    let idx += 1
                                  endfor
                            
                                  if path_idx != len(keys(render_map)) - 1
                                     call self.AddLine([ self.CreateItem("text", "", "Comment") ])
                                  endif
                            
                                  let path_idx += 1
                                endfor
                            
                                call self.AddLine([ self.CreateItem("text", "", "Comment") ])
    3              0.000001   else
    3              0.000003     if len(collection)
   33              0.000015       for gr in collection
   30   0.002096   0.000096         let items = self.GrepResultToItems(gr, idx, "definitions")
   30   0.002368   0.000056         call self.AddLine(items)
                            
   30              0.000021         let idx += 1
   33              0.000010       endfor
                                else
                                  call self.AddLine([ self.CreateItem("text", "No definitions results", g:AnyJumpGetColor('plain_text')) ])
    3              0.000001     endif
                            
    3   0.000195   0.000012     call self.AddLine([ self.CreateItem("text", "", "Comment") ])
    3              0.000001   endif
                            
    3              0.000002   if hidden_count > 0
    3   0.000398   0.000066     call self.AddLine([self.CreateItem("more_button", '[ + ' . hidden_count . ' more ]', g:AnyJumpGetColor('more_button')),self.CreateItem("more_button", '— [a] load more results [A] load all', g:AnyJumpGetColor('more_explain')),])
    3   0.000194   0.000011     call self.AddLine([ self.CreateItem("text", "", "Comment") ])
    3              0.000001   endif
                            
    3              0.000005   if self.usages_opened && len(self.usages_grep_results) > 0
    3   0.005853   0.000016     call self.RenderUiUsagesList(self.usages_grep_results, self.len() + 1)
    3              0.000001   endif
                            
    3   0.001881   0.000017   call self.HelpSection()

FUNCTION  <SNR>52_has_key()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/cache.vim:19
Called 4 times
Total time:   0.000009
 Self time:   0.000009

count  total (s)   self (s)
    4              0.000008   return has_key(self['_cache'], a:key)

FUNCTION  <SNR>54_get_middle_position()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer/popupmenu_palette_theme.vim:460
Called 6 times
Total time:   0.000050
 Self time:   0.000050

count  total (s)   self (s)
                              " Use max_height so the prompt does not move around the screen when height
                              " of the candidates changes
    6              0.000003   if a:is_top
    6              0.000010     let l:row = (&lines - 1 - a:dimensions.max_height) / 2
                              else
                                let l:row = (&lines - 1 - a:dimensions.max_height) / 2 + a:dimensions.max_height - a:dimensions.height
    6              0.000002   endif
                            
    6              0.000007   let l:col = (&columns - a:dimensions.width) / 2
                            
    6              0.000005   return [l:row, l:col]

FUNCTION  wilder#renderer#popupmenu#draw_column()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer/popupmenu.vim:572
Called 36 times
Total time:   0.012967
 Self time:   0.002068

count  total (s)   self (s)
   36              0.000041   let l:Column = a:column
   36              0.000027   let l:height = a:ctx.height
                            
   36              0.000036   if type(l:Column) is v:t_dict
                                let l:Column = l:Column.value
   36              0.000010   endif
                            
   36              0.000033   if type(l:Column) is v:t_func
   12   0.012421   0.001522     let l:Column = l:Column(a:ctx, a:result)
   36              0.000010   endif
                            
   36              0.000034   if type(l:Column) is v:t_string
   18              0.000015     if empty(l:Column)
    6              0.000003       return []
   12              0.000004     endif
                            
   12              0.000029     return repeat([[[l:Column]]], l:height)
   18              0.000004   endif
                            
                              " v:t_list
   18              0.000014   if empty(l:Column)
    2              0.000001     return []
   16              0.000004   endif
                            
   16              0.000022   if empty(l:Column[0])
                                return []
   16              0.000004   endif
                            
                              " highlight chunk
   16              0.000017   if type(l:Column[0]) is v:t_string
   12              0.000022     return repeat([[l:Column]], l:height)
    4              0.000001   endif
                            
                              " list of highlight chunks
    4              0.000005   if type(l:Column[0][0]) is v:t_string
                                return repeat([l:Column], l:height)
    4              0.000001   endif
                            
                              " list of list of highlight chunks
    4              0.000002   return l:Column

FUNCTION  <SNR>10_match()
    Defined: ~/.local/share/nvim/lazy/vim-rooter/plugin/rooter.vim:176
Called 42 times
Total time:   0.000663
 Self time:   0.000385

count  total (s)   self (s)
   42              0.000032   if a:pattern[0] == '='
                                return s:is(a:dir, a:pattern[1:])
   42              0.000030   elseif a:pattern[0] == '^'
                                return s:sub(a:dir, a:pattern[1:])
   42              0.000029   elseif a:pattern[0] == '>'
                                return s:child(a:dir, a:pattern[1:])
   42              0.000011   else
   42   0.000414   0.000136     return s:has(a:dir, a:pattern)
                              endif

FUNCTION  <SNR>109_getcmdline()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/main.vim:634
Called 4 times
Total time:   0.000013
 Self time:   0.000013

count  total (s)   self (s)
    4              0.000006   if s:opts.use_cmdlinechanged || !s:opts.before_cursor
    4              0.000004     return getcmdline()
                              endif
                            
                              if a:0
                                let l:cmdline = a:1
                                let l:cmdpos = a:2
                              else
                                let l:cmdline = getcmdline()
                                let l:cmdpos = getcmdpos()
                              endif
                            
                              if l:cmdpos <= 1
                                return ''
                              else
                                return l:cmdline[: l:cmdpos - 2]
                              endif

FUNCTION  copilot#Client()
    Defined: ~/.local/share/nvim/lazy/copilot.vim/autoload/copilot.vim:59
Called 15 times
Total time:   0.000268
 Self time:   0.000130

count  total (s)   self (s)
   15   0.000250   0.000112   call s:Start()
   15              0.000010   return s:client

FUNCTION  wilder#cmdline#main#is_whitespace()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/cmdline/main.vim:678
Called 2 times
Total time:   0.000009
 Self time:   0.000009

count  total (s)   self (s)
    2              0.000004   let l:nr = char2nr(a:char)
    2              0.000004   return a:char ==# ' ' || l:nr >= 9 && l:nr <= 13

FUNCTION  <SNR>61_add_highlight()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer/nvim_api.vim:251
Called 110 times
Total time:   0.000404
 Self time:   0.000404

count  total (s)   self (s)
  110              0.000383   call nvim_buf_add_highlight(self.state.buf, self.state.ns_id, a:hl, a:line, a:col_start, a:col_end)

FUNCTION  wilder#render#draw_candidate()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/render.vim:10
Called 110 times
Total time:   0.002626
 Self time:   0.001876

count  total (s)   self (s)
  110   0.000618   0.000475   let l:x = wilder#main#get_candidate(a:ctx, a:result, a:i)
                            
  110              0.000102   if has_key(a:result, 'draw')
                                let l:ctx = { 'i': a:i, 'selected': a:ctx.selected == a:i, }
                            
                                for l:F in a:result.draw
                                  if type(l:F) isnot v:t_func
                                    let l:F = function(l:F)
                                  endif
                            
                                  let l:x = l:F(l:ctx, l:x, get(a:result, 'data', {}))
                                endfor
  110              0.000026   endif
                            
  110   0.001137   0.000530   return wilder#render#to_printable(l:x)

FUNCTION  <SNR>104_NvimIsAttached()
    Defined: ~/.local/share/nvim/lazy/copilot.vim/autoload/copilot/client.vim:446
Called 6 times
Total time:   0.000271
 Self time:   0.000271

count  total (s)   self (s)
    6              0.000267   return bufloaded(a:bufnr) ? luaeval('vim.lsp.buf_is_attached(_A[1], _A[2])', [a:bufnr, self.id]) : v:false

FUNCTION  <SNR>67_resolve()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/pipe/branch.vim:48
Called 12 times
Total time:   0.000117
 Self time:   0.000081

count  total (s)   self (s)
   12              0.000020   let l:ctx = copy(a:ctx)
   12              0.000015   let l:ctx.handler_id = a:state.original_ctx.handler_id
                            
   12   0.000074   0.000038   call wilder#resolve(l:ctx, a:x)

FUNCTION  wilder#lua#call_wrapped_function()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/lua.vim:44
Called 116 times
Total time:   0.057243
 Self time:   0.001564

count  total (s)   self (s)
  116              0.000235   let l:F = s:functions[a:index]
  116   0.013633   0.006459   let l:Result = call(l:F, a:000)
  116   0.031149   0.000422   return wilder#lua#wrap(l:Result)

FUNCTION  <SNR>54_prompt_post_hook()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer/popupmenu_palette_theme.vim:419
Called 2 times
Total time:   0.000015
 Self time:   0.000015

count  total (s)   self (s)
    2              0.000012   call timer_stop(a:state.timer)

FUNCTION  <SNR>47_wrap_function()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/lua.vim:32
Called 8 times
Total time:   0.000061
 Self time:   0.000061

count  total (s)   self (s)
    8              0.000007   let l:index = s:index
    8              0.000007   let s:index += 1
                            
    8              0.000013   let s:functions[l:index] = a:f
    8              0.000026   return { 'index': l:index, 'name': get(a:f, 'name'), '__wilder_wrapped__': s:token, }

FUNCTION  <SNR>52_clear()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/cache.vim:23
Called 8 times
Total time:   0.000013
 Self time:   0.000013

count  total (s)   self (s)
    8              0.000012   let self['_cache'] = {}

FUNCTION  <SNR>61_need_timer()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer/nvim_api.vim:263
Called 6 times
Total time:   0.000022
 Self time:   0.000022

count  total (s)   self (s)
    6              0.000014   if has('nvim-0.7')
                                " See https://github.com/neovim/neovim/issues/17810.
                                " Avoid calling nvim_buf_set_lines(), so assume timer is always needed.
    6              0.000003     return 1
                              endif
                            
                              try
                                call nvim_buf_set_lines(self.state.dummy_buf, 0, -1, v:true, [])
                              catch
                                return 1
                              endtry
                            
                              return 0

FUNCTION  lang_map#lang_exists()
    Defined: ~/.local/share/nvim/lazy/any-jump.vim/autoload/lang_map.vim:32
Called 6 times
Total time:   0.000015
 Self time:   0.000015

count  total (s)   self (s)
    6              0.000013   return has_key(s:definitions, a:language)

FUNCTION  <SNR>60_to_hl_list()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/highlight.vim:45
Called 8 times
Total time:   0.001637
 Self time:   0.000236

count  total (s)   self (s)
    8              0.000010   if type(a:x) is v:t_string
    4   0.000128   0.000017     let l:x = wilder#highlight#get_hl(a:x)
    4              0.000002   else
    4              0.000003     let l:x = a:x
    8              0.000002   endif
                            
    8              0.000018   if type(l:x) is v:t_list && type(l:x[0]) is v:t_list
                                return l:x
    8              0.000002   endif
                            
    8   0.000468   0.000038   let l:term_hl = s:get_attrs_as_list(l:x[0])
                            
    8   0.000495   0.000055   let l:cterm_hl = [ get(l:x[1], 'foreground', 'NONE'), get(l:x[1], 'background', 'NONE') ] + s:get_attrs_as_list(l:x[1])
                            
    8   0.000472   0.000051   let l:gui_hl = [ get(l:x[2], 'foreground', 'NONE'), get(l:x[2], 'background', 'NONE') ] + s:get_attrs_as_list(l:x[2])
                            
    8              0.000009   return [l:term_hl, l:cterm_hl, l:gui_hl]

FUNCTION  <SNR>116_FilterGrepResults()
    Defined: ~/.local/share/nvim/lazy/any-jump.vim/autoload/search.vim:393
Called 6 times
Total time:   0.000929
 Self time:   0.000929

count  total (s)   self (s)
    6              0.000011   if type(a:language) != v:t_string
                                return a:grep_results
    6              0.000002   endif
                            
    6              0.000023   if g:any_jump_remove_comments_from_results && has_key(s:filetypes_comments_map_compiled, a:language)
                            
    6              0.000021     let filtered = copy(a:grep_results)
                            
   12              0.000017     for comment_pattern in s:filetypes_comments_map_compiled[a:language]
    6              0.000778       call filter(filtered, 'v:val.text !~# comment_pattern')
   12              0.000046     endfor
                            
    6              0.000005     return filtered
                              else
                                return a:grep_results
                              endif

FUNCTION  <SNR>10_parent()
    Defined: ~/.local/share/nvim/lazy/vim-rooter/plugin/rooter.vim:255
Called 21 times
Total time:   0.000033
 Self time:   0.000033

count  total (s)   self (s)
   21              0.000028   return fnamemodify(a:dir, ':h')

FUNCTION  <SNR>104_NvimAttach()
    Defined: ~/.local/share/nvim/lazy/copilot.vim/autoload/copilot/client.vim:438
Called 6 times
Total time:   0.023290
 Self time:   0.002215

count  total (s)   self (s)
    6              0.000007   if !bufloaded(a:bufnr)
                                return {'uri': '', 'version': 0}
    6              0.000002   endif
    6   0.023095   0.002019   call luaeval('pcall(vim.lsp.buf_attach_client, _A[1], _A[2])', [a:bufnr, self.id])
    6              0.000170   return luaeval('{uri = vim.uri_from_bufnr(_A), version = vim.lsp.util.buf_versions[_A]}', a:bufnr)

FUNCTION  <SNR>104_NvimDoNotify()
    Defined: ~/.local/share/nvim/lazy/copilot.vim/autoload/copilot/client.vim:486
Called 3 times
Total time:   0.000400
 Self time:   0.000400

count  total (s)   self (s)
    3              0.000399   return eval("v:lua.require'_copilot'.rpc_notify(a:client_id, a:method, a:params)")

FUNCTION  <SNR>61_hide()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer/nvim_api.vim:165
Called 2 times
Total time:   0.000254
 Self time:   0.000254

count  total (s)   self (s)
    2              0.000009   if self.state.win == -1 || self.state.window_state ==# 'hidden'
                                return
    2              0.000001   endif
                            
    2              0.000003   if self.state.window_state ==# 'pending'
                                let self.state.win = -1
                                let self.state.window_state = 'hidden'
                                return
    2              0.000001   endif
                            
    2              0.000006   if getcmdwintype() ==# ''
    2              0.000003     try
    2              0.000120       call nvim_win_close(self.state.win, 1)
                                catch
                                  let l:win = self.state.win
                                  call timer_start(0, {-> nvim_win_close(l:win, 1)})
    2              0.000005     endtry
                              else
                                " cannot call nvim_win_close() while cmdline-window is open
                                " make the window as small as possible and hide it with winblend = 100
                                let l:win = self.state.win
                                call self.delete_all_lines()
                                call self.move(&lines, &columns, 1, 1)
                                call self.set_option('winblend', 100)
                                execute 'autocmd CmdWinLeave * ++once call timer_start(0, {-> nvim_win_close(' . l:win . ', 0)})'
    2              0.000001   endif
                            
    2              0.000005   let self.state.win = -1
    2              0.000004   let self.state.window_state = 'hidden'

FUNCTION  <SNR>61_new_buf()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer/nvim_api.vim:59
Called 2 times
Total time:   0.000653
 Self time:   0.000447

count  total (s)   self (s)
    2              0.000093   let l:buf = nvim_create_buf(v:false, v:true)
    2   0.000553   0.000347   call nvim_buf_set_name(l:buf, '[Wilder Float ' . s:index . ']')
    2              0.000004   let s:index += 1
                            
    2              0.000001   return l:buf

FUNCTION  <SNR>76_Highlight_Matching_Pair()
    Defined: /opt/homebrew/Cellar/neovim/0.10.1/share/nvim/runtime/plugin/matchparen.vim:44
Called 210 times
Total time:   0.051764
 Self time:   0.046426

count  total (s)   self (s)
  210              0.002137   if !exists("w:matchparen_ids")
    4              0.000005     let w:matchparen_ids = []
  210              0.000338   endif
                              " Remove any previous match.
  210   0.007941   0.002603   call s:Remove_Matches()
                            
                              " Avoid that we remove the popup menu.
                              " Return when there are no colors (looks like the cursor jumps).
  210              0.001147   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
                                return
  210              0.000098   endif
                            
                              " Get the character under the cursor and check if it's in 'matchpairs'.
  210              0.000597   let c_lnum = line('.')
  210              0.000415   let c_col = col('.')
  210              0.000214   let before = 0
                            
  210              0.000674   let text = getline(c_lnum)
  210              0.004251   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
  210              0.000422   if empty(matches)
                                let [c_before, c] = ['', '']
  210              0.000166   else
  210              0.001007     let [c_before, c] = matches[1:2]
  210              0.000103   endif
  210              0.003204   let plist = split(&matchpairs, '.\zs[:,]')
  210              0.000697   let i = index(plist, c)
  210              0.000199   if i < 0
                                " not found, in Insert mode try character before the cursor
   84              0.000358     if c_col > 1 && (mode() == 'i' || mode() == 'R')
                                  let before = strlen(c_before)
                                  let c = c_before
                                  let i = index(plist, c)
   84              0.000045     endif
   84              0.000074     if i < 0
                                  " not found, nothing to do
   84              0.000150       return
                                endif
  126              0.000078   endif
                            
                              " Figure out the arguments for searchpairpos().
  126              0.000136   if i % 2 == 0
  126              0.000153     let s_flags = 'nW'
  126              0.000265     let c2 = plist[i + 1]
                              else
                                let s_flags = 'nbW'
                                let c2 = c
                                let c = plist[i - 1]
  126              0.000047   endif
  126              0.000190   if c == '['
    4              0.000010     let c = '\['
    4              0.000004     let c2 = '\]'
  126              0.000044   endif
                            
                              " Find the match.  When it was just before the cursor move it there for a
                              " moment.
  126              0.000110   if before > 0
                                let has_getcurpos = exists("*getcurpos")
                                if has_getcurpos
                                  " getcurpos() is more efficient but doesn't exist before 7.4.313.
                                  let save_cursor = getcurpos()
                                else
                                  let save_cursor = winsaveview()
                                endif
                                call cursor(c_lnum, c_col - before)
  126              0.000056   endif
                            
  126              0.000748   if !has("syntax") || !exists("g:syntax_on")
                                let s_skip = "0"
  126              0.000054   else
                                " Build an expression that detects whether the current cursor position is
                                " in certain syntax types (string, comment, etc.), for use as
                                " searchpairpos()'s skip argument.
                                " We match "escape" for special items, such as lispEscapeSpecial, and
                                " match "symbol" for lispBarSymbol.
  126              0.000546     let s_skip = 'synstack(".", col("."))' . '->indexof({_, id -> synIDattr(id, "name") =~? ' . '"string\\|character\\|singlequote\\|escape\\|symbol\\|comment"}) >= 0'
                                " If executing the expression determines that the cursor is currently in
                                " one of the syntax types, then we want searchpairpos() to find the pair
                                " within those syntax types (i.e., not skip).  Otherwise, the cursor is
                                " outside of the syntax types and s_skip should keep its value so we skip
                                " any matching pair inside the syntax types.
                                " Catch if this throws E363: pattern uses more memory than 'maxmempattern'.
  126              0.000129     try
  126              0.002254       execute 'if ' . s_skip . ' | let s_skip = "0" | endif'
                                catch /^Vim\%((\a\+)\)\=:E363/
                                  " We won't find anything, so skip searching, should keep Vim responsive.
                                  return
  126              0.000150     endtry
  126              0.000053   endif
                            
                              " Limit the search to lines visible in the window.
  126              0.000328   let stoplinebottom = line('w$')
  126              0.000223   let stoplinetop = line('w0')
  126              0.000114   if i % 2 == 0
  126              0.000260     let stopline = stoplinebottom
                              else
                                let stopline = stoplinetop
  126              0.000046   endif
                            
                              " Limit the search time to 300 msec to avoid a hang on very long lines.
                              " This fails when a timeout is not supported.
  126              0.000287   if mode() == 'i' || mode() == 'R'
                                let timeout = exists("b:matchparen_insert_timeout") ? b:matchparen_insert_timeout : g:matchparen_insert_timeout
  126              0.000052   else
  126              0.000452     let timeout = exists("b:matchparen_timeout") ? b:matchparen_timeout : g:matchparen_timeout
  126              0.000050   endif
  126              0.000066   try
  126              0.004028     let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline, timeout)
                              catch /E118/
                                " Can't use the timeout, restrict the stopline a bit more to avoid taking
                                " a long time on closed folds and long lines.
                                " The "viewable" variables give a range in which we can scroll while
                                " keeping the cursor at the same position.
                                " adjustedScrolloff accounts for very large numbers of scrolloff.
                                let adjustedScrolloff = min([&scrolloff, (line('w$') - line('w0')) / 2])
                                let bottom_viewable = min([line('$'), c_lnum + &lines - adjustedScrolloff - 2])
                                let top_viewable = max([1, c_lnum-&lines+adjustedScrolloff + 2])
                                " one of these stoplines will be adjusted below, but the current values are
                                " minimal boundaries within the current window
                                if i % 2 == 0
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = min([line2byte("$"), line2byte(".") + col(".") + &smc * 2])
                            	let stopline = min([bottom_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = min([bottom_viewable, c_lnum + 100])
                                  endif
                                  let stoplinebottom = stopline
                                else
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = max([1, line2byte(".") + col(".") - &smc * 2])
                            	let stopline = max([top_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = max([top_viewable, c_lnum - 100])
                                  endif
                                  let stoplinetop = stopline
                                endif
                                let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline)
  126              0.000082   endtry
                            
  126              0.000110   if before > 0
                                if has_getcurpos
                                  call setpos('.', save_cursor)
                                else
                                  call winrestview(save_cursor)
                                endif
  126              0.000045   endif
                            
                              " If a match is found setup match highlighting.
  126              0.000289   if m_lnum > 0 && m_lnum >= stoplinetop && m_lnum <= stoplinebottom 
  126              0.000137     if s:has_matchaddpos
  126              0.001100       call add(w:matchparen_ids, matchaddpos('MatchParen', [[c_lnum, c_col - before], [m_lnum, m_col]], 10))
                                else
                                  exe '3match MatchParen /\(\%' . c_lnum . 'l\%' . (c_col - before) . 'c\)\|\(\%' . m_lnum . 'l\%' . m_col . 'c\)/'
                                  call add(w:matchparen_ids, 3)
  126              0.000052     endif
  126              0.000164     let w:paren_hl_on = 1
  126              0.000063   endif

FUNCTION  <SNR>36_Event()
    Defined: ~/.local/share/nvim/lazy/copilot.vim/plugin/copilot.vim:45
Called 34 times
Total time:   0.000876
 Self time:   0.000371

count  total (s)   self (s)
   34              0.000029   try
   34   0.000723   0.000218     call call('copilot#On' . a:type, [])
                              catch
                                call copilot#logger#Exception('autocmd.' . a:type)
   34              0.000025   endtry

FUNCTION  <SNR>10_root()
    Defined: ~/.local/share/nvim/lazy/vim-rooter/plugin/rooter.vim:128
Called 3 times
Total time:   0.001494
 Self time:   0.000690

count  total (s)   self (s)
    3   0.000121   0.000013   let dir = s:current()
                            
    3              0.000011   let patterns = g:rooter_ignore      ? s:remove_ignored(g:rooter_patterns, dir, s:current_file())      : g:rooter_patterns
                            
                              " breadth-first search
   21              0.000008   while 1
   63              0.000036     for pattern in patterns
   42              0.000033       if pattern[0] == '!'
                                    let [p, exclude] = [pattern[1:], 1]
   42              0.000011       else
   42              0.000047         let [p, exclude] = [pattern, 0]
   42              0.000011       endif
   42   0.000785   0.000122       if s:match(dir, p)
                                    if exclude
                                      break
                                    else
                                      return dir
                                    endif
   42              0.000011       endif
   63              0.000018     endfor
                            
   21   0.000112   0.000079     let [current, dir] = [dir, s:parent(dir)]
   39              0.000028     if current == dir | break | endif
   21              0.000039   endwhile
                            
    3              0.000001   return ''

FUNCTION  wilder#renderer#redraw()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer.vim:1
Called 6 times
Total time:   0.013400
 Self time:   0.000047

count  total (s)   self (s)
    6   0.013399   0.000046   call s:redraw(a:apply_incsearch_fix, 0)

FUNCTION  <SNR>116_RunRgUsagesSearch()
    Defined: ~/.local/share/nvim/lazy/any-jump.vim/autoload/search.vim:353
Called 3 times
Total time:   0.043367
 Self time:   0.000650

count  total (s)   self (s)
    3              0.000003   let kw = a:keyword
    3              0.000009   let kw = substitute(kw, "\-", "\\\\-", "g") " shell escape
                            
    3              0.000012   let cmd = s:rg_base_cmd . ' -w ' . string(kw)
    3   0.000088   0.000032   let cmd = cmd . s:GetRgIgnoreSpecifier()
                            
    3              0.000009   if g:any_jump_references_only_for_current_filetype && type(a:language) == v:t_string
                            
                                let rg_ft = s:GetRgFiletype(a:language)
                                let cmd   = cmd . ' -t ' . rg_ft
    3              0.000001   endif
                            
    3   0.033013   0.000037   let raw_results  = system(cmd)
    3   0.009606   0.000468   let grep_results = s:ParseRgResults(raw_results)
    3   0.000604   0.000058   let grep_results = s:FilterGrepResults(a:language, grep_results)
                            
    3              0.000002   return grep_results

FUNCTION  wilder#main#stop()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/main.vim:172
Called 13 times
Total time:   0.001527
 Self time:   0.000382

count  total (s)   self (s)
   13              0.000082   let s:select_next = 0
                            
   13              0.000018   if !s:active
   11              0.000006     return
    2              0.000002   endif
                            
    2              0.000014   if exists('#WilderCmdlineChanged')
    2              0.000005     augroup WilderCmdlineChanged
    2              0.000035       autocmd!
    2              0.000002     augroup END
    2              0.000012     augroup! WilderCmdlineChanged
    2              0.000001   endif
                            
    2              0.000007   if s:timer isnot v:null
                                call timer_stop(s:timer)
                                let s:timer = v:null
    2              0.000001   endif
                            
    2              0.000005   if exists('#WilderCmdlineLeave')
    2              0.000002     augroup WilderCmdlineLeave
    2              0.000016       autocmd!
    2              0.000001     augroup END
    2              0.000009     augroup! WilderCmdlineLeave
    2              0.000001   endif
                            
    2              0.000003   if exists('#WilderVimResized')
    2              0.000001     augroup WilderVimResized
    2              0.000014       autocmd!
    2              0.000001     augroup END
    2              0.000008     augroup! WilderVimResized
    2              0.000001   endif
                            
    2              0.000004   let s:active = 0
    2              0.000017   let s:result = {'value': [], 'data': {}}
    2              0.000003   let s:selected = -1
    2              0.000004   let s:selection_was_made = 0
    2              0.000003   let s:clear_previous_renderer_state = 0
    2              0.000004   let s:completion_stack = []
    2              0.000004   let s:previous_cmdline = v:null
    2              0.000003   let s:completion = v:null
    2              0.000003   let s:error = v:null
    2              0.000003   let s:replaced_cmdline = v:null
    2              0.000004   let s:completion_from_reject_completion = v:null
                            
    2              0.000002   if !s:hidden
    2   0.001169   0.000024     call s:post_hook()
    2              0.000001   endif
                            
    2              0.000002   let s:hidden = 0

FUNCTION  wilder#main#in_mode()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/main.vim:53
Called 26 times
Total time:   0.000446
 Self time:   0.000446

count  total (s)   self (s)
   26              0.000393   return mode(1) ==# 'c' && index(s:opts.modes, getcmdtype()) >= 0

FUNCTION  <SNR>10_rootless()
    Defined: ~/.local/share/nvim/lazy/vim-rooter/plugin/rooter.vim:271
Called 3 times
Total time:   0.000025
 Self time:   0.000025

count  total (s)   self (s)
    3              0.000003   let dir = ''
    3              0.000005   if g:rooter_change_directory_for_non_project_files ==? 'current'
                                let dir = s:current()
    3              0.000003   elseif g:rooter_change_directory_for_non_project_files ==? 'home'
                                let dir = $HOME
    3              0.000001   endif
    3              0.000006   if !empty(dir) | call s:cd(dir) | endif

FUNCTION  <SNR>58_draw_candidates_chunks()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer/popupmenu.vim:615
Called 110 times
Total time:   0.005136
 Self time:   0.001115

count  total (s)   self (s)
  110              0.000112   let l:is_selected = a:ctx.selected == a:i
                            
  110   0.004649   0.000629   let l:str = s:draw_candidate(a:state, a:ctx, a:result, a:i)
                            
  110              0.000107   let l:Highlighter = a:state.highlighter
                            
  110              0.000068   if l:Highlighter is 0
  110              0.000086     return [[l:str]]
                              endif
                            
                              if !l:is_selected && a:state.highlight_cache.has_key(l:str)
                                return copy(a:state.highlight_cache.get(l:str))
                              endif
                            
                              let l:data = get(a:result, 'data', {})
                              let l:spans = l:Highlighter(a:ctx, l:str, l:data)
                            
                              if l:spans is 0
                                return [[l:str]]
                              endif
                            
                              if a:state.highlight_mode ==# 'basic'
                                let l:spans = s:merge_spans(l:spans)
                              endif
                            
                              let l:chunks = wilder#render#spans_to_chunks( l:str, l:spans, l:is_selected, a:ctx.highlights)
                            
                              if !l:is_selected
                                call a:state.highlight_cache.set(l:str, l:chunks)
                                let l:chunks = copy(l:chunks)
                              endif
                            
                              return l:chunks

FUNCTION  wilder#pipeline#run()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/pipeline.vim:87
Called 28 times
Total time:   0.013322
 Self time:   0.000134

count  total (s)   self (s)
   28              0.000065   let l:pipeline = type(a:pipeline) isnot v:t_list ? [a:pipeline] : a:pipeline
                            
   28   0.009290   0.000819   return s:run(l:pipeline, a:on_finish, a:on_error, a:ctx, a:x, 0)

FUNCTION  wilder#renderer#call_component_post_hook()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer.vim:81
Called 24 times
Total time:   0.000244
 Self time:   0.000154

count  total (s)   self (s)
   24              0.000073   if type(a:component) is v:t_dict && has_key(a:component, 'post_hook')
    2   0.000118   0.000028     call a:component['post_hook'](a:ctx)
   24              0.000011   endif

FUNCTION  <SNR>61_set_line()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer/nvim_api.vim:247
Called 134 times
Total time:   0.001376
 Self time:   0.001376

count  total (s)   self (s)
  134              0.001350   call nvim_buf_set_lines(self.state.buf, a:line, a:line, v:true, [a:str])

FUNCTION  <SNR>61_move()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer/nvim_api.vim:198
Called 6 times
Total time:   0.000092
 Self time:   0.000092

count  total (s)   self (s)
    6              0.000011   if self.state.window_state ==# 'hidden'
                                return
    6              0.000002   endif
                            
    6              0.000005   if self.state.window_state ==# 'pending'
                                let self.state.dimensions = [a:row, a:col, a:height, a:width]
                                return
    6              0.000001   endif
                            
    6              0.000049   call nvim_win_set_config(self.state.win, { 'relative': 'editor', 'row': a:row, 'col': a:col, 'height': a:height, 'width': a:width, })

FUNCTION  copilot#util#Defer()
    Defined: ~/.local/share/nvim/lazy/copilot.vim/autoload/copilot/util.vim:7
Called 12 times
Total time:   0.000097
 Self time:   0.000097

count  total (s)   self (s)
   12              0.000044   call add(s:deferred, function(a:fn, a:000))
   12              0.000047   return timer_start(0, function('s:RunDeferred'))

FUNCTION  <SNR>54_prompt()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer/popupmenu_palette_theme.vim:165
Called 6 times
Total time:   0.001042
 Self time:   0.000926

count  total (s)   self (s)
    6              0.000009   let l:cmdline = getcmdline()
    6              0.000007   let a:state.cmdpos = getcmdpos()
    6   0.000149   0.000033   let l:cmdline_data = s:get_cmdline_data(a:state, l:cmdline)
    6              0.000005   let l:hl = a:state.hl
                            
                              " cmdpos includes the prompt character
    6              0.000007   let l:cursor_pos = a:state.cmdpos - 1
                              " -1 as the prompt char is always drawn
    6              0.000007   let l:max_displaywidth = a:ctx.width - 1
    6              0.000005   let l:displaywidth = 0
    6              0.000008   let l:previous_start = len(l:cmdline)
    6              0.000004   let l:previous_end = 0
                            
                              " cursor is at end of cmdline
    6              0.000007   if l:cursor_pos >= len(l:cmdline)
                                " -1 for the cursor
    6              0.000006     let l:max_displaywidth -= 1
    6              0.000004     let l:displaywidth = 0
    6              0.000005     let l:prompt_str = ''
                            
                                " draw entire cmdline starting from the back
    6              0.000008     let l:i = len(l:cmdline_data) - 1
   10              0.000007     while l:i >= 0
                                  " [char, byte_len, strdisplaywidth, byte_pos, displaywidth_pos]
    4              0.000005       let l:data = l:cmdline_data[l:i]
                            
    4              0.000006       if l:displaywidth + l:data[2] > l:max_displaywidth
                                    break
    4              0.000001       endif
                            
    4              0.000005       let l:displaywidth += l:data[2]
    4              0.000006       let l:prompt_str = l:data[0] . l:prompt_str
    4              0.000005       let l:previous_start = l:data[3]
                            
    4              0.000003       let l:i -= 1
   10              0.000020     endwhile
                            
    6              0.000007     let l:previous_end = len(l:cmdline)
    6              0.000011     let l:chunks = [[l:prompt_str, l:hl], [' ', a:state.cursor_hl]]
                              else
                                let l:chunks = v:null
                            
                                " check if the cursor fits within previous_start and previous_end
                                " if it does, draw the prompt with the same bounds
                                if strdisplaywidth(l:cmdline) <= l:max_displaywidth || (l:cursor_pos >= a:state.previous_start && l:cursor_pos < a:state.previous_end)
                                  let l:start_seen = 0
                                  let l:cursor_char = ''
                                  let l:before_cursor_str = ''
                                  let l:after_cursor_str = ''
                            
                                  let l:i = 0
                                  while l:i < len(l:cmdline_data)
                                    " [char, byte_len, strdisplaywidth, byte_pos, displaywidth_pos]
                                    let l:data = l:cmdline_data[l:i]
                            
                                    if l:data[3] < a:state.previous_start
                                      let l:i += 1
                                      continue
                                    endif
                            
                                    if !l:start_seen
                                      let l:start_seen = 1
                                      let l:previous_start = l:data[3]
                                    endif
                            
                                    if l:data[3] > a:state.previous_end
                                      break
                                    endif
                            
                                    if l:displaywidth + l:data[2] > l:max_displaywidth
                                      break
                                    endif
                            
                                    let l:displaywidth += l:data[2]
                            
                                    if l:data[3] == l:cursor_pos
                                      let l:cursor_char = l:data[0]
                                    elseif l:data[3] < l:cursor_pos
                                      let l:before_cursor_str .= l:data[0]
                                    else
                                      let l:after_cursor_str .= l:data[0]
                                    endif
                            
                                    let l:previous_end = l:data[1] + l:data[3]
                            
                                    let l:i += 1
                                  endwhile
                            
                                  " max_displaywidth reached but cursor is not inside bounds
                                  if l:cursor_char !=# ''
                                    let l:chunks = [[l:before_cursor_str, l:hl], [l:cursor_char, a:state.cursor_hl], [l:after_cursor_str, l:hl]]
                                  endif
                                endif
                            
                                " cursor is not within old bounds, draw new bounds with cursor starting
                                " at the front or end depending on which direction it moved
                                if l:chunks is v:null
                                  let l:displaywidth = 0
                            
                                  if l:cursor_pos < a:state.previous_cursor_pos
                                    " cursor at start
                                    let l:cursor_char = ''
                                    let l:prompt_str = ''
                            
                                    let l:i = 0
                                    while l:i < len(l:cmdline_data)
                                      " [char, byte_len, strdisplaywidth, byte_pos, displaywidth_pos]
                                      let l:data = l:cmdline_data[l:i]
                            
                                      if l:data[3] < l:cursor_pos
                                        let l:i += 1
                                        continue
                                      endif
                            
                                      if l:displaywidth + l:data[2] > l:max_displaywidth
                                        break
                                      endif
                            
                                      let l:displaywidth += l:data[2]
                            
                                      if l:data[3] == l:cursor_pos
                                        let l:previous_start = l:data[3]
                                        let l:cursor_char = l:data[0]
                                      else
                                        let l:prompt_str .= l:data[0]
                                      endif
                            
                                      let l:previous_end = l:data[3] + l:data[1]
                            
                                      let l:i += 1
                                    endwhile
                            
                                    let l:chunks = [[l:cursor_char, a:state.cursor_hl], [l:prompt_str, l:hl]]
                                  else
                                    " cursor at end
                                    let l:cursor_char = ''
                                    let l:prompt_str = ''
                            
                                    let l:i = len(l:cmdline_data) - 1
                                    while l:i >= 0
                                      " [char, byte_len, strdisplaywidth, byte_pos, displaywidth_pos]
                                      let l:data = l:cmdline_data[l:i]
                            
                                      if l:data[3] > l:cursor_pos
                                        let l:i -= 1
                                        continue
                                      endif
                            
                                      if l:displaywidth + l:data[2] > l:max_displaywidth
                                        break
                                      endif
                            
                                      let l:displaywidth += l:data[2]
                            
                                      if l:data[3] == l:cursor_pos
                                        let l:previous_end = l:data[3]
                                        let l:cursor_char = l:data[0]
                                      else
                                        let l:prompt_str = l:data[0] . l:prompt_str
                                      endif
                            
                                      let l:previous_start = l:data[3] + l:data[1]
                            
                                      let l:i -= 1
                                    endwhile
                            
                                    let l:chunks = [[l:prompt_str, l:hl], [l:cursor_char, a:state.cursor_hl]]
                                  endif
                                endif
    6              0.000002   endif
                            
                              " if there is space leftover, add characters depending on the direction
                              " which the cursor moved
    6              0.000006   if l:displaywidth < l:max_displaywidth
    6              0.000004     let l:str = ''
                            
                                " cursor moved left, add characters to the end
    6              0.000007     if l:cursor_pos < a:state.previous_cursor_pos
    1              0.000001       let l:i = 0
    1              0.000001       while l:i < len(l:cmdline_data)
                                    " [char, byte_len, strdisplaywidth, byte_pos, displaywidth_pos]
                                    let l:data = l:cmdline_data[l:i]
                            
                                    if l:data[3] < l:previous_end
                                      let l:i += 1
                                      continue
                                    endif
                            
                                    if l:displaywidth + l:data[2] > l:max_displaywidth
                                      break
                                    endif
                            
                                    let l:displaywidth += l:data[2]
                                    let l:str .= l:data[0]
                                    let l:previous_end = l:data[1] + l:data[3]
                            
                                    let l:i += 1
    1              0.000001       endwhile
                            
    1              0.000002       call add(l:chunks, [l:str, l:hl])
    5              0.000003     else
                                  " cursor moved right, add characters to the start
    5              0.000006       let l:i = len(l:cmdline_data) - 1
    9              0.000006       while l:i >= 0
                                    " [char, byte_len, strdisplaywidth, byte_pos, displaywidth_pos]
    4              0.000004         let l:data = l:cmdline_data[l:i]
                            
    4              0.000004         if l:data[3] >= l:previous_start
    4              0.000003           let l:i -= 1
    4              0.000002           continue
                                    endif
                            
                                    if l:displaywidth + l:data[2] > l:max_displaywidth
                                      break
                                    endif
                            
                                    let l:displaywidth += l:data[2]
                                    let l:str = l:data[0] . l:str
                                    let l:previous_start = l:data[3]
                            
                                    let l:i -= 1
    5              0.000004       endwhile
                            
    5              0.000011       call insert(l:chunks, [l:str, l:hl], 0)
    6              0.000002     endif
    6              0.000002   endif
                            
                              " add padding for the rest of the leftover space
    6              0.000005   if l:displaywidth < l:max_displaywidth
    6              0.000017     call add(l:chunks, [repeat(' ', l:max_displaywidth - l:displaywidth), l:hl])
    6              0.000002   endif
                            
    6              0.000011   call insert(l:chunks, [getcmdtype(), l:hl], 0)
                            
    6              0.000007   let a:state.previous_start = l:previous_start
    6              0.000006   let a:state.previous_end = l:previous_end
    6              0.000006   let a:state.previous_cursor_pos = l:cursor_pos
                            
    6              0.000004   return l:chunks

FUNCTION  <lambda>82()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer/popupmenu.vim:113
Called 2 times
Total time:   0.000971
 Self time:   0.000039

count  total (s)   self (s)
                            return s:post_hook(l:state, ctx)

FUNCTION  wilder#highlight#get_hl_nvim()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/highlight.vim:237
Called 4 times
Total time:   0.000045
 Self time:   0.000045

count  total (s)   self (s)
    4              0.000002   try
    4              0.000016     let l:cterm_hl = nvim_get_hl_by_name(a:group, 0)
    4              0.000008     let l:gui_hl = nvim_get_hl_by_name(a:group, 1)
                            
    4              0.000007     return [{}, l:cterm_hl, l:gui_hl]
                              catch
                                return [{}, {}, {}]
    4              0.000002   endtry

FUNCTION  23()
    Defined: ~/.local/share/nvim/lazy/any-jump.vim/autoload/internal_buffer.vim:140
Called 45 times
Total time:   0.003033
 Self time:   0.000263

count  total (s)   self (s)
   45              0.000042   if type(a:items) == v:t_list
   45   0.002871   0.000101     call self.RenderLine(a:items, a:line_number)
   45              0.000069     call insert(self.items, a:items, a:line_number - 1)
                            
   45              0.000024     return v:true
                              else
                                echoe "array required, got invalid type: " . string(a:items)
                            
                                return v:false
                              endif

FUNCTION  wilder#pipeline#resolve()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/pipeline.vim:12
Called 20 times
Total time:   0.023627
 Self time:   0.000100

count  total (s)   self (s)
   20   0.023622   0.000095   call s:handle(a:ctx, a:x, 'resolve')

FUNCTION  <SNR>54_prompt_pre_draw()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer/popupmenu_palette_theme.vim:160
Called 6 times
Total time:   0.000018
 Self time:   0.000018

count  total (s)   self (s)
    6              0.000016   return a:state.cached_cmdline !=# getcmdline() || a:state.cmdpos != getcmdpos()

FUNCTION  <SNR>66_result_start()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/pipe/result.vim:6
Called 12 times
Total time:   0.001107
 Self time:   0.000217

count  total (s)   self (s)
   12              0.000009   let l:kvs = []
   28              0.000029   for l:key in keys(a:args)
   16              0.000041     call add(l:kvs, {'key': l:key, 'value': a:args[l:key]})
   28              0.000011   endfor
                            
   12              0.000022   let l:result = type(a:x) isnot v:t_dict ? {'value': a:x} : a:x
                            
   12              0.000010   if empty(l:kvs)
                                return l:result
   12              0.000003   endif
                            
   12   0.000940   0.000049   return s:result(l:kvs, a:ctx, l:result)

FUNCTION  wilder#render#to_printable()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/render.vim:98
Called 110 times
Total time:   0.000607
 Self time:   0.000607

count  total (s)   self (s)
  110              0.000073   if !s:has_strtrans_issue
                                " check if first character is a combining character
  110              0.000207     if strdisplaywidth(' ' . a:x) == strdisplaywidth(a:x)
                                  return strtrans(' ' . a:x)
  110              0.000030     endif
                            
  110              0.000128     return strtrans(a:x)
                              endif
                            
                              let l:transformed = strtrans(a:x)
                              " strtrans is ok
                              if strdisplaywidth(a:x) == strdisplaywidth(l:transformed)
                                " check if first character is a combining character
                                if strdisplaywidth(' ' . a:x) == strdisplaywidth(a:x)
                                  return strtrans(' ' . a:x)
                                endif
                            
                                return strtrans(a:x)
                              endif
                            
                              let l:res = ''
                              let l:first = 1
                            
                              for l:char in split(a:x, '\zs')
                                let l:transformed_char = strtrans(l:char)
                            
                                let l:transformed_width = strdisplaywidth(l:transformed_char)
                                let l:width = strdisplaywidth(l:char)
                            
                                if l:transformed_width == l:width
                                  " strtrans is ok
                                  let l:res .= l:transformed_char
                                elseif l:transformed_width == 0
                                  " strtrans returns empty character, use original char
                                  if l:first && strdisplaywidth(' ' . l:char) == strdisplaywidth(l:char)
                                    " check if first character is combining character
                                    let l:res .= ' ' . l:char
                                  else
                                    let l:res .= l:char
                                  endif
                                else
                                  " fallback to hex representation
                                  let l:res .= '<' . printf('%02x', char2nr(l:char)) . '>'
                                endif
                            
                                let l:first = 0
                              endfor
                            
                              return l:res

FUNCTION  <SNR>10_activate()
    Defined: ~/.local/share/nvim/lazy/vim-rooter/plugin/rooter.vim:102
Called 6 times
Total time:   0.000385
 Self time:   0.000213

count  total (s)   self (s)
    6              0.000023   if index(g:rooter_buftypes, &buftype) == -1 | return 0 | endif
                            
    6              0.000020   let patterns = split(g:rooter_targets, ',')
    6   0.000198   0.000026   let fn = s:current_file()
                            
                              " directory
    6              0.000020   if empty(fn) || isdirectory(fn)
                                return index(patterns, '/') != -1
    6              0.000002   endif
                            
                              " file
    6              0.000052   if !filereadable(fn) | return 0 | endif
    3              0.000007   if !exists('*glob2regpat') | return 1 | endif
                            
    3              0.000018   for p in filter(copy(patterns), 'v:val != "/"')
    3              0.000021     if fn =~ glob2regpat(p)
    3              0.000002       return 1
                                endif
                              endfor
                            
                              return 0

FUNCTION  <SNR>58_pre_hook()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer/popupmenu.vim:682
Called 2 times
Total time:   0.002316
 Self time:   0.000391

count  total (s)   self (s)
    2   0.000708   0.000018   call a:state.api.new({ 'normal_highlight': a:state.highlights.default, 'zindex': get(a:state, 'zindex', 0), 'pumblend': get(a:state, 'pumblend', -1) })
                            
   26              0.000039   for l:Component in [a:state.empty_message, a:state.error_message] + a:state.left + a:state.right + a:state.top + a:state.bottom
   24   0.001522   0.000288     call wilder#renderer#call_component_pre_hook(a:ctx, l:Component)
   26              0.000035   endfor
                            
    2              0.000002   let a:state.active = 1
    2              0.000002   let a:state.is_first_draw = 1

FUNCTION  <SNR>109_draw()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/main.vim:429
Called 8 times
Total time:   0.003483
 Self time:   0.000994

count  total (s)   self (s)
    8              0.000004   if s:hidden
                                return
    8              0.000002   endif
                            
    8              0.000003   try
    8              0.000011       let l:direction = a:0 >= 1 ? a:1 : 0
                            
    8              0.000020       if s:selected == -1 && !s:opts.noselect && !s:selection_was_made && !empty(s:result.value)
                                    let l:selected = 0
    8              0.000004       else
    8              0.000007         let l:selected = s:selected
    8              0.000003       endif
                            
    8              0.000046       let l:ctx = { 'clear_previous': get(s:, 'clear_previous_renderer_state', 0), 'selected': l:selected, 'direction': l:direction, 'run_id': s:result_run_id, 'done': s:run_id == s:result_run_id, 'session_id': s:result_session_id, }
    8              0.000009       let s:clear_previous_renderer_state = 0
                            
    8              0.000010       let l:has_error = s:error isnot v:null
                            
    8              0.000005       if l:has_error
                                    let l:ctx.error = s:error
                                    let l:value = {'value': []}
    8              0.000003       else
    8              0.000007         let l:value = s:result
    8              0.000003       endif
                            
    8   0.003257   0.000768       call s:opts.renderer.render(l:ctx, l:value)
                              catch
                                echohl ErrorMsg
                                echomsg 'wilder: draw: ' . v:exception
                                echohl Normal
    8              0.000007   finally
    8              0.000007     let s:draw_done = 1
    8              0.000004   endtry

FUNCTION  <SNR>54_prompt_pre_hook()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer/popupmenu_palette_theme.vim:409
Called 2 times
Total time:   0.000027
 Self time:   0.000027

count  total (s)   self (s)
    2              0.000005   call timer_stop(a:state.timer)
                            
    2              0.000002   let a:state.cmdpos = -1
    2              0.000002   let a:state.previous_start = -1
    2              0.000002   let a:state.previous_end = -1
                            
    2              0.000014   let a:state.timer = timer_start(a:state.cursor_check_interval, {-> s:prompt_update_cursor(a:state)}, {'repeat': -1})

FUNCTION  <SNR>60_make_hl()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/highlight.vim:34
Called 4 times
Total time:   0.002686
 Self time:   0.000105

count  total (s)   self (s)
    4   0.000919   0.000021   let l:x = s:to_hl_list(a:x)
                            
    8              0.000005   for l:elem in a:xs
    4   0.000755   0.000016     let l:y = s:to_hl_list(l:elem)
    4   0.000202   0.000021     let l:x = s:combine_hl_list(l:x, l:y)
    8              0.000003   endfor
                            
    4   0.000787   0.000025   call s:make_hl_from_list(a:name, l:x)

FUNCTION  <SNR>61_delete_all_lines()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer/nvim_api.vim:243
Called 6 times
Total time:   0.000258
 Self time:   0.000258

count  total (s)   self (s)
    6              0.000256   call nvim_buf_set_lines(self.state.buf, 0, -1, v:true, [])

FUNCTION  <SNR>102_Focus()
    Defined: ~/.local/share/nvim/lazy/copilot.vim/autoload/copilot.vim:452
Called 6 times
Total time:   0.000948
 Self time:   0.000199

count  total (s)   self (s)
    6   0.000569   0.000108   if s:Running() && copilot#Client().IsAttached(a:bufnr)
    3   0.000360   0.000072     call copilot#Client().Notify('textDocument/didFocus', {'textDocument': {'uri': copilot#Client().Attach(a:bufnr).uri}})
    6              0.000003   endif

FUNCTION  wilder#main#on_finish()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/main.vim:315
Called 4 times
Total time:   0.002117
 Self time:   0.000179

count  total (s)   self (s)
    4              0.000005   if !s:active || !s:enabled
                                return
    4              0.000001   endif
                            
    4              0.000004   if a:ctx.run_id != s:run_id
                                return
    4              0.000001   endif
                            
    4              0.000004   let s:result_run_id = a:ctx.run_id
    4              0.000004   let s:result_session_id = a:ctx.session_id
                            
    4              0.000008   let l:result = (a:x is v:false || a:x is v:true) ? {'value': []} : a:x
    4              0.000004   if type(l:result) isnot v:t_dict
                                let s:result = {'value': l:result}
    4              0.000002   else
    4              0.000006     let s:result = l:result
    4              0.000001   endif
                            
    4              0.000004   if !has_key(s:result, 'data')
                                let s:result.data = {}
    4              0.000001   endif
                            
    4              0.000005   if !has_key(s:result.data, 'query')
                                let s:result.data.query = a:ctx.input
    4              0.000001   endif
                            
                              " When a new result arrives, the previous results are cleared. If there is a
                              " selection, treat the current cmdline as being replaced.
    4              0.000003   if s:selected >= 0
                                let s:replaced_cmdline = getcmdline()
    4              0.000001   endif
                            
    4              0.000003   let s:selected = -1
    4              0.000004   let s:selection_was_made = 0
    4              0.000004   let s:clear_previous_renderer_state = 1
                              " keep previous completion
                            
    4              0.000003   let s:error = v:null
                            
    4              0.000002   if a:x is v:true
                                if !s:hidden
                                  let s:hidden = 1
                            
                                  call s:post_hook()
                                endif
                            
                                return
    4              0.000001   endif
                            
    4              0.000002   if s:hidden
                                let s:hidden = 0
                            
                                call s:pre_hook()
    4              0.000001   endif
                            
    4              0.000002   if s:select_next
                                call wilder#main#next()
                            
                                let s:select_next = 0
                                return
    4              0.000001   endif
                            
    4              0.000007   if !empty(s:completion_stack) && get(a:ctx, 'auto_select', 0)
                                " removing previous_cmdline causes this to be treated as a new input
                                let s:previous_cmdline = v:null
                            
                                call wilder#main#next()
                                return
    4              0.000001   endif
                            
    4   0.001954   0.000015   call s:draw()

FUNCTION  <SNR>61_set_option()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer/nvim_api.vim:230
Called 10 times
Total time:   0.000208
 Self time:   0.000113

count  total (s)   self (s)
   10              0.000009   if self.state.window_state ==# 'hidden'
                                return
   10              0.000003   endif
                            
   10              0.000007   if self.state.window_state ==# 'pending'
                                let self.state.options[a:option] = a:value
                                return
   10              0.000002   endif
                            
   10   0.000163   0.000067   call nvim_win_set_option(self.state.win, a:option, a:value)

FUNCTION  <lambda>1105()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/pipe/branch.vim:5
Called 1 time
Total time:   0.000172
 Self time:   0.000005

count  total (s)   self (s)
                            return s:branch(a:args, ctx, x)

FUNCTION  <lambda>1107()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/pipeline.vim:105
Called 1 time
Total time:   0.000529
 Self time:   0.000004

count  total (s)   self (s)
                            return s:run(a:pipeline, a:on_finish, a:on_error, ctx, x, a:i)

FUNCTION  <SNR>62_prepare_fuzzy_completion()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/cmdline.vim:46
Called 4 times
Total time:   0.000064
 Self time:   0.000064

count  total (s)   self (s)
                              " For non-python completion, a maximum of 300 help tags are returned, so
                              " getting all the candidates and filtering will miss out on a lot of matches
                              " If argument is empty, don't fuzzy match except for expanding 'help', where
                              " the default argument is 'help'
    4              0.000009   if (a:res.expand ==# 'help' && !a:use_python) || a:res.pos == len(a:res.cmdline)
    2              0.000001     return a:res
    2              0.000000   endif
                            
                              " Remove the starting s: and g: so the fuzzy filter does not match against
                              " that them.
    2              0.000005   if (a:res.expand ==# 'expression' || a:res.expand ==# 'var') && a:res.expand_arg[1] ==# ':' && (a:res.expand_arg[0] ==# 'g' || a:res.expand_arg[0] ==# 's')
                                let a:res.fuzzy_char = a:res.expand_arg[2]
                                let a:res.match_arg = a:res.expand_arg[2 :]
                                let a:res.expand_arg = a:res.expand_arg[0: 1]
                            
                              " For tag-regexp, keep the argument and don't do fuzzy matching
    2              0.000003   elseif a:res.expand ==# 'tags' && a:res.expand_arg[0] ==# '/'
                                let a:res.fuzzy_char = ''
                                let a:res.match_arg = ''
                            
                              " Return all candidates and let the fuzzy filter remove the non-matching
                              " candidates for the following cases:
                              "
                              " mapping: special keys such as <Space> cannot be fuzzy completed since
                              " < will not get completions for <Space>.
                              "
                              " buffer: getcompletion() for buffers checks against the file name, but
                              " we want to check against the full path.
                              "
                              " help: help tag matching does not have to start from beginning of word.
    2              0.000003   elseif a:res.expand ==# 'mapping' || a:res.expand ==# 'buffer' || a:res.expand ==# 'help'
                                " Default argument for help completion is 'help'
                                if a:res.expand ==# 'help' && empty(a:res.expand_arg)
                                  let a:res.match_arg = 'help'
                                else
                                  let a:res.match_arg = a:res.expand_arg
                                endif
                            
                                let a:res.expand_arg = ''
                                let a:res.fuzzy_char = ''
    2              0.000001   else
                                " Default case, expand with the fuzzy_char
    2              0.000005     let a:res.fuzzy_char = strcharpart(a:res.expand_arg, 0, 1)
    2              0.000002     let a:res.expand_arg = ''
    2              0.000001   endif
                            
    2              0.000001   return a:res

FUNCTION  wilder#transform#vim_fuzzy_filt()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/transform.vim:99
Called 4 times
Total time:   0.000025
 Self time:   0.000025

count  total (s)   self (s)
    4              0.000004   if empty(a:query)
    2              0.000002     return a:candidates
    2              0.000000   endif
                            
    2              0.000003   if exists('*matchfuzzy')
    2              0.000011     return matchfuzzy(a:candidates, a:query)
                              endif
                            
                              return s:vim_fuzzy_filt(a:ctx, a:candidates, a:query)

FUNCTION  wilder#uniq_filt()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder.vim:382
Called 2 times
Total time:   0.000070
 Self time:   0.000028

count  total (s)   self (s)
    2   0.000069   0.000027   return call('wilder#transform#uniq_filt', a:000)

FUNCTION  <SNR>58_render()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer/popupmenu.vim:121
Called 8 times
Total time:   0.002344
 Self time:   0.000544

count  total (s)   self (s)
    8              0.000017   call timer_stop(a:state.empty_message_first_draw_timer)
                            
    8              0.000008   if a:state.run_id != a:ctx.run_id
    4              0.000005     let a:state.longest_line_width = 0
    4   0.000022   0.000014     call a:state.draw_cache.clear()
    4   0.000016   0.000010     call a:state.highlight_cache.clear()
    8              0.000003   endif
                            
    8              0.000008   let a:state.run_id = a:ctx.run_id
                            
    8              0.000005   if a:ctx.clear_previous
    4              0.000005     let a:state.page = [-1, -1]
    8              0.000002   endif
                            
    8   0.000340   0.000037   let l:page = s:make_page(a:state, a:ctx, a:result)
    8              0.000008   let a:ctx.page = l:page
    8              0.000008   let a:state.page = l:page
                            
    8              0.000018   let l:height = l:page == [-1, -1] ? 0 : l:page[1] - l:page[0] + 1
                            
    8   0.000066   0.000027   let l:min_height = a:state.get_min_height(a:ctx, a:result)
    8              0.000011   let l:min_height -= len(a:state.top)
    8              0.000010   let l:min_height -= len(a:state.bottom)
    8              0.000007   if l:height < l:min_height
                                let l:height = l:min_height
    8              0.000002   endif
                            
    8              0.000008   let a:ctx.height = l:height
    8              0.000009   let a:ctx.highlights = a:state.highlights
                            
                              " Hide popupmenu if there is nothing to draw and empty message is not set
    8              0.000019   if a:state.page == [-1, -1] && !has_key(a:ctx, 'error') && a:state.empty_message is 0
                                call a:state.api.hide()
                                return
    8              0.000002   endif
                            
    8              0.000009   let l:was_first_draw = a:state.is_first_draw
    8              0.000007   let a:state.is_first_draw = 0
                            
                              " Rough hack to prevent empty message from showing for the first draw.
                              " If the pipeline is async, the first draw will always have an empty result.
                              " This delays the empty message from showing to prevent flicker.
    8              0.000021   if l:was_first_draw && a:state.page == [-1, -1] && a:state.empty_message isnot 0 && !a:ctx.done && a:state.empty_message_first_draw_delay > 0
    2              0.000007     let a:state.empty_message_first_draw_timer = timer_start(a:state.empty_message_first_draw_delay, {-> wilder#main#draw()})
    2              0.000001     return
    6              0.000002   endif
                            
                              " If error or empty message is not showing, check if we need to draw.
    6   0.001497   0.000075   if !has_key(a:ctx, 'error') && a:state.page != [-1, -1] && !wilder#renderer#pre_draw(a:state.left + a:state.right + a:state.top + a:state.bottom, a:ctx, a:result)
                                return
    6              0.000002   endif
                            
    6              0.000006   let a:state.render_id += 1
                            
    6   0.000043   0.000020   if a:state.api.need_timer()
    6              0.000006     let l:render_id = a:state.render_id
    6              0.000024     call timer_start(0, {-> s:render_lines_from_timer(l:render_id, a:state, a:ctx, a:result)})
                              else
                                call s:render_lines(a:state, a:ctx, a:result)
    6              0.000002   endif

FUNCTION  wilder#pipeline#clear_handlers()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/pipeline.vim:6
Called 2 times
Total time:   0.000030
 Self time:   0.000030

count  total (s)   self (s)
    2              0.000009   let s:last_cleared_id = s:id_index
    2              0.000007   let s:handler_registry = {}
    2              0.000005   let s:partial_results = {}

FUNCTION  <lambda>910()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/pipeline.vim:105
Called 1 time
Total time:   0.000714
 Self time:   0.000004

count  total (s)   self (s)
                            return s:run(a:pipeline, a:on_finish, a:on_error, ctx, x, a:i)

FUNCTION  <SNR>111_prepare_call()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/pipeline.vim:105
Called 16 times
Total time:   0.000240
 Self time:   0.000240

count  total (s)   self (s)
   16              0.000095   let l:handler = { 'on_finish': {ctx, x -> s:run(a:pipeline, a:on_finish, a:on_error, ctx, x, a:i)}, 'on_error': {ctx, x -> a:on_error(ctx, x)}, }
                            
   16              0.000015   let s:id_index += 1
   16              0.000017   let l:handler_id = s:id_index
   16              0.000030   let s:handler_registry[s:id_index] = l:handler
                            
   16              0.000063   call timer_start(0, {_ -> s:call(a:f, a:ctx, l:handler_id)})

FUNCTION  <SNR>52_mru_set()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/cache.vim:45
Called 2 times
Total time:   0.000062
 Self time:   0.000028

count  total (s)   self (s)
    2              0.000004   let self['_cache'][a:key] = a:value
                            
    2   0.000057   0.000024   call self.mru_update(a:key)

FUNCTION  <SNR>16_CreateNvimUi()
    Defined: ~/.local/share/nvim/lazy/any-jump.vim/plugin/any-jump.vim:195
Called 3 times
Total time:   0.040701
 Self time:   0.001529

count  total (s)   self (s)
    3              0.000005   let kw  = a:internal_buffer.keyword
    3              0.000148   let buf = nvim_create_buf(1, 0)
    3   0.002151   0.000863   call nvim_buf_set_name(buf, 'any-jump lookup ' . kw)
                            
    3   0.000112   0.000070   call nvim_buf_set_option(buf, 'bufhidden', 'delete')
    3   0.000102   0.000050   call nvim_buf_set_option(buf, 'buftype', 'nofile')
    3   0.000075   0.000045   call nvim_buf_set_option(buf, 'modifiable', v:true)
                            
    3              0.000012   let height     = float2nr(&lines * g:any_jump_window_height_ratio)
    3              0.000006   let width      = float2nr(&columns * g:any_jump_window_width_ratio)
    3              0.000006   let horizontal = float2nr((&columns - width) / 2)
    3              0.000004   let vertical   = g:any_jump_window_top_offset
                            
    3              0.000012   let opts = { 'relative': 'editor', 'row': vertical, 'col': horizontal, 'width': width, 'height': height, 'style': 'minimal', }
                            
    3   0.006113   0.000217   let winid = nvim_open_win(buf, v:true, opts)
                            
                              " Set filetype after window appearance for proper event propagation
    3   0.017010   0.000019   call nvim_buf_set_option(buf, 'filetype', 'any-jump')
                            
    3   0.000050   0.000020   call nvim_win_set_option(winid, 'number', v:false)
    3   0.000023   0.000010   call nvim_win_set_option(winid, 'wrap', v:false)
                            
    3              0.000007   let t:any_jump.vim_bufnr = buf
                            
    3   0.014435   0.000013   call t:any_jump.RenderUi()
    3   0.000415   0.000009   call t:any_jump.JumpToFirstOfType('link', 'definitions')

FUNCTION  <SNR>10_current()
    Defined: ~/.local/share/nvim/lazy/vim-rooter/plugin/rooter.vim:239
Called 3 times
Total time:   0.000108
 Self time:   0.000023

count  total (s)   self (s)
    3   0.000096   0.000011   let fn = s:current_file()
    3              0.000006   if empty(fn) | return getcwd() | endif  " opening vim without a file
    3              0.000005   return fnamemodify(fn, ':h')

FUNCTION  <SNR>116_ParseRgResults()
    Defined: ~/.local/share/nvim/lazy/any-jump.vim/autoload/search.vim:413
Called 6 times
Total time:   0.014902
 Self time:   0.013967

count  total (s)   self (s)
    6              0.000011   let grep_results = []
                            
    6              0.000046   if len(a:raw_results) > 0
    6              0.000005     let matches = []
                            
  579              0.000490     for res in split(a:raw_results, "\n")
  573              0.002659       let match = json_decode(res)
  573              0.000497       call add(matches, match)
  579              0.000146     endfor
                            
  579              0.000248     for match in matches
  573              0.000552       if get(match, 'type') == 'match'
  531              0.000496         let data = get(match, 'data')
                            
  531              0.000438         if type(data) == v:t_dict
  531              0.000412           let text = data.lines.text
  531              0.001506           let text = substitute(text, '^\s*', '', 'g')
  531              0.000975           let text = substitute(text, '\n', '', 'g')
                            
  531   0.002852   0.001917           let grep_result             = s:NewGrepResult()
  531              0.000463           let grep_result.line_number = data.line_number
  531              0.000423           let grep_result.path        = data.path.text
  531              0.000369           let grep_result.text        = text
                            
  531              0.000521           call add(grep_results, grep_result)
  531              0.000130         endif
  573              0.000123       endif
  579              0.000644     endfor
    6              0.000002   endif
                            
    6              0.000004   return grep_results

FUNCTION  <SNR>111_wait_start()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/pipeline.vim:175
Called 8 times
Total time:   0.000636
 Self time:   0.000103

count  total (s)   self (s)
    8              0.000011   let a:state.wait_handler_id = a:ctx.handler_id
                            
    8              0.000040   let a:state.handler = { 'on_finish': {ctx, x -> s:wait_on_finish(a:state, ctx, x)}, 'on_error': {ctx, x -> s:wait_on_error(a:state, ctx, x)}, }
                            
    8   0.000578   0.000045   call s:wait_call(a:state, a:ctx)

FUNCTION  <SNR>67_on_finish()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/pipe/branch.vim:26
Called 24 times
Total time:   0.004305
 Self time:   0.000209

count  total (s)   self (s)
   24              0.000023   if a:x isnot v:false
   12   0.000176   0.000059     call s:resolve(a:state, a:ctx, a:x)
   12              0.000005     return
   12              0.000003   endif
                            
   12              0.000011   let a:state.index += 1
                            
   12              0.000015   if a:state.index >= len(a:state.pipelines)
                                call s:resolve(a:state, a:ctx, v:false)
                                return
   12              0.000003   endif
                            
   12   0.002264   0.000294   call wilder#pipeline#run( a:state.pipelines[a:state.index], {ctx, x -> s:on_finish(a:state, ctx, x)}, {ctx, x -> s:on_error(a:state, ctx, x)}, copy(a:state.original_ctx), copy(a:state.original_x), )

FUNCTION  <SNR>109_pre_hook()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/main.vim:224
Called 2 times
Total time:   0.005128
 Self time:   0.000048

count  total (s)   self (s)
    2   0.002736   0.000009   call wilder#highlight#init_hl()
                            
    2              0.000003   if has_key(s:opts, 'pre_hook')
                                call s:opts.pre_hook({})
    2              0.000001   endif
                            
    2              0.000003   if has_key(s:opts.renderer, 'pre_hook')
    2   0.002380   0.000028     call s:opts.renderer.pre_hook({})
    2              0.000001   endif

FUNCTION  <SNR>111_wait_call()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/pipeline.vim:186
Called 10 times
Total time:   0.000568
 Self time:   0.000171

count  total (s)   self (s)
   10              0.000004   try
   10              0.000014     if type(a:state.f) is v:t_func
    4              0.000007       let l:ctx = copy(a:ctx)
                            
    4              0.000004       let s:id_index += 1
    4              0.000004       let l:id_index = s:id_index
    4              0.000007       let s:handler_registry[s:id_index] = a:state.handler
                            
    4              0.000013       call timer_start(0, {_ -> s:call(a:state.f, l:ctx, l:id_index)})
    6              0.000002     else
    6              0.000006       let a:ctx.handler_id = a:state.wait_handler_id
    6   0.000417   0.000020       call a:state.on_finish(a:ctx, a:state.f)
   10              0.000003     endif
                              catch
                                let a:ctx.handler_id = a:state.wait_handler_id
                                call s:wait_on_error(a:state, a:ctx, v:exception)
   10              0.000004   endtry

FUNCTION  wilder#lua#wrap()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/lua.vim:9
Called 4572 times
Total time:   0.072947
 Self time:   0.064079

count  total (s)   self (s)
 4572              0.008862   if type(a:t) is v:t_string || type(a:t) is v:t_number || type(a:t) is v:t_bool || a:t is v:null
 3962              0.001796     return a:t
  610              0.000154   endif
                            
  610              0.000469   if type(a:t) is v:t_func
    8   0.000093   0.000032     return s:wrap_function(a:t)
  602              0.000147   endif
                            
  602              0.000460   if type(a:t) is v:t_dict
  188              0.000118     for l:key in keys(a:t)
  160              0.000147       let l:Value = a:t[l:key]
  160              0.000184       let a:t[l:key] = wilder#lua#wrap(l:Value)
  188              0.000066     endfor
  602              0.000147   endif
                            
                              " v:t_list
  602              0.002983   return map(a:t, {_, x -> wilder#lua#wrap(x)})

FUNCTION  wilder#renderer#call_component_pre_hook()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer.vim:74
Called 24 times
Total time:   0.000156
 Self time:   0.000087

count  total (s)   self (s)
   24              0.000042   if type(a:component) is v:t_dict && has_key(a:component, 'pre_hook')
    2   0.000082   0.000014     call a:component['pre_hook'](a:ctx)
   24              0.000007   endif

FUNCTION  <lambda>931()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/pipeline.vim:105
Called 1 time
Total time:   0.000100
 Self time:   0.000018

count  total (s)   self (s)
                            return s:run(a:pipeline, a:on_finish, a:on_error, ctx, x, a:i)

FUNCTION  <SNR>96_SynSet()
    Defined: /opt/homebrew/Cellar/neovim/0.10.1/share/nvim/runtime/syntax/synload.vim:27
Called 7 times
Total time:   0.015006
 Self time:   0.015006

count  total (s)   self (s)
                              " clear syntax for :set syntax=OFF  and any syntax name that doesn't exist
    7              0.000015   syn clear
    7              0.000009   if exists("b:current_syntax")
                                unlet b:current_syntax
    7              0.000002   endif
                            
    7              0.000012   0verbose let s = expand("<amatch>")
    7              0.000006   if s == "ON"
                                " :set syntax=ON
                                if &filetype == ""
                                  echohl ErrorMsg
                                  echo "filetype unknown"
                                  echohl None
                                endif
                                let s = &filetype
    7              0.000005   elseif s == "OFF"
                                let s = ""
    7              0.000002   endif
                            
    7              0.000004   if s != ""
                                " Load the syntax file(s).  When there are several, separated by dots,
                                " load each in sequence.  Skip empty entries.
   14              0.000023     for name in split(s, '\.')
    7              0.000007       if !empty(name)
                                    " XXX: "[.]" in the first pattern makes it a wildcard on Windows
    7              0.014808         exe $'runtime! syntax/{name}[.]{{vim,lua}} syntax/{name}/*.{{vim,lua}}'
    7              0.000005       endif
   14              0.000024     endfor
    7              0.000003   endif

FUNCTION  <SNR>62_sort_buffers_lastused()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/cmdline.vim:1398
Called 4 times
Total time:   0.000012
 Self time:   0.000012

count  total (s)   self (s)
    4              0.000007   if get(a:data, 'cmdline.expand', '') !=# 'buffer'
    4              0.000002     return a:xs
                              endif
                            
                              let l:bufinfos = getbufinfo()
                              let l:bufnr_to_x = {}
                            
                              for l:x in a:xs
                                let l:bufname = fnamemodify(l:x, ':~')
                                let l:bufnr = bufnr('^' . l:x . '$')
                            
                                let l:bufnr_to_x[l:bufnr] = l:x
                              endfor
                            
                              let l:x_to_info = {}
                              let l:seen = {}
                            
                              for l:info in l:bufinfos
                                let l:bufnr = l:info.bufnr
                            
                                if !has_key(l:bufnr_to_x, l:bufnr)
                                  continue
                                endif
                            
                                let l:x = l:bufnr_to_x[l:bufnr]
                                let l:x_to_info[l:x] = l:info
                                let l:seen[l:bufnr] = 1
                              endfor
                            
                              let l:xs = copy(a:xs)
                              let l:match_arg = get(a:data, 'cmdline.match_arg', '')
                            
                              " add matching bufnr
                              if l:match_arg =~# '\d\+'
                                for l:info in l:bufinfos
                                  let l:bufnr = l:info.bufnr
                                  let l:bufname = l:info.name
                            
                                  if !l:info.listed || empty(l:bufname) || has_key(l:seen, l:bufnr)
                                    continue
                                  endif
                            
                                  if stridx(l:bufnr, l:match_arg) == 0
                                    let l:bufname = fnamemodify(l:bufname, ':~:.')
                                    let l:x_to_info[l:bufname] = l:info
                                    call add(l:xs, l:bufname)
                                  endif
                                endfor
                              endif
                            
                              let l:current_bufnr = bufnr('%')
                            
                              return sort(l:xs, {x1, x2 -> s:sort_buffers_lastused_func(x1, x2, l:x_to_info, l:current_bufnr)})

FUNCTION  <SNR>58_draw_candidate()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer/popupmenu.vim:656
Called 110 times
Total time:   0.004021
 Self time:   0.001394

count  total (s)   self (s)
  110              0.000109   let l:use_cache = a:ctx.selected == a:i
  110              0.000143   if l:use_cache && a:state.draw_cache.has_key(a:i)
                                return a:state.draw_cache.get(a:i)
  110              0.000029   endif
                            
  110   0.003281   0.000655   let l:x = wilder#render#draw_candidate(a:ctx, a:result, a:i)
                            
  110              0.000052   if l:use_cache
                                call a:state.draw_cache.set(a:i, l:x)
  110              0.000027   endif
                            
  110              0.000054   return l:x

FUNCTION  wilder#cmdline#prepare_getcompletion()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/cmdline.vim:20
Called 4 times
Total time:   0.000135
 Self time:   0.000071

count  total (s)   self (s)
    4              0.000005   let a:res.match_arg = a:res.arg
    4              0.000013   let a:res.expand_arg = has_key(a:res, 'subcommand_start') ? a:res.cmdline[a:res.subcommand_start :] : a:res.arg
                            
    4              0.000002   if !a:fuzzy
                                if a:res.expand ==# 'tags' && !empty(a:res.expand_arg) && a:res.expand_arg[0] !=# '/'
                                  " Search taglist for tags starting with expand_arg
                                  let a:res.expand_arg = '/^' . a:res.expand_arg
                                endif
                            
                                return a:res
    4              0.000001   endif
                            
    4   0.000089   0.000024   return s:prepare_fuzzy_completion(a:ctx, a:res, a:use_python)

FUNCTION  wilder#wait()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder.vim:55
Called 8 times
Total time:   0.000107
 Self time:   0.000068

count  total (s)   self (s)
    8              0.000005   if !a:0
                                return wilder#pipeline#wait(a:f)
    8              0.000005   elseif a:0 == 1
    8   0.000084   0.000045     return wilder#pipeline#wait(a:f, a:1)
                              else
                                return wilder#pipeline#wait(a:f, a:1, a:2)
                              endif

FUNCTION  AnyJumpHandleClose()
    Defined: ~/.local/share/nvim/lazy/any-jump.vim/plugin/any-jump.vim:473
Called 3 times
Total time:   0.016665
 Self time:   0.003215

count  total (s)   self (s)
    3   0.000047   0.000029   let ui = s:GetCurrentInternalBuffer()
    3              0.000008   let ui.current_page = 1
                            
    3              0.000003   if s:nvim
    3   0.016594   0.003163     close!
                              else
                                call popup_close(ui.popup_winid)
    3              0.000001   endif

FUNCTION  wilder#renderer#pre_draw()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer.vim:52
Called 6 times
Total time:   0.001422
 Self time:   0.000416

count  total (s)   self (s)
    6              0.000006   let l:should_draw = 0
                            
   66              0.000044   for l:Component in a:components
   60   0.001243   0.000237     let l:should_draw += s:pre_draw(l:Component, a:ctx, a:result)
   66              0.000106   endfor
                            
    6              0.000004   return l:should_draw

FUNCTION  copilot#OnBufEnter()
    Defined: ~/.local/share/nvim/lazy/copilot.vim/autoload/copilot.vim:458
Called 6 times
Total time:   0.000140
 Self time:   0.000086

count  total (s)   self (s)
    6              0.000009   let bufnr = bufnr('')
    6   0.000128   0.000074   call copilot#util#Defer(function('s:Focus'), bufnr)

FUNCTION  AnyJumpGetColor()
    Defined: ~/.local/share/nvim/lazy/any-jump.vim/plugin/any-jump.vim:174
Called 156 times
Total time:   0.000421
 Self time:   0.000421

count  total (s)   self (s)
  156              0.000219   if has_key(g:any_jump_colors_compiled, a:name)
  156              0.000161     return g:any_jump_colors_compiled[a:name]
                              else
                                echo "any-jump color not found: " . a:name
                                return 'Comment'
                              endif

FUNCTION  wilder#options#get()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/options.vim:13
Called 1 time
Total time:   0.000016
 Self time:   0.000016

count  total (s)   self (s)
    1              0.000001   if !a:0
                                return s:opts
    1              0.000000   endif
                            
    1              0.000003   if a:1 ==# 'use_python_remote_plugin' && !has_key(s:opts, 'use_python_remote_plugin')
                                if !has('python3')
                                  let s:opts.use_python_remote_plugin = 0
                                elseif has('nvim')
                                  let s:opts.use_python_remote_plugin = 1
                                else
                                  let l:file = findfile('autoload/yarp.vim', &rtp)
                                  let s:opts.use_python_remote_plugin = !empty(l:file)
                                endif
    1              0.000000   endif
                            
    1              0.000001   return s:opts[a:1]

FUNCTION  <SNR>116_GetRgFiletype()
    Defined: ~/.local/share/nvim/lazy/any-jump.vim/autoload/search.vim:107
Called 3 times
Total time:   0.000014
 Self time:   0.000014

count  total (s)   self (s)
    3              0.000006   if has_key(s:rg_filetype_convertion_map, a:lang)
                                return s:rg_filetype_convertion_map[a:lang]
    3              0.000001   else
    3              0.000002     return a:lang
                              endif

FUNCTION  <SNR>58_make_page()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer/popupmenu.vim:195
Called 8 times
Total time:   0.000303
 Self time:   0.000236

count  total (s)   self (s)
    8              0.000010   if empty(a:result.value)
    2              0.000002     return [-1, -1]
    6              0.000002   endif
                            
    6              0.000005   let l:page = a:state.page
    6              0.000005   let l:selected = a:ctx.selected
                              " Adjust -1 (unselected) to show the top of the list.
    6              0.000008   let l:selected = l:selected == -1 ? 0 : l:selected
                            
                              " Adjust previous page.
    6              0.000008   if l:page != [-1, -1]
    2              0.000003     if l:page[0] > len(a:result.value)
                                  let l:page = [-1, -1]
    2              0.000003     elseif l:page[1] > len(a:result.value)
                                  let l:page[1] = len(a:result.value) - 1
    2              0.000001     endif
    6              0.000002   endif
                            
    6              0.000005   if l:page != [-1, -1]
                                " Selected is within current page, reuse the page.
    2              0.000004     if l:selected != -1 && l:selected >= l:page[0] && l:selected <= l:page[1]
    2              0.000001       return l:page
                                endif
                            
                                " Scroll the page forward.
                                if a:ctx.direction >= 0 && l:page[1] < l:selected
                                  " calculate distance moved.
                                  let l:moved = l:selected - l:page[1]
                                  return [l:page[0] + l:moved, l:selected]
                                endif
                            
                                " Scroll the page backward.
                                if a:ctx.direction < 0 && l:page[0] > l:selected
                                  " calculate distance moved.
                                  let l:moved = l:page[0] - l:selected
                                  return [l:selected, l:page[1] - l:moved]
                                endif
    4              0.000001   endif
                            
                              " Otherwise make a new page.
                            
    4   0.000064   0.000014   let l:max_height = a:state.get_max_height(a:ctx, a:result)
    4   0.000029   0.000012   let l:min_height = a:state.get_min_height(a:ctx, a:result)
    4              0.000004   if l:max_height < l:min_height
                                let l:max_height = l:min_height
    4              0.000001   endif
    4              0.000006   let l:max_height -= len(a:state.top)
    4              0.000005   let l:max_height -= len(a:state.bottom)
                              " Assume the worst case scenario that the cursor is on the top row of the
                              " cmdline.
    4              0.000009   let l:max_height = min([l:max_height, &lines - &cmdheight - 1])
                            
                              " Page starts at selected.
    4              0.000003   if a:ctx.direction >= 0
    4              0.000004     let l:start = l:selected
                            
                                " Try to include all candidates after selected.
    4              0.000006     let l:height = len(a:result.value) - l:selected
                            
    4              0.000003     if l:height > l:max_height
    2              0.000002       let l:height = l:max_height
    4              0.000001     endif
                            
    4              0.000005     return [l:start, l:start + l:height - 1]
                              endif
                            
                              " Page ends at selected.
                              let l:end = l:selected
                            
                              " Try to include all candidates before selected.
                              let l:height = l:selected
                            
                              if l:height > l:max_height
                                let l:height = l:max_height
                              endif
                            
                              return [l:end - l:height + 1, l:end]

FUNCTION  <SNR>62_set_query()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/cmdline.vim:1473
Called 4 times
Total time:   0.000042
 Self time:   0.000042

count  total (s)   self (s)
    4              0.000006   let l:data = a:data is v:null ? {} : a:data
    4              0.000007   let l:match_arg = get(l:data, 'cmdline.match_arg', '')
                            
    4              0.000026   return extend(l:data, {'query': l:match_arg})

FUNCTION  <SNR>111_wait_on_finish()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/pipeline.vim:206
Called 4 times
Total time:   0.000122
 Self time:   0.000038

count  total (s)   self (s)
    4              0.000005   if type(a:x) is v:t_func
    2              0.000002     let a:state.f = a:x
    2   0.000043   0.000007     call s:wait_call(a:state, a:ctx)
    2              0.000001     return
    2              0.000001   endif
                            
    2              0.000003   let l:ctx = copy(a:ctx)
    2              0.000002   let l:ctx.handler_id = a:state.wait_handler_id
                            
    2              0.000001   try
    2   0.000055   0.000006     call a:state.on_finish(l:ctx, a:x)
                              catch
                                call wilder#reject(l:ctx, v:exception)
    2              0.000001   endtry

FUNCTION  wilder#cmdline#skip_range#do()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/cmdline/skip_range.vim:3
Called 1 time
Total time:   0.000031
 Self time:   0.000031

count  total (s)   self (s)
    1              0.000006   while a:ctx.pos < len(a:ctx.cmdline) && stridx(s:chars, a:ctx.cmdline[a:ctx.pos]) != -1
                                let l:char = a:ctx.cmdline[a:ctx.pos]
                                if l:char ==# '\'
                                  if a:ctx.pos + 1 >= len(a:ctx.cmdline)
                                    return 1
                                  endif
                            
                                  let l:second_char = a:ctx.cmdline[a:ctx.pos + 1]
                            
                                  if l:second_char ==# '?' || l:second_char ==# '/' || l:second_char ==# '&'
                                    let a:ctx.pos += 2
                                  else
                                    return 1
                                  endif
                                elseif l:char ==# "'"
                                  let a:ctx.pos += 1
                                elseif l:char ==# '/' || l:char ==# '?'
                                  let l:delim = l:char
                                  let a:ctx.pos += 1
                            
                                  while a:ctx.pos < len(a:ctx.cmdline) && a:ctx.cmdline[a:ctx.pos] !=# l:delim
                                    if a:ctx.cmdline[a:ctx.pos] ==# '\' && a:ctx.pos + 1 < len (a:ctx.cmdline)
                                      let a:ctx.pos += 1
                                    endif
                            
                                    let a:ctx.pos += 1
                                  endwhile
                            
                                  if a:ctx.pos == len(a:ctx.cmdline)
                                    return
                                  endif
                                endif
                            
                                let a:ctx.pos += 1
    1              0.000002   endwhile

FUNCTION  <lambda>907()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer/popupmenu_palette_theme.vim:415
Called 26 times
Total time:   0.000587
 Self time:   0.000265

count  total (s)   self (s)
                            return s:prompt_update_cursor(a:state)

FUNCTION  <lambda>908()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/pipe/branch.vim:5
Called 1 time
Total time:   0.000803
 Self time:   0.000004

count  total (s)   self (s)
                            return s:branch(a:args, ctx, x)

FUNCTION  wilder#vim_fuzzy_filt()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder.vim:416
Called 4 times
Total time:   0.000068
 Self time:   0.000043

count  total (s)   self (s)
    4   0.000067   0.000042   return call('wilder#transform#vim_fuzzy_filt', a:000)

FUNCTION  <SNR>52_mru_get()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/cache.vim:41
Called 4 times
Total time:   0.000007
 Self time:   0.000007

count  total (s)   self (s)
    4              0.000006   return self['_cache'][a:key]

FUNCTION  lang_map#get_language_from_filetype()
    Defined: ~/.local/share/nvim/lazy/any-jump.vim/autoload/lang_map.vim:36
Called 3 times
Total time:   0.000052
 Self time:   0.000043

count  total (s)   self (s)
    3              0.000009   if has_key(s:filetypes_proxy, a:ft)
                                let maybe_lan = s:filetypes_proxy[a:ft]
    3              0.000002   else
    3              0.000004     let maybe_lan = a:ft
    3              0.000001   endif
                            
    3   0.000024   0.000015   if lang_map#lang_exists(maybe_lan)
    3              0.000002     return maybe_lan
                              else
                                return 0
                              endif

FUNCTION  <lambda>1254()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/cmdline.vim:309
Called 1 time
Total time:   0.000132
 Self time:   0.000029

count  total (s)   self (s)
                            return wilder#resolve(ctx, wilder#wait(a:getcompletion(ctx, l:lower_res), {ctx, lower_xs -> wilder#resolve(ctx, wilder#uniq_filt(0, 0, lower_xs + upper_xs))}))

FUNCTION  <SNR>116_RunRgDefinitionSearch()
    Defined: ~/.local/share/nvim/lazy/any-jump.vim/autoload/search.vim:325
Called 3 times
Total time:   0.081448
 Self time:   0.000481

count  total (s)   self (s)
    3   0.000029   0.000015   let rg_ft = s:GetRgFiletype(a:language)
                            
    3              0.000005   let cmd = s:rg_base_cmd . ' -t ' . rg_ft
    3   0.000062   0.000016   let cmd = cmd . s:GetRgIgnoreSpecifier()
    3              0.000006   let cmd = cmd . ' ' . a:patterns
                            
    3   0.074807   0.000047   let raw_results  = system(cmd)
    3   0.006101   0.000338   let grep_results = s:ParseRgResults(raw_results)
    3   0.000428   0.000045   let grep_results = s:FilterGrepResults(a:language, grep_results)
                            
    3              0.000002   return grep_results

FUNCTION  41()
    Defined: ~/.local/share/nvim/lazy/any-jump.vim/autoload/internal_buffer.vim:657
Called 3 times
Total time:   0.001864
 Self time:   0.000127

count  total (s)   self (s)
    3              0.000003   if g:any_jump_show_help_section
    3   0.000209   0.000019     call self.AddLine([ self.CreateItem("help_link", "> Help", g:AnyJumpGetColor('heading_text')) ])
                            
    3   0.000017   0.000009     let color = g:AnyJumpGetColor('help')
                            
    3   0.000242   0.000011     call self.AddLine([ self.CreateItem("help_text", "", color) ])
    3   0.000256   0.000015     call self.AddLine([ self.CreateItem("help_text", "[o] open               [t] open in tab        [s] open in split   [v] open in vsplit", color) ])
    3   0.000247   0.000013     call self.AddLine([ self.CreateItem("help_text", "[p/tab] preview file   [b] scroll to first result", color) ])
    3   0.000198   0.000012     call self.AddLine([ self.CreateItem("help_text", "[a] load more results  [A] load all results", color) ])
    3   0.000236   0.000012     call self.AddLine([ self.CreateItem("help_text", "[r] show references    [T] group by file", color) ])
    3   0.000209   0.000013     call self.AddLine([ self.CreateItem("help_text", "[L] toggle search                             [esc/q] exit", color) ])
    3   0.000239   0.000012     call self.AddLine([ self.CreateItem("help_text", "    results ui style", color) ])
    3              0.000001   endif

FUNCTION  search#SearchDefinitions()
    Defined: ~/.local/share/nvim/lazy/any-jump.vim/autoload/search.vim:196
Called 3 times
Total time:   0.082599
 Self time:   0.000418

count  total (s)   self (s)
    3              0.000003   let patterns      = []
    3   0.000059   0.000031   let lang          = lang_map#find_definitions(a:lang)
    3   0.000709   0.000015   let search_engine = search#GetCurrentSearchEngine()
                            
                              " if lang regexp doesn't support prefered search engine
    3              0.000010   if index(lang[0].supports, search_engine) == -1
                                " try to change selected engine
                                let search_engine = (search_engine == 'rg' ? 'ag' : 'rg')
                            
                                " end error of changed engine not installed
                                if !executable(search_engine)
                                  echoe "please install " . search_engine . " to run " . a:lang . " any-jump.vim search"
                                endif
                            
                                return 0
    3              0.000001   endif
                            
   21              0.000014   for rule in lang
   18              0.000076     let regexp = substitute(rule.pcre2_regexp, s:regexp_keyword_word, a:keyword, "g")
                            
   18              0.000034     if match(&shell, 'fish') != -1
                                  let regexp = substitute(regexp, '\$', '\\$', 'g')
   18              0.000005     endif
                            
   18              0.000023     call add(patterns, regexp)
   21              0.000021   endfor
                            
    3   0.000063   0.000051   let regexp = map(patterns, { _, pattern -> '(' . pattern . ')' })
    3              0.000010   let regexp = join(regexp, '|')
    3              0.000006   let regexp = "\"(" . regexp . ")\""
                            
    3              0.000004   if search_engine == 'rg'
    3   0.081477   0.000029     let grep_results = s:RunRgDefinitionSearch(a:lang, regexp)
                              elseif search_engine == 'ag'
                                let grep_results = s:RunAgDefinitionSearch(a:lang, regexp)
    3              0.000001   end
                            
    3              0.000002   return grep_results

FUNCTION  <SNR>116_GetRgIgnoreSpecifier()
    Defined: ~/.local/share/nvim/lazy/any-jump.vim/autoload/search.vim:145
Called 6 times
Total time:   0.000102
 Self time:   0.000102

count  total (s)   self (s)
    6              0.000004   let result = ''
                            
    6              0.000009   if g:any_jump_disable_vcs_ignore
                                let result .= " --no-ignore-vcs"
    6              0.000002   endif
                            
   18              0.000017   for glob in g:any_jump_ignored_files
   12              0.000027     let result = result . ' -g !' . string(glob)
   18              0.000020   endfor
                            
    6              0.000004   return result

FUNCTION  <SNR>16_Jump()
    Defined: ~/.local/share/nvim/lazy/any-jump.vim/plugin/any-jump.vim:339
Called 3 times
Total time:   0.178406
 Self time:   0.005599

count  total (s)   self (s)
    3   0.007707   0.003472   let lang = lang_map#get_language_from_filetype(&l:filetype)
    3              0.000002   let keyword = ''
                            
    3              0.000002   let opts = {}
    3              0.000002   if a:0
                                let opts = a:1
    3              0.000001   endif
                            
    3              0.000004   if has_key(opts, 'is_visual')
                                let x = getpos("'<")[2]
                                let y = getpos("'>")[2]
                            
                                let keyword = getline(line('.'))[ x - 1 : y - 1]
    3              0.000003   elseif has_key(opts, 'is_arg')
                                let keyword = opts['is_arg']
    3              0.000001   else
    3              0.000009     let keyword = expand('<cword>')
    3              0.000001   endif
                            
    3              0.000005   if len(keyword) == 0
                                return
    3              0.000001   endif
                            
    3   0.000926   0.000333   let ib = internal_buffer#GetClass().New()
                            
    3              0.000004   let ib.keyword                  = keyword
    3              0.000003   let ib.language                 = lang
    3              0.000007   let ib.source_win_id            = winnr()
    3              0.000006   let ib.grouping_enabled         = g:any_jump_grouping_enabled
                            
    3              0.000005   if type(lang) == v:t_string
    3   0.083706   0.000262     let ib.definitions_grep_results = search#SearchDefinitions(lang, keyword)
    3              0.000001   endif
                            
    3              0.000007   if g:any_jump_references_enabled || len(ib.definitions_grep_results) == 0
    3              0.000003     let ib.usages_opened       = v:true
    3   0.043809   0.000018     let usages_grep_results    = search#SearchUsages(ib)
    3              0.000004     let ib.usages_grep_results = []
                            
                                " filter out results found in definitions
  255              0.000097     for result in usages_grep_results
  252              0.000702       if index(ib.definitions_grep_results, result) == -1
                                    " not effective? ( TODO: deletion is more memory effective)
  102              0.000092         call add(ib.usages_grep_results, result)
  252              0.000058       endif
  255              0.000057     endfor
    3              0.000001   endif
                            
                              " assign any-jump internal buffer to current tab
    3              0.000190   let t:any_jump = ib
                            
    3   0.040760   0.000016   call s:CreateUi(ib)

FUNCTION  <lambda>1256()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/cmdline.vim:799
Called 1 time
Total time:   0.000024
 Self time:   0.000009

count  total (s)   self (s)
                            return wilder#resolve(ctx, { 'value': xs, 'pos': a:res.pos, 'data': s:convert_result_to_data(a:res), })

FUNCTION  <lambda>1257()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/pipeline.vim:171
Called 1 time
Total time:   0.000034
 Self time:   0.000004

count  total (s)   self (s)
                            return s:wait_start(l:state, ctx)

FUNCTION  <lambda>928()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/pipe/branch.vim:38
Called 1 time
Total time:   0.000017
 Self time:   0.000003

count  total (s)   self (s)
                            return s:on_finish(a:state, ctx, x)

FUNCTION  <SNR>58_clamp()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer/popupmenu.vim:818
Called 34 times
Total time:   0.000141
 Self time:   0.000141

count  total (s)   self (s)
   34              0.000022   if a:value < 1
   12              0.000005     return 1
   22              0.000006   endif
                            
   22              0.000031   let l:max = a:is_height ? (&lines - 1) : &columns
   22              0.000014   if a:value > l:max
                                return l:max
   22              0.000005   endif
                            
   22              0.000012   return a:value

FUNCTION  wilder#cmdline#get_fuzzy_completion()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/cmdline.vim:261
Called 4 times
Total time:   0.000921
 Self time:   0.000159

count  total (s)   self (s)
                              " Use tag-regexp to get fuzzy completions from taglist()
    4              0.000003   if a:res.expand ==# 'tags'
                                let l:fuzzy_char = get(a:res, 'fuzzy_char', '')
                            
                                if empty(l:fuzzy_char)
                                  let a:res.expand_arg = '.'
                                else
                                  let a:res.expand_arg = '/'
                                  if toupper(l:fuzzy_char) !=# l:fuzzy_char
                                    let a:res.expand_arg .= '\c'
                                  endif
                            
                                  if a:fuzzy_mode == 1
                                    let a:res.expand_arg .= '^'
                                  endif
                            
                                  let a:res.expand_arg .= l:fuzzy_char
                                endif
                            
                                return a:getcompletion(a:ctx, a:res)
    4              0.000001   endif
                            
                              " If argument is empty, use normal completions
                              " Don't fuzzy complete for vim help since a maximum of 300 help tags are returned
    4              0.000007   if a:res.pos == len(a:res.cmdline) || (a:res.expand ==# 'help' && !a:use_python)
    2   0.000610   0.000010     return a:getcompletion(a:ctx, a:res)
    2              0.000000   endif
                            
    2              0.000004   let l:fuzzy_char = get(a:res, 'fuzzy_char', '')
                            
                              " Keep leading . in file expansion to search hidden directories
    2              0.000004   if a:fuzzy_mode == 2 && !(wilder#cmdline#is_file_expansion(a:res.expand) && l:fuzzy_char ==# '.')
                                let l:fuzzy_char = ''
    2              0.000000   endif
                            
    2              0.000004   if toupper(l:fuzzy_char) ==# l:fuzzy_char
                                let a:res.expand_arg = a:res.expand_arg . l:fuzzy_char
                                return a:getcompletion(a:ctx, a:res)
    2              0.000000   endif
                            
    2              0.000005   let l:lower_res = copy(a:res)
    2              0.000003   let l:lower_res.expand_arg = a:res.expand_arg . l:fuzzy_char
                            
    2              0.000004   let l:upper_res = copy(a:res)
    2              0.000003   let l:upper_res.expand_arg = a:res.expand_arg . toupper(l:fuzzy_char)
                            
    2   0.000208   0.000046   return wilder#wait(a:getcompletion(a:ctx, l:upper_res), {ctx, upper_xs -> wilder#resolve(ctx, wilder#wait(a:getcompletion(ctx, l:lower_res), {ctx, lower_xs -> wilder#resolve(ctx, wilder#uniq_filt(0, 0, lower_xs + upper_xs))}))})

FUNCTION  <lambda>921()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/pipe/branch.vim:5
Called 1 time
Total time:   0.000154
 Self time:   0.000004

count  total (s)   self (s)
                            return s:branch(a:args, ctx, x)

FUNCTION  <lambda>923()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/pipeline.vim:105
Called 1 time
Total time:   0.008795
 Self time:   0.000004

count  total (s)   self (s)
                            return s:run(a:pipeline, a:on_finish, a:on_error, ctx, x, a:i)

FUNCTION  <SNR>114_add_definition()
    Defined: ~/.local/share/nvim/lazy/any-jump.vim/autoload/lang_map.vim:12
Called 244 times
Total time:   0.000919
 Self time:   0.000919

count  total (s)   self (s)
  244              0.000256   if !has_key(s:definitions, a:lang)
   55              0.000064     let s:definitions[a:lang] = []
  244              0.000065   endif
                            
  244              0.000312   call add(s:definitions[a:lang], a:definition)

FUNCTION  <SNR>53_scrollbar()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer/component/popupmenu_scrollbar.vim:17
Called 6 times
Total time:   0.000173
 Self time:   0.000173

count  total (s)   self (s)
    6              0.000008   let [l:start, l:end] = a:ctx.page
    6              0.000009   let l:num_candidates = len(a:result.value)
    6              0.000005   let l:height = a:ctx.height
                            
    6              0.000006   if l:num_candidates <= l:height
    2              0.000001     if a:state.collapse
    2              0.000001       return []
                                else
                                  return repeat([[a:state.scrollbar_chunk]], l:height)
                                endif
    4              0.000001   endif
                            
    4              0.000017   let l:thumb_start = float2nr(1.0 * l:start * l:height / l:num_candidates)
    4              0.000008   let l:thumb_size = float2nr(1.0 * l:height * l:height / l:num_candidates) + 1
    4              0.000005   let l:thumb_end = l:thumb_start + l:thumb_size
                            
                              " Due to floating point rounding, thumb can exceed height.
                              " Adjust the thumb back 1 row so that visually the thumb size remains fixed.
                              " The position of the thumb will be wrong but the fixed thumb size is more
                              " important.
    4              0.000003   if l:thumb_end > l:height
                                let l:thumb_start -= 1
                                let l:thumb_end -= 1
    4              0.000001   endif
                            
                              " Adjust case where rounding causes l:thumb_size to equal l:height.
    4              0.000003   if l:thumb_size == l:height
                                let l:thumb_size -= 1
                            
                                if l:end < l:num_candidates - 1
                                  let l:thumb_end -= 1
                                else
                                  let l:thumb_start += 1
                                endif
    4              0.000001   endif
                            
    4              0.000004   let l:thumb_chunk = a:state.thumb_chunk
    4              0.000005   let l:scrollbar_chunk = a:state.scrollbar_chunk
                            
    4              0.000010   let l:before_thumb_chunks = repeat([[l:scrollbar_chunk]], l:thumb_start)
    4              0.000008   let l:thumb_chunks = repeat([[l:thumb_chunk]], l:thumb_size)
    4              0.000010   let l:after_thumb_chunks = repeat([[l:scrollbar_chunk]], l:height - l:thumb_end)
                            
    4              0.000009   return l:before_thumb_chunks + l:thumb_chunks + l:after_thumb_chunks

FUNCTION  <lambda>930()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/pipe/branch.vim:5
Called 1 time
Total time:   0.000652
 Self time:   0.000003

count  total (s)   self (s)
                            return s:branch(a:args, ctx, x)

FUNCTION  <lambda>938()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/pipe/branch.vim:38
Called 1 time
Total time:   0.000018
 Self time:   0.000003

count  total (s)   self (s)
                            return s:on_finish(a:state, ctx, x)

FUNCTION  <SNR>58_post_hook()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer/popupmenu.vim:698
Called 2 times
Total time:   0.000931
 Self time:   0.000434

count  total (s)   self (s)
    2   0.000272   0.000018   call a:state.api.hide()
                            
   26              0.000083   for l:Component in [a:state.empty_message, a:state.error_message] + a:state.left + a:state.right + a:state.top + a:state.bottom
   24   0.000458   0.000215     call wilder#renderer#call_component_post_hook(a:ctx, l:Component)
   26              0.000086   endfor
                            
    2              0.000011   call timer_stop(a:state.empty_message_first_draw_timer)
                            
    2              0.000003   let a:state.active = 0

FUNCTION  <lambda>4()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer/component/popupmenu_devicons.vim:20
Called 6 times
Total time:   0.000079
 Self time:   0.000028

count  total (s)   self (s)
                            return s:devicons(l:state, ctx, result)

FUNCTION  <lambda>5()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer/component/popupmenu_scrollbar.vim:13
Called 6 times
Total time:   0.000211
 Self time:   0.000038

count  total (s)   self (s)
                            return s:scrollbar(l:state, ctx, result)

FUNCTION  <SNR>77_LocalBrowse()
    Defined: /opt/homebrew/Cellar/neovim/0.10.1/share/nvim/runtime/plugin/netrwPlugin.vim:105
Called 6 times
Total time:   0.000154
 Self time:   0.000154

count  total (s)   self (s)
                              " Unfortunate interaction -- only DechoMsg debugging calls can be safely used here.
                              " Otherwise, the BufEnter event gets triggered when attempts to write to
                              " the DBG buffer are made.
                            
    6              0.000009   if !exists("s:vimentered")
                               " If s:vimentered doesn't exist, then the VimEnter event hasn't fired.  It will,
                               " and so s:VimEnter() will then be calling this routine, but this time with s:vimentered defined.
                            "   call Dfunc("s:LocalBrowse(dirname<".a:dirname.">)  (s:vimentered doesn't exist)")
                            "   call Dret("s:LocalBrowse")
                               return
    6              0.000002   endif
                            
                            "  call Dfunc("s:LocalBrowse(dirname<".a:dirname.">)  (s:vimentered=".s:vimentered.")")
                            
    6              0.000014   if has("amiga")
                               " The check against '' is made for the Amiga, where the empty
                               " string is the current directory and not checking would break
                               " things such as the help command.
                            "   call Decho("(LocalBrowse) dirname<".a:dirname.">  (isdirectory, amiga)")
                               if a:dirname != '' && isdirectory(a:dirname)
                                sil! call netrw#LocalBrowseCheck(a:dirname)
                                if exists("w:netrw_bannercnt") && line('.') < w:netrw_bannercnt
                                 exe w:netrw_bannercnt
                                endif
                               endif
                            
    6              0.000026   elseif isdirectory(a:dirname)
                            "   call Decho("(LocalBrowse) dirname<".a:dirname."> ft=".&ft."  (isdirectory, not amiga)")
                            "   call Dredir("LocalBrowse ft last set: ","verbose set ft")
                               " Jul 13, 2021: for whatever reason, preceding the following call with
                               " a   sil!  causes an unbalanced if-endif vim error
                               call netrw#LocalBrowseCheck(a:dirname)
                               if exists("w:netrw_bannercnt") && line('.') < w:netrw_bannercnt
                                exe w:netrw_bannercnt
                               endif
                            
    6              0.000002   else
                               " not a directory, ignore it
                            "   call Decho("(LocalBrowse) dirname<".a:dirname."> not a directory, ignoring...")
    6              0.000002   endif
                            
                            "  call Dret("s:LocalBrowse")

FUNCTION  wilder#cmdline#prepare_user_completion()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/cmdline.vim:617
Called 4 times
Total time:   0.000038
 Self time:   0.000027

count  total (s)   self (s)
    4   0.000031   0.000020   if !wilder#cmdline#is_user_command(a:res.cmd)
    4              0.000003     return [0, 0, a:res]
                              endif
                            
                              if !has('nvim')
                                return [1, v:true, a:res]
                              endif
                            
                              if a:ctx.session_id > s:cached_commands_session_id
                                let s:cached_commands_session_id = a:ctx.session_id
                                let s:cached_user_commands = extend(nvim_get_commands({}), nvim_buf_get_commands(0, {}))
                                let s:has_completion_error = {}
                              endif
                            
                              " Calling getcompletion() interferes with wildmenu command completion so
                              " we return v:true early
                              if has_key(s:has_completion_error, a:res.cmd)
                                let l:res = copy(a:res)
                                let l:res.pos = 0
                                return [1, v:true, l:res]
                              endif
                            
                              if has_key(s:cached_user_commands, a:res.cmd)
                                let l:command = a:res.cmd
                              else
                                " Command might be a partial name
                                let l:matches = getcompletion(a:res.cmd, 'command')
                            
                                " 2 or more matches indicates command is ambiguous
                                if len(l:matches) >= 2
                                  throw "Ambiguous use of user-defined command, possible matches: " . string(l:matches)
                                elseif len(l:matches) == 0
                                  return [1, [], a:res, 0]
                                endif
                            
                                let l:command = l:matches[0]
                              endif
                            
                              let l:user_command = s:cached_user_commands[l:command]
                            
                              if has_key(l:user_command, 'complete_arg') && l:user_command.complete_arg isnot v:null
                            
                                " Find last argument by looking for the last whitespace character
                                let l:pos = len(a:res.cmdline)
                                while l:pos >= a:res.pos
                                  if a:res.cmdline[l:pos] ==# ' ' || a:res.cmdline[l:pos] ==# "\t"
                                    break
                                  endif
                            
                                  let l:pos -= 1
                                endwhile
                            
                                let l:arg = a:res.cmdline[l:pos+1 :]
                            
                                try
                                  let l:function_name = l:user_command.complete_arg
                                  if l:function_name[:1] ==# 's:'
                                    let l:function_name = '<SNR>' . l:user_command.script_id . '_' . l:function_name[2:]
                                  elseif l:function_name[:4] ==? '<SID>'
                                    let l:function_name = '<SNR>' . l:user_command.script_id . '_' . l:function_name[5:]
                                  endif
                            
                                  let l:Completion_func = function(l:function_name)
                                  let l:result = l:Completion_func(l:arg, a:res.cmdline, len(a:res.cmdline))
                                catch
                                  " Add both the full command and partial command
                                  let s:has_completion_error[l:command] = 1
                                  let s:has_completion_error[a:res.cmd] = 1
                            
                                  let l:res = copy(a:res)
                                  let l:res.pos = 0
                                  return [1, v:true, l:res]
                                endtry
                            
                                let l:is_custom_list = get(l:user_command, 'complete', '') ==# 'customlist'
                                if !l:is_custom_list
                                  let l:result = split(l:result, '\n')
                                endif
                            
                                let l:res = copy(a:res)
                                let l:res.pos = l:pos
                                let l:res.match_arg = l:arg
                                if !l:is_custom_list
                                  let l:res.arg = l:arg
                                endif
                            
                                return [1, l:result, l:res, !l:is_custom_list]
                              endif
                            
                              if has_key(l:user_command, 'complete') && l:user_command['complete'] isnot v:null && l:user_command['complete'] !=# 'custom' && l:user_command['complete'] !=# 'customlist'
                                let l:res = copy(a:res)
                                let l:res['expand'] = l:user_command['complete']
                            
                                return [0, 0, l:res]
                              endif
                            
                              return [1, v:false, a:res]

FUNCTION  <lambda>1241()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/pipe/branch.vim:38
Called 1 time
Total time:   0.000030
 Self time:   0.000003

count  total (s)   self (s)
                            return s:on_finish(a:state, ctx, x)

FUNCTION  <SNR>62_convert_result_to_data()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/cmdline.vim:753
Called 4 times
Total time:   0.000053
 Self time:   0.000053

count  total (s)   self (s)
    4              0.000014   let l:data = { 'pos': a:res.pos, 'cmdline.command': a:res.cmd, 'cmdline.expand': a:res.expand, 'cmdline.arg': a:res.arg, }
                            
    4              0.000005   if has_key(a:res, 'path_prefix')
                                let l:data['cmdline.path_prefix'] = a:res.path_prefix
    4              0.000001   endif
                            
    4              0.000004   if has_key(a:res, 'match_arg')
    4              0.000007     let l:data['cmdline.match_arg'] = a:res.match_arg
    4              0.000001   endif
                            
    4              0.000004   if has_key(a:res, 'has_wildcard')
                                let l:data['cmdline.has_wildcard'] = a:res.has_wildcard
    4              0.000001   endif
                            
    4              0.000002   return l:data

FUNCTION  <SNR>54_prompt_update_cursor()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer/popupmenu_palette_theme.vim:423
Called 65 times
Total time:   0.001143
 Self time:   0.001143

count  total (s)   self (s)
   65              0.000540   let l:cmdpos = getcmdpos()
                            
   65              0.000210   if a:state.cmdpos != l:cmdpos
                                call wilder#main#draw()
   65              0.000071   endif

FUNCTION  <lambda>940()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/cmdline.vim:793
Called 1 time
Total time:   0.000338
 Self time:   0.000008

count  total (s)   self (s)
                            return wilder#cmdline#get_fuzzy_completion( ctx, x, l:Completion_func, a:fuzzy, a:use_python)

FUNCTION  <lambda>941()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/cmdline.vim:799
Called 1 time
Total time:   0.000028
 Self time:   0.000011

count  total (s)   self (s)
                            return wilder#resolve(ctx, { 'value': xs, 'pos': a:res.pos, 'data': s:convert_result_to_data(a:res), })

FUNCTION  lang_map#find_definitions()
    Defined: ~/.local/share/nvim/lazy/any-jump.vim/autoload/lang_map.vim:20
Called 3 times
Total time:   0.000028
 Self time:   0.000022

count  total (s)   self (s)
    3   0.000019   0.000013   if !lang_map#lang_exists(a:language)
                                return
    3              0.000001   endif
                            
    3              0.000003   return s:definitions[a:language]

FUNCTION  <lambda>943()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/pipeline.vim:105
Called 1 time
Total time:   0.000291
 Self time:   0.000018

count  total (s)   self (s)
                            return s:run(a:pipeline, a:on_finish, a:on_error, ctx, x, a:i)

FUNCTION  <lambda>110()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/cmdline.vim:1161
Called 4 times
Total time:   0.000160
 Self time:   0.000026

count  total (s)   self (s)
                            return wilder#cmdline#prepare_getcompletion(ctx, res, l:fuzzy, l:use_python)

FUNCTION  <lambda>111()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/cmdline.vim:1161
Called 4 times
Total time:   0.001179
 Self time:   0.000035

count  total (s)   self (s)
                            return s:getcompletion(ctx, res, l:fuzzy, l:use_python)

FUNCTION  <lambda>112()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/cmdline.vim:1161
Called 4 times
Total time:   0.000104
 Self time:   0.000016

count  total (s)   self (s)
                            return l:Filter(     ctx, xs, get(data, 'cmdline.match_arg', ''))

FUNCTION  <lambda>113()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/pipe/result.vim:2
Called 4 times
Total time:   0.000415
 Self time:   0.000022

count  total (s)   self (s)
                            return s:result_start(l:args, ctx, x)

FUNCTION  <lambda>114()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder.vim:201
Called 4 times
Total time:   0.000431
 Self time:   0.000016

count  total (s)   self (s)
                            return a:p(ctx, x)

FUNCTION  <lambda>118()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/pipe/result.vim:2
Called 4 times
Total time:   0.000260
 Self time:   0.000019

count  total (s)   self (s)
                            return s:result_start(l:args, ctx, x)

FUNCTION  <lambda>119()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/cmdline.vim:1177
Called 4 times
Total time:   0.000003
 Self time:   0.000003

count  total (s)   self (s)
                            return res.expand ==# 'lua'

FUNCTION  <lambda>10()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer/popupmenu_border_theme.vim:96
Called 6 times
Total time:   0.000291
 Self time:   0.000048

count  total (s)   self (s)
                            return s:make_top_or_bottom_border(ctx, 1, a:border_chars)

FUNCTION  <lambda>11()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer/popupmenu_border_theme.vim:99
Called 6 times
Total time:   0.000306
 Self time:   0.000075

count  total (s)   self (s)
                            return s:make_top_or_bottom_border(ctx, 0, a:border_chars)

FUNCTION  <lambda>15()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer/popupmenu_palette_theme.vim:118
Called 6 times
Total time:   0.001083
 Self time:   0.000041

count  total (s)   self (s)
                            return s:prompt(a:state, ctx, result)

FUNCTION  <lambda>16()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer/popupmenu_palette_theme.vim:118
Called 2 times
Total time:   0.000037
 Self time:   0.000010

count  total (s)   self (s)
                            return s:prompt_pre_hook(a:state)

FUNCTION  <lambda>17()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer/popupmenu_palette_theme.vim:118
Called 2 times
Total time:   0.000036
 Self time:   0.000021

count  total (s)   self (s)
                            return s:prompt_post_hook(a:state)

FUNCTION  <lambda>18()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer/popupmenu_palette_theme.vim:118
Called 6 times
Total time:   0.000045
 Self time:   0.000027

count  total (s)   self (s)
                            return s:prompt_pre_draw(a:state)

FUNCTION  <lambda>19()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer/popupmenu_border_theme.vim:116
Called 6 times
Total time:   0.001327
 Self time:   0.000056

count  total (s)   self (s)
                            return s:wrap_string_or_func_with_border(ctx, result, l:Value, a:left, a:right)

FUNCTION  <SNR>38_vm_persist()
    Defined: ~/.local/share/nvim/lazy/vim-visual-multi/plugin/visual-multi.vim:82
Called 1 time
Total time:   0.000007
 Self time:   0.000007

count  total (s)   self (s)
    1              0.000002   if exists('g:VM_PERSIST') && !g:VM_persistent_registers
                                unlet g:VM_PERSIST
    1              0.000001   elseif g:VM_persistent_registers
                                let g:VM_PERSIST = deepcopy(g:Vm.registers)
    1              0.000000   endif

FUNCTION  wilder#cmdline#is_file_expansion()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/cmdline.vim:600
Called 4 times
Total time:   0.000014
 Self time:   0.000014

count  total (s)   self (s)
    4              0.000012   return a:expand ==# 'file' || a:expand ==# 'file_in_path' || a:expand ==# 'dir' || a:expand ==# 'shellcmd' || a:expand ==# 'user'

FUNCTION  <SNR>111_call()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/pipeline.vim:95
Called 20 times
Total time:   0.010218
 Self time:   0.000209

count  total (s)   self (s)
   20              0.000036   let a:ctx.handler_id = a:handler_id
                            
   20              0.000010   try
   20   0.010112   0.000103     call a:f(a:ctx)
                              catch
                                call wilder#reject(a:ctx, 'pipeline: ' . v:exception)
   20              0.000008   endtry

FUNCTION  <lambda>120()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/pipe/check.vim:1
Called 4 times
Total time:   0.000049
 Self time:   0.000017

count  total (s)   self (s)
                            return s:check(a:args, ctx, x)

FUNCTION  <lambda>129()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/pipe/branch.vim:5
Called 4 times
Total time:   0.000010
 Self time:   0.000010

count  total (s)   self (s)
                            return {ctx -> s:branch(a:args, ctx, x)}

FUNCTION  <lambda>20()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer/popupmenu_border_theme.vim:96
Called 6 times
Total time:   0.000309
 Self time:   0.000043

count  total (s)   self (s)
                            return s:make_top_or_bottom_border(ctx, 1, a:border_chars)

FUNCTION  <lambda>21()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer/popupmenu_palette_theme.vim:456
Called 6 times
Total time:   0.000083
 Self time:   0.000033

count  total (s)   self (s)
                            return s:get_middle_position(ctx, dimensions, a:is_top)

FUNCTION  <SNR>10_current_file()
    Defined: ~/.local/share/nvim/lazy/vim-rooter/plugin/rooter.vim:246
Called 9 times
Total time:   0.000257
 Self time:   0.000257

count  total (s)   self (s)
    9              0.000131   let fn = expand('%:p', 1)
    9              0.000077   if fn =~ 'NERD_tree_\d\+$' | let fn = b:NERDTree.root.path.str().'/' | endif
    9              0.000019   if fn[:5] == 'oil://' | let fn = fn[5:] | endif
    9              0.000016   if g:rooter_resolve_links | let fn = resolve(fn) | endif
    9              0.000007   return fn

FUNCTION  <SNR>102_Attach()
    Defined: ~/.local/share/nvim/lazy/copilot.vim/autoload/copilot.vim:438
Called 3 times
Total time:   0.023199
 Self time:   0.000041

count  total (s)   self (s)
    3              0.000002   try
    3   0.023181   0.000024     return copilot#Client().Attach(a:bufnr)
                              catch
                                call copilot#logger#Exception()
    3              0.000004   endtry

FUNCTION  <SNR>61_clear_all_highlights()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer/nvim_api.vim:255
Called 6 times
Total time:   0.000090
 Self time:   0.000090

count  total (s)   self (s)
    6              0.000010   if !bufexists(self.state.buf)
                                return
    6              0.000002   endif
                            
    6              0.000073   call nvim_buf_clear_namespace(self.state.buf, self.state.ns_id, 0, -1)

FUNCTION  <lambda>132()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder.vim:198
Called 4 times
Total time:   0.000001
 Self time:   0.000001

count  total (s)   self (s)
                            return x

FUNCTION  <lambda>135()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder.vim:198
Called 4 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                            return x

FUNCTION  <lambda>136()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/cmdline.vim:1367
Called 4 times
Total time:   0.000005
 Self time:   0.000005

count  total (s)   self (s)
                            return getcmdtype() ==# ':'

FUNCTION  <lambda>137()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/pipe/check.vim:1
Called 4 times
Total time:   0.000082
 Self time:   0.000019

count  total (s)   self (s)
                            return s:check(a:args, ctx, x)

FUNCTION  <lambda>138()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/cmdline.vim:1367
Called 4 times
Total time:   0.002996
 Self time:   0.000015

count  total (s)   self (s)
                            return wilder#cmdline#parse(x)

FUNCTION  wilder#main#get_candidate()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/main.vim:599
Called 110 times
Total time:   0.000143
 Self time:   0.000143

count  total (s)   self (s)
  110              0.000119   return a:result.value[a:index]

FUNCTION  copilot#OnBufUnload()
    Defined: ~/.local/share/nvim/lazy/copilot.vim/autoload/copilot.vim:484
Called 20 times
Total time:   0.000004
 Self time:   0.000004

count  total (s)   self (s)

FUNCTION  <SNR>56_make_top_or_bottom_border()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer/popupmenu_border_theme.vim:155
Called 18 times
Total time:   0.000740
 Self time:   0.000740

count  total (s)   self (s)
   18              0.000035   let l:left = a:is_top ? a:border_chars[0] : a:border_chars[5]
   18              0.000027   let l:middle = a:is_top ? a:border_chars[1] : a:border_chars[6]
   18              0.000023   let l:right = a:is_top ? a:border_chars[2] : a:border_chars[7]
                            
   18              0.000026   let l:left_width = strdisplaywidth(l:left)
   18              0.000025   let l:middle_width = strdisplaywidth(l:middle)
   18              0.000023   let l:right_width = strdisplaywidth(l:right)
                            
   18              0.000031   let l:expected_middle_width = a:ctx.width - l:left_width - l:right_width
   18              0.000030   let l:middle_repeat =  l:expected_middle_width / l:middle_width
   18              0.000014   if l:middle_repeat < 0
                                let l:middle_repeat = 0
   18              0.000005   endif
                            
   18              0.000044   let l:middle_str = repeat(l:middle, l:middle_repeat)
   18              0.000107   let l:actual_middle_width = strdisplaywidth(l:middle_str)
   18              0.000020   if l:actual_middle_width < l:expected_middle_width
                                let l:middle_chars = split(l:middle, '\zs')
                            
                                let l:i = 0
                                for l:char in l:middle_chars
                                  let l:new_middle_width = l:actual_middle_width + strdisplaywidth(l:char)
                            
                                  if l:new_middle_width > l:expected_middle_width
                                    break
                                  endif
                            
                                  let l:middle_str .= l:char
                                  let l:actual_middle_width = l:new_middle_width
                                endfor
                            
                                let l:middle_str .= repeat(' ', l:expected_middle_width - l:actual_middle_width)
   18              0.000005   endif
                            
   18              0.000020   let l:border_hl = a:ctx.highlights.border
   18              0.000030   let l:middle_hl = a:is_top ? l:border_hl : a:ctx.highlights.bottom_border
                            
   18              0.000042   return [[l:left, l:border_hl], [l:middle_str, l:middle_hl], [l:right, l:border_hl]]

FUNCTION  wilder#cmdline#main#do()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/cmdline/main.vim:36
Called 2 times
Total time:   0.001405
 Self time:   0.000320

count  total (s)   self (s)
                              " default
    2              0.000002   let a:ctx.expand = 'command'
    2              0.000002   let a:ctx.force = 0
                            
    2              0.000004   if empty(a:ctx.cmdline[a:ctx.pos :])
    1              0.000000     return
    1              0.000000   endif
                            
    1   0.000024   0.000006   if !wilder#cmdline#main#skip_whitespace(a:ctx)
                                return
    1              0.000000   endif
                            
                              " check if comment
    1              0.000001   if a:ctx.cmdline[a:ctx.pos] ==# '"'
                                let a:ctx.pos = len(a:ctx.cmdline)
                                let a:ctx.expand = 'nothing'
                                return
    1              0.000000   endif
                            
                              " skip range
    1   0.001236   0.000204   call wilder#cmdline#skip_range#do(a:ctx)
                            
    1   0.000040   0.000005   if !wilder#cmdline#main#skip_whitespace(a:ctx)
                                return
    1              0.000000   endif
                            
    1              0.000001   if a:ctx.cmdline[a:ctx.pos] ==# '"'
                                let a:ctx.pos = len(a:ctx.cmdline)
                                let a:ctx.expand = 'nothing'
                                return
    1              0.000000   endif
                            
                              " check if starts with | or :
                              " treat as a new command
    1              0.000002   if a:ctx.cmdline[a:ctx.pos] ==# '|' || a:ctx.cmdline[a:ctx.pos] ==# ':'
                                let a:ctx.pos += 1
                                let a:ctx.cmd = ''
                            
                                call wilder#cmdline#main#do(a:ctx)
                            
                                return
    1              0.000000   endif
                            
    1              0.000001   let l:is_user_cmd = 0
                            
    1              0.000002   if a:ctx.cmdline[a:ctx.pos] ==# 'k' && a:ctx.cmdline[a:ctx.pos + 1] !=# 'e'
                                let a:ctx.cmd = 'k'
                                let a:ctx.pos += 1
                            
                                return
    1              0.000000   else
    1              0.000001     let l:cmd_start = a:ctx.pos
                            
    1              0.000001     let l:char = a:ctx.cmdline[a:ctx.pos]
                            
    1              0.000001     if l:char >=# 'A' && l:char <=# 'Z'
                                  " user-defined command can contain digits
                                  while l:char >=# 'a' && l:char <=# 'z' || l:char >=# 'A' && l:char <=# 'Z' || l:char >=# '0' && l:char <=# '9'
                                    let a:ctx.pos += 1
                                    let l:char = a:ctx.cmdline[a:ctx.pos]
                                  endwhile
                            
                                  let a:ctx.cmd = a:ctx.cmdline[l:cmd_start : a:ctx.pos - 1]
                                  let l:is_user_cmd = 1
    1              0.000000     else
                                  " non-alphabet command
    1              0.000002       if stridx('@*!=><&~#', l:char) != -1
                                    let a:ctx.pos += 1
                                    let l:char = a:ctx.cmdline[a:ctx.pos]
    1              0.000000       else
                                    " py3, python3, py3file and py3do are the only commands with numbers
                                    " all other commands are alphabet only
    1              0.000002         if a:ctx.cmdline[a:ctx.pos] ==# 'p' && a:ctx.cmdline[a:ctx.pos + 1] ==# 'y' && a:ctx.cmdline[a:ctx.pos + 2] ==# '3'
                                      let a:ctx.pos += 3
                                      let l:char = a:ctx.cmdline[a:ctx.pos]
    1              0.000000         endif
                            
                                    " this should check for [a-zA-Z] only, but the Vim implementation
                                    " skips over wildcards. This matters for commands which accept
                                    " non-alphanumeric arugments e.g. 'e*' would be parsed as an 'edit'
                                    " command with a '*' argument otherwise. These commands typically
                                    " don't need a space between the command and argument e.g. 'e++opt'
                                    " is a valid command.
    2              0.000004         while l:char >=# 'a' && l:char <=# 'z' || l:char >=# 'A' && l:char <=# 'Z' || l:char ==# '*'
    1              0.000001           let a:ctx.pos += 1
    1              0.000001           let l:char = a:ctx.cmdline[a:ctx.pos]
    2              0.000001         endwhile
    1              0.000000       endif
                            
    1              0.000001       if a:ctx.pos == l:cmd_start
                                    let a:ctx.expand = 'unsuccessful'
                                    return
    1              0.000000       endif
                            
                                  " find the command
    1              0.000001       if a:ctx.pos > l:cmd_start
    1              0.000002         let l:cmd = a:ctx.cmdline[l:cmd_start : a:ctx.pos - 1]
    1              0.000001         let l:len = a:ctx.pos - l:cmd_start
                            
    1              0.000001         let l:char = l:cmd[0]
    1              0.000001         if l:char < 'a' || l:char > 'z'
                                      let l:char = 'z'
    1              0.000000         endif
                            
    1              0.000002         let l:next_char = nr2char(char2nr(l:char) + 1)
                            
    1              0.000003         let l:i = s:command_char_pos[l:char]
    1              0.000003         let l:end = get(s:command_char_pos, 'l:next_char', len(s:commands))
                            
    1              0.000001         while l:i < l:end
    1              0.000005           let l:command = s:commands[l:i]
    1              0.000002           if l:cmd ==# l:command[: l:len - 1]
    1              0.000001             let a:ctx.cmd = l:command
    1              0.000001             break
                                      endif
                            
                                      let l:i += 1
    1              0.000001         endwhile
    1              0.000000       endif
    1              0.000000     endif
    1              0.000000   endif
                            
                              " cursor is touching command and ends in alpha-numeric character
                              " complete the command name
    1              0.000001   if a:ctx.pos == len(a:ctx.cmdline)
    1              0.000001     let l:char = a:ctx.cmdline[a:ctx.pos - 1]
                            
    1              0.000002     if l:char >=# 'a' && l:char <=# 'z' || l:char >=# 'A' && l:char <=# 'Z' || l:char >=# '0' && l:char <=# '9'
    1              0.000001       let a:ctx.pos = l:cmd_start
    1              0.000001       let a:ctx.cmd = ''
                                  " expand commands
    1              0.000001       return
                                endif
                              endif
                            
                              " no matching command found, treat as no arguments
                              if empty(a:ctx.cmd)
                                " 2 or 3-letter substitute command, takes no arguments
                                if a:ctx.cmdline[l:cmd_start] ==# 's' && stridx('cgriI', a:ctx.cmdline[l:cmd_start + 1]) != -1
                                  let a:ctx.cmd = 's'
                                endif
                            
                                let a:ctx.pos = len(a:ctx.cmdline)
                                let a:ctx.expand = 'nothing'
                                return
                              endif
                            
                              let a:ctx.expand = 'nothing'
                            
                              " handle !
                              if a:ctx.cmdline[a:ctx.pos] ==# '!'
                                let a:ctx.pos += 1
                                let a:ctx.force = 1
                              endif
                            
                              if has_key(s:command_modifiers, a:ctx.cmd)
                                let a:ctx.cmd = ''
                                let a:ctx.expand = ''
                            
                                call wilder#cmdline#main#do(a:ctx)
                            
                                return
                              endif
                            
                              call wilder#cmdline#main#skip_whitespace(a:ctx)
                            
                              let l:flags = get(s:command_flags, a:ctx.cmd, 0)
                            
                              let l:use_filter = 0
                            
                              if a:ctx.cmd ==# 'write' || a:ctx.cmd ==# 'update'
                                if a:ctx.cmdline[a:ctx.pos] ==# '>'
                                  if a:ctx.cmdline[a:ctx.pos + 1] ==# '>'
                                    let a:ctx.pos += 2
                                  endif
                            
                                  call wilder#cmdline#main#skip_whitespace(a:ctx)
                                endif
                            
                                if a:ctx.cmd ==# 'write' && a:ctx.cmdline[a:ctx.pos] ==# '!'
                                  let a:ctx.pos += 1
                                  let l:use_filter = 1
                                endif
                              elseif a:ctx.cmd ==# 'read'
                                if a:ctx.cmdline[a:ctx.pos] ==# '!'
                                  let a:ctx.pos += 1
                                  let l:use_filter = 1
                                else
                                  let l:use_filter = a:ctx.force
                                endif
                              elseif a:ctx.cmd ==# '<' || a:ctx.cmd ==# '>'
                                while a:ctx.cmdline[a:ctx.pos] ==# a:ctx.cmd
                                  let a:ctx.pos += 1
                                endwhile
                            
                                call wilder#cmdline#main#skip_whitespace(a:ctx)
                              endif
                            
                              " Handle +cmd or ++opt
                              if a:ctx.cmdline[a:ctx.pos] ==# '+' && ((and(l:flags, s:EDITCMD) && !l:use_filter) || and(l:flags, s:ARGOPT))
                                let l:allow_opt = 1
                                let l:allow_cmd = and(l:flags, s:EDITCMD) && !l:use_filter
                            
                                while a:ctx.cmdline[a:ctx.pos] ==# '+' && a:ctx.pos < len(a:ctx.cmdline)
                                  let a:ctx.pos += 1
                            
                                  if a:ctx.cmdline[a:ctx.pos] ==# '+'
                                    if l:allow_opt
                                      let a:ctx.pos += 1
                                      let l:expand = 'file_opt'
                                    else
                                      let l:expand = 'nothing'
                                    endif
                                  elseif l:allow_cmd
                                    let l:expand = 'command'
                                    " ++opt must be before +cmd
                                    let l:allow_opt = 0
                                    " only 1 +cmd allowed
                                    let l:allow_cmd = 0
                                  else
                                    let l:expand = 'nothing'
                                  endif
                            
                                  let l:arg_start = a:ctx.pos
                            
                                  " skip to next arg
                                  while a:ctx.pos < len(a:ctx.cmdline) && !wilder#cmdline#main#is_whitespace(a:ctx.cmdline[a:ctx.pos])
                                    if a:ctx.cmdline[a:ctx.pos] ==# '\' && a:ctx.pos + 1 < len(a:ctx.cmdline)
                                      let a:ctx.pos += 1
                                    endif
                            
                                    " TODO: multibyte
                                    let a:ctx.pos += 1
                                  endwhile
                            
                                  " still in command or option
                                  if empty(a:ctx.cmdline[a:ctx.pos])
                                    let a:ctx.pos = l:arg_start
                                    let a:ctx.expand = l:expand
                                    return
                                  endif
                            
                                  call wilder#cmdline#main#skip_whitespace(a:ctx)
                                endwhile
                            
                                if a:ctx.cmd ==# 'write' && a:ctx.cmdline[a:ctx.pos] ==# '!'
                                  let a:ctx.pos += 1
                                  let l:use_filter = 1
                                elseif a:ctx.cmd ==# 'read'
                                  if a:ctx.cmdline[a:ctx.pos] ==# '!'
                                    let a:ctx.pos += 1
                                    let l:use_filter = 1
                                  else
                                    let l:use_filter = a:ctx.force
                                  endif
                                endif
                              endif
                            
                              " look for | for new command and " for comment
                              if and(l:flags, s:TRLBAR) && !l:use_filter
                                if a:ctx.cmd ==# 'redir' && a:ctx.cmdline[a:ctx.pos] ==# '@' && a:ctx.cmdline[a:ctx.pos + 1] ==# '"'
                                  let a:ctx.pos += 2
                                endif
                            
                                let l:lookahead = a:ctx.pos
                                while l:lookahead < len(a:ctx.cmdline)
                                  if a:ctx.cmdline[l:lookahead] ==# "\<C-V>" || a:ctx.cmdline[l:lookahead] ==# '\'
                                    let l:lookahead += 1
                            
                                    if l:lookahead + 1 < len(a:ctx.cmdline)
                                      let l:lookahead += 1
                                    else
                                      break
                                    endif
                                  endif
                            
                                  " Check if " indicates a comment or start of string
                                  if a:ctx.cmdline[l:lookahead] ==# '"'
                                    let l:lookahead += 1
                            
                                    let l:end_quote_reached = 0
                                    " Consume until next char is " or end of cmdline is reached
                                    while l:lookahead < len(a:ctx.cmdline)
                                      if a:ctx.cmdline[l:lookahead] ==# '\'
                                        let l:lookahead += 1
                                      elseif a:ctx.cmdline[l:lookahead] ==# '"'
                                        let l:end_quote_reached = 1
                                        let l:lookahead += 1
                                        break
                                      endif
                            
                                      let l:lookahead += 1
                                    endwhile
                            
                                    " remaining part of cmdline is comment, treat as no arguments
                                    if !l:end_quote_reached
                                      let a:ctx.pos = len(a:ctx.cmdline)
                                      return
                                    endif
                            
                                  " start of new command
                                  elseif a:ctx.cmdline[l:lookahead] ==# '|'
                                    let a:ctx.pos = l:lookahead + 1
                                    let a:ctx.cmd = ''
                                    let a:ctx.expand = ''
                            
                                    call wilder#cmdline#main#do(a:ctx)
                            
                                    return
                                  endif
                            
                                  " TODO: multibyte
                                  let l:lookahead += 1
                                endwhile
                              endif
                            
                              " command does not take extra arguments
                              if !and(l:flags, s:EXTRA) && !l:is_user_cmd
                                " consume whitespace
                                call wilder#cmdline#main#skip_whitespace(a:ctx)
                            
                                " and check for | or "
                                if a:ctx.cmdline[a:ctx.pos] ==# '|'
                                  let a:ctx.pos += 1
                                  let a:ctx.cmd = ''
                                  let a:ctx.expand = ''
                            
                                  call wilder#cmdline#main#do(a:ctx)
                                  return
                                else
                                  " remaining part is either comment or invalid arguments
                                  " either way, treat as no arguments
                                  let a:ctx.pos = len(a:ctx.cmdline)
                                  let a:ctx.expand = 'nothing'
                                  return
                                endif
                              endif
                            
                            
                              if l:use_filter || a:ctx.cmd ==# '!' || a:ctx.cmd ==# 'terminal'
                                let l:before_args = a:ctx.pos
                            
                                if !wilder#cmdline#main#skip_nonwhitespace(a:ctx)
                                  let a:ctx.pos = l:before_args
                                  let a:ctx.expand = 'shellcmd'
                                  return
                                endif
                            
                                " Reset pos back to before_args
                                let a:ctx.pos = l:before_args
                              endif
                            
                              if and(l:flags, s:XFILE)
                                " TODO: handle backticks :h backtick-expansion
                            
                                let l:arg_start = a:ctx.pos
                            
                                " Check if completing $ENV
                                if a:ctx.cmdline[a:ctx.pos] ==# '$'
                                  let l:arg_start = a:ctx.pos
                                  let a:ctx.pos += 1
                            
                                  while a:ctx.pos < len(a:ctx.cmdline)
                                    let l:char = a:ctx.cmdline[a:ctx.pos]
                                    if !s:is_idc(l:char)
                                      break
                                    endif
                            
                                    let a:ctx.pos += 1
                                  endwhile
                            
                                  if a:ctx.pos == len(a:ctx.cmdline)
                                    let a:ctx.expand = 'environment'
                                    let a:ctx.pos = l:arg_start + 1
                                    return
                                  endif
                                endif
                            
                                " Check if completing ~user
                                if a:ctx.cmdline[a:ctx.pos] ==# '~'
                                  let l:allow_backslash = has('win32') || has('win64')
                            
                                  while a:ctx.pos < len(a:ctx.cmdline)
                                    let l:char = a:ctx.cmdline[a:ctx.pos]
                                    if l:char ==# '/' || l:allow_backslash && l:char ==# '\' || !s:is_filec(l:char)
                                      break
                                    endif
                            
                                    let a:ctx.pos += 1
                                  endwhile
                            
                                  " + 1 since we want to expand ~ to $HOME
                                  if a:ctx.pos == len(a:ctx.cmdline) && a:ctx.pos > l:arg_start + 1
                                    let a:ctx.expand = 'user'
                                    let a:ctx.pos = l:arg_start + 1
                                    return
                                  endif
                                endif
                            
                                let a:ctx.pos = l:arg_start
                                let a:ctx.expand = 'file'
                            
                                " vim assumes for XFILE, we can ignore arguments other than the last one but
                                " this is not necessarily true, we should not do this for NOSPC
                                if !and(l:flags, s:NOSPC)
                                  call s:move_pos_to_last_arg(a:ctx)
                                endif
                              endif
                            
                              if a:ctx.cmd ==# 'find' || a:ctx.cmd ==# 'sfind' || a:ctx.cmd ==# 'tabfind'
                                if a:ctx.expand ==# 'file'
                                  let a:ctx.expand = 'file_in_path'
                                endif
                                return
                              elseif a:ctx.cmd ==# 'cd' || a:ctx.cmd ==# 'chdir' || a:ctx.cmd ==# 'lcd' || a:ctx.cmd ==# 'lchdir' || a:ctx.cmd ==# 'tcd' || a:ctx.cmd ==# 'tchdir'
                                if a:ctx.expand ==# 'file'
                                  let a:ctx.expand = 'dir'
                                endif
                                return
                              elseif a:ctx.cmd ==# 'help'
                                let a:ctx.expand = 'help'
                                return
                              " command modifiers
                              elseif has_key(s:command_modifiers, a:ctx.cmd)
                                let a:ctx.cmd = ''
                                let a:ctx.expand = ''
                            
                                call wilder#cmdline#main#do(a:ctx)
                            
                                return
                              elseif a:ctx.cmd ==# 'filter'
                                call wilder#cmdline#filter#do(a:ctx)
                                return
                              elseif a:ctx.cmd ==# 'match'
                                call wilder#cmdline#match#do(a:ctx)
                                return
                              elseif a:ctx.cmd ==# 'command'
                                call wilder#cmdline#command#do(a:ctx)
                                return
                              elseif a:ctx.cmd ==# 'delcommand'
                                let a:ctx.expand = 'user_commands'
                                return
                              elseif a:ctx.cmd ==# 'global' || a:ctx.cmd ==# 'vglobal'
                                call wilder#cmdline#global#do(a:ctx)
                                return
                              elseif a:ctx.cmd ==# '&' || a:ctx.cmd ==# 'substitute'
                                call wilder#cmdline#substitute#do(a:ctx)
                                return
                              elseif a:ctx.cmd ==# 'isearch' || a:ctx.cmd ==# 'dsearch' || a:ctx.cmd ==# 'ilist' || a:ctx.cmd ==# 'dlist' || a:ctx.cmd ==# 'ijump' || a:ctx.cmd ==# 'psearch' || a:ctx.cmd ==# 'djump' || a:ctx.cmd ==# 'isplit' || a:ctx.cmd ==# 'dsplit'
                                call wilder#cmdline#isearch#do(a:ctx)
                                return
                              elseif a:ctx.cmd ==# 'autocmd'
                                call wilder#cmdline#autocmd#do(a:ctx, 0)
                                return
                              elseif a:ctx.cmd ==# 'doautocmd' || a:ctx.cmd ==# 'doautoall'
                                call wilder#cmdline#autocmd#do(a:ctx, 1)
                              elseif a:ctx.cmd ==# 'set' || a:ctx.cmd ==# 'setglobal' || a:ctx.cmd ==# 'setlocal'
                                call wilder#cmdline#set#do(a:ctx)
                                return
                              elseif a:ctx.cmd ==# 'tag' || a:ctx.cmd ==# 'stag' || a:ctx.cmd ==# 'ptag' || a:ctx.cmd ==# 'ltag' || a:ctx.cmd ==# 'tselect' || a:ctx.cmd ==# 'stselect' || a:ctx.cmd ==# 'tjump' || a:ctx.cmd ==# 'stjump' || a:ctx.cmd ==# 'ptselect' || a:ctx.cmd ==# 'ptjump'
                                let a:ctx.expand = 'tags'
                                return
                              elseif a:ctx.cmd ==# 'augroup'
                                let a:ctx.expand = 'augroup'
                              elseif a:ctx.cmd ==# 'syntax'
                                call wilder#cmdline#syntax#do(a:ctx)
                                return
                              elseif a:ctx.cmd ==# 'let' || a:ctx.cmd ==# 'if' || a:ctx.cmd ==# 'elseif' || a:ctx.cmd ==# 'while' || a:ctx.cmd ==# 'for' || a:ctx.cmd ==# 'echo' || a:ctx.cmd ==# 'echon' || a:ctx.cmd ==# 'execute' || a:ctx.cmd ==# 'echomsg' || a:ctx.cmd ==# 'echoerr' || a:ctx.cmd ==# 'call' || a:ctx.cmd ==# 'return' || a:ctx.cmd ==# 'cexpr' || a:ctx.cmd ==# 'caddexpr' || a:ctx.cmd ==# 'cgetexpr' || a:ctx.cmd ==# 'lexpr' || a:ctx.cmd ==# 'laddexpr' || a:ctx.cmd ==# 'lgetexpr'
                                "TODO call has extra arugments
                                call wilder#cmdline#let#do(a:ctx)
                                return
                              elseif a:ctx.cmd ==# 'unlet'
                                call wilder#cmdline#unlet#do(a:ctx)
                                return
                              elseif a:ctx.cmd ==# 'function'
                                let a:ctx.expand = 'function'
                                return
                              elseif a:ctx.cmd ==# 'delfunction'
                                let a:ctx.expand = 'user_func'
                                return
                              elseif a:ctx.cmd ==# 'echohl'
                                let a:ctx.expand = 'highlight'
                                " TODO: include None
                                return
                              elseif a:ctx.cmd ==# 'highlight'
                                call wilder#cmdline#highlight#do(a:ctx)
                                return
                              elseif a:ctx.cmd ==# 'cscope' || a:ctx.cmd ==# 'lcscope' || a:ctx.cmd ==# 'scscope'
                                call wilder#cmdline#cscope#do(a:ctx)
                                return
                              elseif a:ctx.cmd ==# 'sign'
                                call wilder#cmdline#sign#do(a:ctx)
                                return
                              elseif a:ctx.cmd ==# 'bdelete' || a:ctx.cmd ==# 'bwipeout' || a:ctx.cmd ==# 'bunload'
                                let a:ctx.expand = 'buffer'
                                return
                              elseif a:ctx.cmd ==# 'buffer' || a:ctx.cmd ==# 'sbuffer' || a:ctx.cmd ==# 'checktime'
                                let a:ctx.expand = 'buffer'
                                return
                              elseif a:ctx.cmd ==# 'abbreviate' || a:ctx.cmd ==# 'unabbreviate' || a:ctx.cmd[-3 :] ==# 'map' || a:ctx.cmd[-6 :] ==# 'abbrev'
                                call wilder#cmdline#map#do(a:ctx)
                                return
                              elseif a:ctx.cmd[-8 :] ==# 'mapclear'
                                let a:ctx.expand = 'mapclear'
                                return
                              elseif a:ctx.cmd[-4 :] ==# 'menu'
                                call wilder#cmdline#menu#do(a:ctx)
                                return
                              elseif a:ctx.cmd ==# 'colorscheme'
                                let a:ctx.expand = 'color'
                                return
                              elseif a:ctx.cmd ==# 'compiler'
                                let a:ctx.expand = 'compiler'
                                return
                              elseif a:ctx.cmd ==# 'ownsyntax'
                                let a:ctx.expand = 'ownsyntax'
                                return
                              elseif a:ctx.cmd ==# 'packadd'
                                let a:ctx.expand = 'packadd'
                                return
                              elseif a:ctx.cmd ==# 'language'
                                let l:arg_start = a:ctx.pos
                                call wilder#cmdline#main#skip_nonwhitespace(a:ctx)
                            
                                if a:ctx.pos == len(a:ctx.cmdline)
                                  let a:ctx.expand = 'language'
                                  let a:ctx.pos = l:arg_start
                                else
                                  let l:subcommand = a:ctx.cmdline[l:arg_start : a:ctx.pos - 1]
                                  if l:subcommand ==# 'messages' || l:subcommand ==# 'ctype' || l:subcommand ==# 'time'
                                    let a:ctx.expand = 'locales'
                                    call wilder#cmdline#main#skip_whitespace(a:ctx)
                                  endif
                                endif
                              elseif a:ctx.cmd ==# 'profile'
                                call wilder#cmdline#profile#do(a:ctx)
                                return
                              elseif a:ctx.cmd ==# 'checkhealth'
                                let a:ctx.expand = 'checkhealth'
                                call s:move_pos_to_last_arg(a:ctx)
                                return
                              elseif a:ctx.cmd ==# 'behave'
                                let a:ctx.expand = 'behave'
                                return
                              elseif a:ctx.cmd ==# 'messages'
                                let a:ctx.expand = 'messages'
                                return
                              elseif a:ctx.cmd ==# 'history'
                                let a:ctx.expand = 'history'
                                return
                              elseif a:ctx.cmd ==# 'syntime'
                                let a:ctx.expand = 'syntime'
                                return
                              elseif a:ctx.cmd ==# 'argdelete'
                                let a:ctx.expand = 'arglist'
                                return
                              elseif a:ctx.cmd ==# 'lua'
                                let a:ctx.expand = 'lua'
                                return
                              endif

FUNCTION  <lambda>140()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder.vim:198
Called 4 times
Total time:   0.000001
 Self time:   0.000001

count  total (s)   self (s)
                            return x

FUNCTION  <lambda>141()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder.vim:198
Called 4 times
Total time:   0.000001
 Self time:   0.000001

count  total (s)   self (s)
                            return x

FUNCTION  <lambda>142()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/cmdline.vim:1367
Called 4 times
Total time:   0.000064
 Self time:   0.000026

count  total (s)   self (s)
                            return wilder#cmdline#prepare_user_completion(ctx, res)

FUNCTION  <lambda>143()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/pipe/branch.vim:5
Called 4 times
Total time:   0.000018
 Self time:   0.000018

count  total (s)   self (s)
                            return {ctx -> s:branch(a:args, ctx, x)}

FUNCTION  <lambda>144()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/cmdline.vim:1367
Called 4 times
Total time:   0.000048
 Self time:   0.000035

count  total (s)   self (s)
                            return l:sort_buffers_lastused ? s:sort_buffers_lastused(ctx, xs, data) : xs

FUNCTION  <lambda>145()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/cmdline.vim:1367
Called 4 times
Total time:   0.000058
 Self time:   0.000016

count  total (s)   self (s)
                            return s:set_query(data)

FUNCTION  <lambda>146()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/pipe/result.vim:2
Called 4 times
Total time:   0.000492
 Self time:   0.000020

count  total (s)   self (s)
                            return s:result_start(l:args, ctx, x)

FUNCTION  <SNR>116_NewGrepResult()
    Defined: ~/.local/share/nvim/lazy/any-jump.vim/autoload/search.vim:321
Called 531 times
Total time:   0.000934
 Self time:   0.000934

count  total (s)   self (s)
  531              0.000841   return { "line_number": 0, "path": 0, "text": 0 }

FUNCTION  <SNR>60_combine_hl_list()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/highlight.vim:71
Called 4 times
Total time:   0.000181
 Self time:   0.000181

count  total (s)   self (s)
    4              0.000006   let l:term_hl = copy(a:l[0])
    4              0.000005   let l:cterm_hl = copy(a:l[1])
    4              0.000005   let l:gui_hl = copy(a:l[2])
                            
    4              0.000004   if len(l:term_hl) <= 2
    4              0.000005     let l:term_hl = copy(a:m[0])
                              else
                                let l:term_hl += a:m[0][2:]
    4              0.000001   endif
                            
    4              0.000006   let l:cterm_fg = get(a:m[1], 0, -1)
    4              0.000005   if l:cterm_fg isnot 'NONE' && l:cterm_fg isnot -1
                                if empty(l:cterm_hl)
                                  let l:cterm_hl = [l:cterm_fg]
                                else
                                  let l:cterm_hl[0] = l:cterm_fg
                                endif
    4              0.000001   endif
                            
    4              0.000005   let l:cterm_bg = get(a:m[1], 1, -1)
    4              0.000004   if l:cterm_bg isnot 'NONE' && l:cterm_bg isnot -1
                                if empty(l:cterm_hl)
                                  let l:cterm_hl = ['NONE', l:cterm_bg]
                                else
                                  let l:cterm_hl[1] = l:cterm_bg
                                endif
    4              0.000001   endif
                            
    4              0.000004   if len(a:m[1]) > 2
    4              0.000004     if empty(l:cterm_hl)
                                  let l:cterm_hl = ['NONE', 'NONE'] + a:m[1][2:]
    4              0.000001     else
    4              0.000007       let l:cterm_hl += a:m[1][2:]
    4              0.000001     endif
    4              0.000001   endif
                            
    4              0.000005   let l:gui_fg = get(a:m[2], 0, -1)
    4              0.000004   if l:gui_fg isnot 'NONE' && l:gui_fg isnot -1
                                if empty(l:gui_hl)
                                  let l:gui_hl = [l:gui_fg]
                                else
                                  let l:gui_hl[0] = l:gui_fg
                                endif
    4              0.000001   endif
                            
    4              0.000005   let l:gui_bg = get(a:m[2], 1, -1)
    4              0.000004   if l:gui_bg isnot 'NONE' && l:gui_bg isnot -1
                                if empty(l:gui_hl)
                                  let l:gui_hl = ['NONE', l:gui_bg]
                                else
                                  let l:gui_hl[1] = l:gui_bg
                                endif
    4              0.000001   endif
                            
    4              0.000004   if len(a:m[2]) > 2
    4              0.000003     if empty(l:gui_hl)
                                  let l:gui_hl = ['NONE', 'NONE'] + a:m[2][2:]
    4              0.000001     else
    4              0.000006       let l:gui_hl += a:m[2][2:]
    4              0.000001     endif
    4              0.000001   endif
                            
    4              0.000004   return [l:term_hl, l:cterm_hl, l:gui_hl]

FUNCTION  copilot#OnVimLeavePre()
    Defined: ~/.local/share/nvim/lazy/copilot.vim/autoload/copilot.vim:487
Called 1 time
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)

FUNCTION  <SNR>109_run_pipeline()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/main.vim:293
Called 4 times
Total time:   0.001058
 Self time:   0.000190

count  total (s)   self (s)
    4              0.000005   let s:run_id += 1
                            
    4              0.000012   let l:ctx = { 'input': a:input, 'run_id': s:run_id, 'session_id': s:session_id, }
                            
    4              0.000003   if a:0 > 0
                                call extend(l:ctx, a:1)
    4              0.000001   endif
                            
    4   0.001027   0.000159   call wilder#pipeline#run( s:opts.pipeline, function('wilder#main#on_finish'), function('wilder#main#on_error'), l:ctx, a:input, )

FUNCTION  <SNR>110_redraw()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer.vim:9
Called 6 times
Total time:   0.013353
 Self time:   0.013353

count  total (s)   self (s)
    6              0.000016   if a:apply_incsearch_fix && &incsearch && (getcmdtype() ==# '/' || getcmdtype() ==# '?')
                                call feedkeys("\<C-R>\<BS>", 'n')
                                return
    6              0.000002   endif
                            
    6              0.000004   if a:is_redrawstatus
                                redrawstatus
    6              0.000002   else
    6              0.013290     redraw
    6              0.000008   endif

FUNCTION  wilder#cmdline#main#skip_whitespace()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/cmdline/main.vim:683
Called 2 times
Total time:   0.000053
 Self time:   0.000044

count  total (s)   self (s)
    2              0.000003   if empty(a:ctx.cmdline[a:ctx.pos])
                                return 0
    2              0.000001   endif
                            
    2   0.000037   0.000029   while wilder#cmdline#main#is_whitespace(a:ctx.cmdline[a:ctx.pos])
                                let a:ctx.pos += 1
                            
                                if empty(a:ctx.cmdline[a:ctx.pos])
                                  return 0
                                endif
    2              0.000001   endwhile
                            
    2              0.000001   return 1

FUNCTION  <SNR>102_Start()
    Defined: ~/.local/share/nvim/lazy/copilot.vim/autoload/copilot.vim:45
Called 15 times
Total time:   0.000138
 Self time:   0.000089

count  total (s)   self (s)
   15   0.000121   0.000072   if s:Running() || exists('s:client.startup_error')
   15              0.000008     return
                              endif
                              let s:client = copilot#client#New({'editorConfiguration' : s:EditorConfiguration()})

FUNCTION  wilder#cmdline#is_user_command()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/cmdline.vim:608
Called 4 times
Total time:   0.000011
 Self time:   0.000011

count  total (s)   self (s)
    4              0.000009   return !empty(a:cmd) && a:cmd[0] >=# 'A' && a:cmd[0] <=# 'Z'

FUNCTION  <SNR>76_Remove_Matches()
    Defined: /opt/homebrew/Cellar/neovim/0.10.1/share/nvim/runtime/plugin/matchparen.vim:206
Called 224 times
Total time:   0.005519
 Self time:   0.005519

count  total (s)   self (s)
  224              0.000891   if exists('w:paren_hl_on') && w:paren_hl_on
  252              0.000663     while !empty(w:matchparen_ids)
  126              0.000963       silent! call remove(w:matchparen_ids, 0)->matchdelete()
  252              0.000369     endwhile
  126              0.000384     let w:paren_hl_on = 0
  224              0.000114   endif

FUNCTION  <SNR>60_normalise_attrs()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/highlight.vim:137
Called 12 times
Total time:   0.000493
 Self time:   0.000493

count  total (s)   self (s)
   12              0.000022   let l:attr_map = copy(s:attr_map)
                            
   30              0.000022   for l:attr in a:hl[2:]
   18              0.000019     if has_key(l:attr_map, l:attr)
   18              0.000018       let l:attr_map[l:attr] = 1
                                elseif l:attr[:1] ==# 'no' && has_key(l:attr_map, l:attr[2:])
                                  let l:attr_map[l:attr[2:]] = 0
   18              0.000005     endif
   30              0.000039   endfor
                            
   12              0.000009   let l:result = []
   96              0.000057   for l:attr in keys(l:attr_map)
   84              0.000059     if l:attr_map[l:attr]
   18              0.000019       call add(l:result, l:attr)
   84              0.000020     endif
   96              0.000024   endfor
                            
   12              0.000015   return a:hl[:1] + l:result

FUNCTION  search#GetCurrentSearchEngine()
    Defined: ~/.local/share/nvim/lazy/any-jump.vim/autoload/search.vim:173
Called 6 times
Total time:   0.001036
 Self time:   0.001036

count  total (s)   self (s)
    6              0.000012   let search_engine = g:any_jump_search_prefered_engine
    6              0.000996   let engine_ok     = executable(search_engine)
                            
    6              0.000007   if !engine_ok
                                let search_engine = search_engine == 'rg' ? 'ag' : 'rg'
    6              0.000002   endif
                            
    6              0.000004   return search_engine

FUNCTION  <SNR>58_make_lines()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer/popupmenu.vim:446
Called 6 times
Total time:   0.031450
 Self time:   0.007018

count  total (s)   self (s)
    6              0.000012   let l:Highlighter = get(a:state, 'highlighter', [])
                            
    6              0.000005   let l:height = a:ctx.height
                            
    6              0.000004   if l:height > 0
    6   0.000256   0.000246     let l:left_column_chunks = map(repeat([0], l:height), {-> []})
    6   0.002991   0.000035     call s:draw_columns(l:left_column_chunks, a:state.left, a:ctx, a:result)
                            
    6   0.000239   0.000214     let l:right_column_chunks = map(repeat([0], l:height), {-> []})
    6   0.012392   0.000051     call s:draw_columns(l:right_column_chunks, a:state.right, a:ctx, a:result)
                              else
                                let l:left_column_chunks = []
                                let l:right_column_chunks = []
    6              0.000002   endif
                            
                              " [[left_column, chunks, right_column]]
    6              0.000011   let l:raw_lines = repeat([0], l:height)
                              " [[chunks_width, total_width]]
    6              0.000009   let l:widths = repeat([0], l:height)
                            
                              " Draw each line and calculate the width taken by the chunks.
    6              0.000007   let [l:start, l:end] = a:state.page
    6              0.000004   let l:i = 0
  116              0.000067   while l:i < l:height
  110              0.000087     let l:index = l:start + l:i
  110              0.000065     if l:index <= l:end
  110   0.005716   0.000581       let l:chunks = s:draw_candidates_chunks(a:state, a:ctx, a:result, l:index)
                                else
                                  let l:chunks = []
  110              0.000028     endif
  110              0.000124     let l:left_column = l:left_column_chunks[l:i]
  110              0.000119     let l:right_column = l:right_column_chunks[l:i]
                            
  110   0.002019   0.000678     let l:left_width = wilder#render#chunks_displaywidth(l:left_column)
  110   0.001462   0.000521     let l:chunks_width = wilder#render#chunks_displaywidth(l:chunks)
  110   0.002066   0.000501     let l:right_width = wilder#render#chunks_displaywidth(l:right_column)
                            
  110              0.000146     let l:total_width = l:left_width + l:chunks_width + l:right_width
                            
                                " Store the longest line width seen so far.
  110              0.000092     if l:total_width > a:state.longest_line_width
   18              0.000018       let a:state.longest_line_width = l:total_width
  110              0.000027     endif
                            
  110              0.000093     let l:index = l:i - l:start
  110              0.000191     let l:raw_lines[l:i] = [l:left_column, l:chunks, l:right_column]
  110              0.000140     let l:widths[l:i] = [l:chunks_width, l:total_width]
                            
  110              0.000063     let l:i += 1
  116              0.000038   endwhile
                            
    6   0.000087   0.000021   let l:max_width = a:state.get_max_width(a:ctx, a:result)
    6   0.000086   0.000032   let l:min_width = a:state.get_min_width(a:ctx, a:result)
                            
                              " Try to fit the longest line seen so far, if possible.
    6              0.000014   let l:expected_width = min([ l:max_width, a:state.longest_line_width, ])
    6              0.000006   if l:expected_width < l:min_width
    6              0.000006     let l:expected_width = l:min_width
    6              0.000002   endif
                            
                              " lines is the list of list of chunks which will be drawn.
                              " Each element represents one line of the popupmenu.
    6              0.000010   let l:lines = repeat([0], l:height)
                            
    6              0.000003   let l:i = 0
  116              0.000097   while l:i < len(l:raw_lines)
  110              0.000161     let [l:left_column, l:chunks, l:right_column] = l:raw_lines[l:i]
  110              0.000138     let [l:chunks_width, l:total_width] = l:widths[l:i]
                            
                                " Truncate or pad if necessary
  110              0.000085     if l:total_width > l:expected_width
                                  let l:ellipsis = a:state.ellipsis
                                  let l:ellipsis_width = strdisplaywidth(l:ellipsis)
                            
                                  let l:left_right_width = l:total_width - l:chunks_width
                                  let l:truncated_width = l:expected_width - l:left_right_width - l:ellipsis_width
                                  let l:chunks = wilder#render#truncate_chunks(l:truncated_width, l:chunks)
                            
                                  call add(l:chunks, [l:ellipsis])
                                  call add(l:chunks, [repeat(' ', l:truncated_width - wilder#render#chunks_displaywidth(l:chunks))])
  110              0.000087     elseif l:total_width < l:expected_width
  110              0.000110       let l:to_pad = l:expected_width - l:total_width
  110              0.000177       let l:chunks += [[repeat(' ', l:to_pad)]]
  110              0.000026     endif
                            
  110              0.000220     let l:lines[l:i] = l:left_column + l:chunks + l:right_column
                            
  110              0.000059     let l:i += 1
  116              0.000036   endwhile
                            
    6              0.000006   return [l:lines, l:expected_width]

FUNCTION  <SNR>61_new()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer/nvim_api.vim:43
Called 2 times
Total time:   0.000690
 Self time:   0.000038

count  total (s)   self (s)
                              " If the buffer is somehow unloaded, bufload(self.state.buf) doesn't restore
                              " it so we have to create a new one
    2              0.000006   if !bufexists(self.state.buf) || !bufloaded(self.state.buf)
    1   0.000418   0.000005     let self.state.buf = s:new_buf()
    2              0.000001   endif
                            
    2              0.000004   if !bufexists(self.state.dummy_buf) || !bufloaded(self.state.dummy_buf)
    1   0.000243   0.000005     let self.state.dummy_buf = s:new_buf()
    2              0.000001   endif
                            
    2              0.000005   let self.state.normal_highlight = get(a:opts, 'normal_highlight', 'Normal')
    2              0.000003   let self.state.pumblend = get(a:opts, 'pumblend', -1)
    2              0.000003   let self.state.zindex = get(a:opts, 'zindex', 0)

FUNCTION  <lambda>1253()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/cmdline.vim:793
Called 1 time
Total time:   0.000137
 Self time:   0.000006

count  total (s)   self (s)
                            return wilder#cmdline#get_fuzzy_completion( ctx, x, l:Completion_func, a:fuzzy, a:use_python)

FUNCTION  <lambda>172()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/pipe/branch.vim:5
Called 4 times
Total time:   0.000016
 Self time:   0.000016

count  total (s)   self (s)
                            return {ctx -> s:branch(a:args, ctx, x)}

FUNCTION  <lambda>1255()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/pipeline.vim:171
Called 1 time
Total time:   0.000177
 Self time:   0.000003

count  total (s)   self (s)
                            return s:wait_start(l:state, ctx)

FUNCTION  <SNR>111_handle()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/pipeline.vim:27
Called 20 times
Total time:   0.023528
 Self time:   0.000776

count  total (s)   self (s)
   20              0.000040   let l:handler_id = get(a:ctx, 'handler_id', 0)
                            
   20              0.000032   if !has_key(s:handler_registry, l:handler_id)
                                " only show error if handler has not been cleared
                                if l:handler_id > s:last_cleared_id
                                  let l:message = 'wilder#' . a:key . '()'
                                  let l:message .= ' handler not found - id: ' . l:handler_id
                                  let l:message .= ': ' . string(a:x)
                            
                                  call s:echoerr(l:message)
                                endif
                            
                                return
   20              0.000005   endif
                            
   20              0.000013   let l:X = a:x
   20              0.000030   let l:handler = s:handler_registry[l:handler_id]
                            
   20              0.000020   if get(a:ctx, 'partial', 0)
                                if type(l:X) isnot v:t_list
                                  call l:handler.on_error(a:ctx, 'pipeline: ' . s:partial_error_message(a:key, l:X))
                                  return
                                endif
                            
                                if !has_key(s:partial_results, l:handler_id)
                                  let s:partial_results[l:handler_id] = l:X
                                else
                                  let s:partial_results[l:handler_id] += l:X
                                endif
                            
                                return
   20              0.000005   endif
                            
   20              0.000026   unlet s:handler_registry[l:handler_id]
                            
   20              0.000026   if has_key(s:partial_results, l:handler_id)
                                if type(l:X) isnot v:t_list
                                  call l:handler.on_error(a:ctx, 'pipeline: ' . s:partial_error_message(a:key, l:X))
                                  return
                                endif
                            
                                let l:X = s:partial_results[l:handler_id] + l:X
                                unlet s:partial_results[l:handler_id]
   20              0.000005   endif
                            
   20              0.000015   if a:key ==# 'reject'
                                call l:handler.on_error(a:ctx, l:X)
                                return
   20              0.000005   endif
                            
   20              0.000007   try
   20   0.022811   0.000060     call l:handler.on_finish(a:ctx, l:X)
                              catch
                                call l:handler.on_error(a:ctx, 'pipeline: ' . v:exception)
   20              0.000007   endtry

FUNCTION  <lambda>74()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer/popupmenu.vim:843
Called 10 times
Total time:   0.000113
 Self time:   0.000053

count  total (s)   self (s)
                            return s:clamp(float2nr(l:percent * (&lines - 1)), a:is_height)

FUNCTION  <lambda>75()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer/popupmenu.vim:832
Called 12 times
Total time:   0.000057
 Self time:   0.000040

count  total (s)   self (s)
                            return s:clamp(a:opt, a:is_height)

FUNCTION  <lambda>76()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer/popupmenu.vim:845
Called 6 times
Total time:   0.000066
 Self time:   0.000031

count  total (s)   self (s)
                            return s:clamp(float2nr(l:percent * &columns), a:is_height)

FUNCTION  <lambda>77()
    Defined: ~/.local/share/nvim/lazy/wilder.nvim/autoload/wilder/renderer/popupmenu.vim:845
Called 6 times
Total time:   0.000053
 Self time:   0.000023

count  total (s)   self (s)
                            return s:clamp(float2nr(l:percent * &columns), a:is_height)

FUNCTIONS SORTED ON TOTAL TIME
count  total (s)   self (s)  function
    3   0.178406   0.005599  <SNR>16_Jump()
    3   0.082599   0.000418  search#SearchDefinitions()
    3   0.081448   0.000481  <SNR>116_RunRgDefinitionSearch()
 4572   0.072947   0.064079  wilder#lua#wrap()
    6   0.072612   0.000184  <SNR>58_render_lines_from_timer()
    6   0.072428   0.015491  <SNR>58_render_lines()
  116   0.057243   0.001564  wilder#lua#call_wrapped_function()
  210   0.051764   0.046426  <SNR>76_Highlight_Matching_Pair()
    3   0.043791   0.000081  search#SearchUsages()
    3   0.043367   0.000650  <SNR>116_RunRgUsagesSearch()
    3   0.040744   0.000044  <SNR>16_CreateUi()
    3   0.040701   0.001529  <SNR>16_CreateNvimUi()
   44   0.035603   0.003643  <SNR>111_run()
    6   0.031450   0.007018  <SNR>58_make_lines()
   24   0.024865   0.000319  <SNR>103_RunDeferred()
   20   0.023627   0.000100  wilder#pipeline#resolve()
   20   0.023528   0.000776  <SNR>111_handle()
    6   0.023290   0.002215  <SNR>104_NvimAttach()
    3   0.023199   0.000041  <SNR>102_Attach()
    7   0.019191             <SNR>1_LoadFTPlugin()

FUNCTIONS SORTED ON SELF TIME
count  total (s)   self (s)  function
 4572   0.072947   0.064079  wilder#lua#wrap()
  210   0.051764   0.046426  <SNR>76_Highlight_Matching_Pair()
    7              0.019191  <SNR>1_LoadFTPlugin()
    6   0.072428   0.015491  <SNR>58_render_lines()
    7              0.015006  <SNR>96_SynSet()
    6   0.014902   0.013967  <SNR>116_ParseRgResults()
    6              0.013353  <SNR>110_redraw()
  117              0.007354  21()
    6   0.031450   0.007018  <SNR>58_make_lines()
    3   0.178406   0.005599  <SNR>16_Jump()
  224              0.005519  <SNR>76_Remove_Matches()
    7              0.005200  <SNR>2_LoadIndent()
  330              0.003846  wilder#render#chunks_displaywidth()
   44   0.035603   0.003643  <SNR>111_run()
    3   0.016665   0.003215  AnyJumpHandleClose()
   24   0.008551   0.003207  <SNR>58_draw_top_or_bottom_line()
   12   0.015297   0.002330  <SNR>58_draw_columns()
  195              0.002269  24()
   60   0.003922   0.002224  37()
    6   0.023290   0.002215  <SNR>104_NvimAttach()

